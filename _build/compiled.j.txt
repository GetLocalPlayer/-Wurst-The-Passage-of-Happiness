// this script was compiled with wurst 1.8.1.0-jenkins-Wurst-1339
globals
// real bj_GAME_STARTED_THRESHOLD=0.
// integer bj_MAX_PLAYERS=0
// integer bj_PLAYER_NEUTRAL_VICTIM=0
// integer bj_MAX_PLAYER_SLOTS=0
// integer bj_MAX_SKELETONS=0
// integer bj_MAX_STOCK_ITEM_SLOTS=0
// integer bj_MAX_STOCK_UNIT_SLOTS=0
// integer bj_MAX_ITEM_LEVEL=0
// real bj_TOD_DAWN=0.
// real bj_TOD_DUSK=0.
// real bj_STOCK_RESTOCK_INITIAL_DELAY=0.
// real bj_STOCK_RESTOCK_INTERVAL=0.
// integer bj_STOCK_MAX_ITERATIONS=0
// real bj_RESCUE_PING_TIME=0.
// integer bj_MAX_QUEUED_TRIGGERS=0
// real bj_QUEUED_TRIGGER_TIMEOUT=0.
// real bj_CORPSE_MAX_DEATH_TIME=0.
// force bj_FORCE_ALL_PLAYERS=null
// rect bj_mapInitialPlayableArea=null
// boolean bj_slotControlReady=false
// timer bj_gameStartedTimer=null
// boolean bj_isSinglePlayer=false
// trigger bj_dncSoundsDay=null
// trigger bj_dncSoundsNight=null
// sound bj_dayAmbientSound=null
// sound bj_nightAmbientSound=null
// trigger bj_dncSoundsDawn=null
// trigger bj_dncSoundsDusk=null
// sound bj_dawnSound=null
// sound bj_duskSound=null
// boolean bj_useDawnDuskSounds=false
// boolean bj_dncIsDaytime=false
// sound bj_rescueSound=null
// sound bj_victoryDialogSound=null
// trigger bj_stockItemPurchased=null
// timer bj_stockUpdateTimer=null
// integer bj_stockPickedItemLevel=0
// itemtype bj_stockPickedItemType=null
// trigger bj_rescueUnitBehavior=null
// boolean bj_rescueChangeColorUnit=false
// boolean bj_rescueChangeColorBldg=false
// integer bj_queuedExecTotal=0
// timer bj_queuedExecTimeoutTimer=null
// trigger bj_queuedExecTimeout=null
// integer bj_groupEnumTypeId=0
// player bj_groupEnumOwningPlayer=null
// location bj_enumDestructableCenter=null
// real bj_enumDestructableRadius=0.
// boolean bj_changeLevelShowScores=false
// string bj_changeLevelMapName=null
// group bj_suspendDecayFleshGroup=null
// group bj_suspendDecayBoneGroup=null
// timer bj_delayedSuspendDecayTimer=null
// trigger bj_delayedSuspendDecayTrig=null
// integer bj_livingPlayerUnitsTypeId=0
// integer PLAYER_NEUTRAL_PASSIVE=0
// integer PLAYER_NEUTRAL_AGGRESSIVE=0
// playergameresult PLAYER_GAME_RESULT_VICTORY=null
// playergameresult PLAYER_GAME_RESULT_DEFEAT=null
// playergameresult PLAYER_GAME_RESULT_NEUTRAL=null
// alliancetype ALLIANCE_PASSIVE=null
// version VERSION_REIGN_OF_CHAOS=null
// racepreference RACE_PREF_HUMAN=null
// mapcontrol MAP_CONTROL_USER=null
// mapcontrol MAP_CONTROL_RESCUABLE=null
// gametype GAME_TYPE_MELEE=null
// gametype GAME_TYPE_FFA=null
// gametype GAME_TYPE_USE_MAP_SETTINGS=null
// gametype GAME_TYPE_ONE_ON_ONE=null
// gametype GAME_TYPE_TWO_TEAM_PLAY=null
// gametype GAME_TYPE_THREE_TEAM_PLAY=null
// gametype GAME_TYPE_FOUR_TEAM_PLAY=null
// placement MAP_PLACEMENT_USE_MAP_SETTINGS=null
// playerslotstate PLAYER_SLOT_STATE_PLAYING=null
// volumegroup SOUND_VOLUMEGROUP_UI=null
// fgamestate GAME_STATE_TIME_OF_DAY=null
// playerstate PLAYER_STATE_GIVES_BOUNTY=null
// unitstate UNIT_STATE_LIFE=null
// playerevent EVENT_PLAYER_LEAVE=null
// playerevent EVENT_PLAYER_END_CINEMATIC=null
// playerunitevent EVENT_PLAYER_UNIT_RESCUED=null
// playerunitevent EVENT_PLAYER_UNIT_DEATH=null
// playerunitevent EVENT_PLAYER_UNIT_ISSUED_ORDER=null
// playerunitevent EVENT_PLAYER_UNIT_DROP_ITEM=null
// playerunitevent EVENT_PLAYER_UNIT_PICKUP_ITEM=null
// unitevent EVENT_UNIT_DAMAGED=null
// playerevent EVENT_PLAYER_ARROW_LEFT_DOWN=null
// playerevent EVENT_PLAYER_ARROW_LEFT_UP=null
// playerevent EVENT_PLAYER_ARROW_RIGHT_DOWN=null
// playerevent EVENT_PLAYER_ARROW_RIGHT_UP=null
// playerevent EVENT_PLAYER_ARROW_DOWN_DOWN=null
// playerevent EVENT_PLAYER_ARROW_DOWN_UP=null
// playerevent EVENT_PLAYER_ARROW_UP_DOWN=null
// playerevent EVENT_PLAYER_ARROW_UP_UP=null
// playerevent EVENT_PLAYER_MOUSE_DOWN=null
// playerevent EVENT_PLAYER_MOUSE_UP=null
// playerevent EVENT_PLAYER_MOUSE_MOVE=null
// playerunitevent EVENT_PLAYER_UNIT_SELL_ITEM=null
// playerunitevent EVENT_PLAYER_UNIT_SPELL_EFFECT=null
// playerunitevent EVENT_PLAYER_UNIT_SPELL_ENDCAST=null
// limitop LESS_THAN=null
// limitop EQUAL=null
// limitop GREATER_THAN_OR_EQUAL=null
// unittype UNIT_TYPE_HERO=null
// unittype UNIT_TYPE_STRUCTURE=null
// itemtype ITEM_TYPE_PERMANENT=null
// itemtype ITEM_TYPE_CHARGED=null
// itemtype ITEM_TYPE_ARTIFACT=null
// integer CAMERA_MARGIN_LEFT=0
// integer CAMERA_MARGIN_RIGHT=0
// integer CAMERA_MARGIN_TOP=0
// integer CAMERA_MARGIN_BOTTOM=0
// originframetype ORIGIN_FRAME_GAME_UI=null
// originframetype ORIGIN_FRAME_WORLD_FRAME=null
rect gg_rct_Finish=null
rect gg_rct_Checkpoint=null
rect gg_rct_Start=null
rect gg_rct_RazorStart=null
rect gg_rct_RazorFinish=null
rect gg_rct_ShieldGeneratorSpawn=null
string Abilities_farseerMissile=null
string Abilities_vengeanceMissile=null
integer AbilityIds_inventory=0
real Angle_DEGTORAD=0.
real Angle_RADTODEG=0.
real Basics_ANIMATION_PERIOD=0.
real Basics_MAX_COLLISION_SIZE=0.
player Basics_DUMMY_PLAYER=null
integer BitSet_BITSET_SIZE=0
integer array BitSet_pows
real Character_REVIVE_TIME=0.
unit Character_character=null
real Character_checkpoint_x=0.
real Character_checkpoint_y=0.
playerevent ClosureEvents_EVENT_PLAYER_CHAT_FILTER=null
trigger ClosureEvents_unitTrig=null
trigger ClosureEvents_leaveTrig=null
trigger ClosureEvents_keyTrig=null
integer array ClosureEvents_eventidToIndex
integer ClosureEvents_eventTypeCounter=0
integer EventListener_castMap=0
integer EventListener_castMapCasters=0
integer array EventListener_generalListenersFirsts
integer array EventListener_unitListenersFirsts
boolean EventListener_useMouseEvents=false
group ClosureForGroups_DUMMY_GROUP=null
integer array ClosureForGroups_tempCallbacks
integer ClosureForGroups_tempCallbacksCount=0
integer ClosureForGroups_maxCount=0
integer ClosureForGroups_iterCount=0
filterfunc ClosureForGroups_filter=null
integer array ClosureForGroups_tempCallbacksD
integer ClosureForGroups_tempCallbacksDCount=0
integer ClosureTimers_x=0
integer array Colors_PLAYER_COLORS_red
integer array Colors_PLAYER_COLORS_green
integer array Colors_PLAYER_COLORS_blue
string array Colors_hexs
integer Colors_decs=0
integer ErrorHandling_MUTE_ERROR_DURATION=0
integer ErrorHandling_PRIMARY_ERROR_KEY=0
hashtable ErrorHandling_HT=null
boolean ErrorHandling_suppressErrorMessages=false
integer EventHelper_rectMap=0
framehandle Framehandle_GAME_UI=null
real Framehandle_SCREEN_TOP_x=0.
real Framehandle_SCREEN_TOP_y=0.
real Framehandle_SCREEN_BOTTOM_x=0.
real Framehandle_SCREEN_BOTTOM_y=0.
integer Framehandle_BLZ_FRAMENAME_MAXLENGTH=0
real GameTimer_currentTime=0.
group Group_ENUM_GROUP=null
hashtable HashList_ht=null
hashtable HashList_occurences=null
integer Integer_INT_MAX=0
string Lightning_LIGHTNING_CHAIN_LIGHTNING_PRIMARY=null
string Lightning_LIGHTNING_DRAIN=null
string Lightning_LIGHTNING_FINGER_OF_DEATH=null
boolean MagicFunctions_compiletime=false
rect MapBounds_playableMapRect=null
rect MapBounds_boundRect=null
region MapBounds_boundRegion=null
real MapBounds_playableMin_x=0.
real MapBounds_playableMin_y=0.
real MapBounds_playableMax_x=0.
real MapBounds_playableMax_y=0.
real MapBounds_boundMin_x=0.
real MapBounds_boundMin_y=0.
real MapBounds_boundMax_x=0.
real MapBounds_boundMax_y=0.
real Maths_PI=0.
real Matrices_ZERO44_m00=0.
real Matrices_ZERO44_m01=0.
real Matrices_ZERO44_m02=0.
real Matrices_ZERO44_m03=0.
real Matrices_ZERO44_m10=0.
real Matrices_ZERO44_m11=0.
real Matrices_ZERO44_m12=0.
real Matrices_ZERO44_m13=0.
real Matrices_ZERO44_m20=0.
real Matrices_ZERO44_m21=0.
real Matrices_ZERO44_m22=0.
real Matrices_ZERO44_m23=0.
real Matrices_ZERO44_m30=0.
real Matrices_ZERO44_m31=0.
real Matrices_ZERO44_m32=0.
real Matrices_ZERO44_m33=0.
integer Missile_LinkedListModule_first=0
string ObjectIds_CHARMAP=null
trigger OnUnitEnterLeave_eventTrigger=null
group OnUnitEnterLeave_preplacedUnits=null
unit array OnUnitEnterLeave_tempUnits
integer OnUnitEnterLeave_tempUnitsCount=0
integer OnUnitEnterLeave_ABILITY_ID=0
integer OrderIds_undefend=0
player array Player_players
player Player_localPlayer=null
boolean Preloader_autoFinish=false
group Preloader_dumg=null
unit Preloader_dum=null
integer Printing_DEBUG_LEVEL=0
real Printing_DEBUG_MSG_DURATION=0.
boolean Raycast_FAIL_2D_intersects=false
real Raycast_FAIL_2D_point_x=0.
real Raycast_FAIL_2D_point_y=0.
real Raycast_FAIL_2D_distance=0.
real Raycast_EPSILON=0.
real Razor_START_POS_x=0.
real Razor_START_POS_y=0.
real Razor_FINISH_POS_x=0.
real Razor_FINISH_POS_y=0.
real Razor_WIDTH=0.
real Razor_SPEED=0.
integer Razor_LinkedListModule_first=0
integer Razor_LinkedListModule_last=0
integer Razor_LinkedListModule_size=0
real Real_REAL_MAX=0.
trigger array RegisterEvents_t
integer RegisterEvents_onCastMap=0
string Segment_lightType=null
string Segment_touchEffect=null
timer Segment_clock=null
integer Segment_LinkedListModule_first=0
integer Segment_LinkedListModule_last=0
integer Segment_LinkedListModule_size=0
integer ShieldGenerator_ITEM_ID=0
integer ShieldGenerator_FRONT_SHIELD_ID=0
integer ShieldGenerator_ABOVE_SHIELD_ID=0
real array ShieldGenerator_ABOVE_SHIELD_POINTS_x
real array ShieldGenerator_ABOVE_SHIELD_POINTS_y
real array ShieldGenerator_ABOVE_SHIELD_POINTS_z
real array ShieldGenerator_FRONT_SHIELD_POINTS_x
real array ShieldGenerator_FRONT_SHIELD_POINTS_y
real array ShieldGenerator_FRONT_SHIELD_POINTS_z
integer Shield_LinkedListModule_first=0
integer Shield_LinkedListModule_last=0
integer Shield_LinkedListModule_size=0
string String_charset=null
string String_numberset=null
hashtable Table_ht=null
timer array TimerUtils_freeTimers
integer TimerUtils_freeTimersCount=0
integer TimerUtils_timerData=0
integer TimerUtils_HELD=0
integer TypeCasting_typecastdata=0
real TypeCasting_R2I_PRECISION=0.
integer UnitIds_shade=0
trigger UnitIndexer_onIndexTrigger=null
trigger UnitIndexer_onDeindexTrigger=null
unit array UnitIndexer_tempUnits
integer UnitIndexer_tempUnitsCount=0
real Vectors_ZERO2_x=0.
real Vectors_ZERO2_y=0.
real Vectors_ZERO3_x=0.
real Vectors_ZERO3_y=0.
real Vectors_ZERO3_z=0.
location Vectors_tempLoc=null
hashtable hashtable_compiletime=null
hashtable hashtable_compiletime_478=null
hashtable hashtable_compiletime_479=null
hashtable hashtable_compiletime_480=null
integer array CallbackSingle_nextFree
integer CallbackSingle_firstFree=0
integer CallbackSingle_maxIndex=0
integer array CallbackSingle_typeId
integer array EventListener_nextFree
integer EventListener_firstFree=0
integer EventListener_maxIndex=0
integer array EventListener_typeId
integer array CallbackCounted_nextFree
integer CallbackCounted_firstFree=0
integer CallbackCounted_maxIndex=0
integer array CallbackCounted_typeId
integer array OnCastListener_nextFree
integer OnCastListener_firstFree=0
integer OnCastListener_maxIndex=0
integer array OnCastListener_typeId
integer array ForGroupCallback_nextFree
integer ForGroupCallback_firstFree=0
integer ForGroupCallback_maxIndex=0
integer array ForGroupCallback_typeId
integer array ForGroupCallbackD_nextFree
integer ForGroupCallbackD_firstFree=0
integer ForGroupCallbackD_maxIndex=0
integer array ForGroupCallbackD_typeId
integer array CallbackPeriodic_nextFree
integer CallbackPeriodic_firstFree=0
integer CallbackPeriodic_maxIndex=0
integer array CallbackPeriodic_typeId
integer array HashList_typeId
integer array Table_nextFree
integer Table_firstFree=0
integer Table_maxIndex=0
integer array Table_typeId
integer array W3UDefinition_nextFree
integer W3UDefinition_firstFree=0
integer W3UDefinition_maxIndex=0
integer array W3UDefinition_typeId
integer array Comparator_nextFree
integer Comparator_firstFree=0
integer Comparator_maxIndex=0
integer array LLEntry_nextFree
integer LLEntry_firstFree=0
integer LLEntry_maxIndex=0
integer array LLIterator_nextFree
integer LLIterator_firstFree=0
integer LLIterator_maxIndex=0
integer array LLIterator_typeId
integer array LinkedList_nextFree
integer LinkedList_firstFree=0
integer LinkedList_maxIndex=0
integer array LinkedList_typeId
integer array BackIterator_nextFree
integer BackIterator_firstFree=0
integer BackIterator_maxIndex=0
integer array Iterator_nextFree
integer Iterator_firstFree=0
integer Iterator_maxIndex=0
integer array IdGenerator_nextFree
integer IdGenerator_firstFree=0
integer IdGenerator_maxIndex=0
integer array OrderStringFactory_nextFree
integer OrderStringFactory_firstFree=0
integer OrderStringFactory_maxIndex=0
integer array Razor_nextFree
integer Razor_firstFree=0
integer Razor_maxIndex=0
integer array Razor_typeId
integer array BackIterator_nextFree_15
integer BackIterator_firstFree_7=0
integer BackIterator_maxIndex_11=0
integer array Iterator_nextFree_168
integer Iterator_firstFree_160=0
integer Iterator_maxIndex_164=0
integer array Segment_nextFree
integer Segment_firstFree=0
integer Segment_maxIndex=0
integer array Segment_typeId
integer array BackIterator_nextFree_16
integer BackIterator_firstFree_8=0
integer BackIterator_maxIndex_12=0
integer array Iterator_nextFree_169
integer Iterator_firstFree_161=0
integer Iterator_maxIndex_165=0
integer array Iterator_typeId
integer array Shield_nextFree
integer Shield_firstFree=0
integer Shield_maxIndex=0
integer array Shield_typeId
integer array BackIterator_nextFree_17
integer BackIterator_firstFree_9=0
integer BackIterator_maxIndex_13=0
integer array Iterator_nextFree_170
integer Iterator_firstFree_162=0
integer Iterator_maxIndex_166=0
integer array UnitIndex_nextFree
integer UnitIndex_firstFree=0
integer UnitIndex_maxIndex=0
integer array UnitIndex_typeId
unit array dyingUnit
timerdialog array reviveTimerDialog
integer array EventListener_eventId
integer array EventListener_uid
integer array EventListener_next
integer array EventListener_prev
integer array OnCastListener_next
integer array OnCastListener_prev
integer array OnCastListener_abilId
unit array OnCastListener_eventUnit
integer array w_count
integer array CallbackCounted_count
integer array CallbackCounted_maxCount
timer array CallbackCounted_t
timer array CallbackPeriodic_t
timer array CallbackSingle_t
integer array HashList_size
integer array HashMap_size
integer array IterableMap_keys
integer array HeroPreset_properNames
string array HeroPreset_heroAbilityString
string array HeroPreset_normalAbilityString
integer array result
integer array LLEntry_elem
integer array LLEntry_prev
integer array LLEntry_next
integer array LLIterator_dummy
integer array LLIterator_current
integer array LLIterator_parent
boolean array LLIterator_destroyOnClose
integer array LinkedList_dummy
integer array LinkedList_size
integer array choice
real array Razor_p1_x
real array Razor_p1_y
real array Razor_p2_x
real array Razor_p2_y
real array Razor_dir_x
real array Razor_dir_y
real array Razor_speed
lightning array Razor_ltn
string array Razor_hitFxPath
integer array Razor_LinkedListModule_prev
integer array Razor_LinkedListModule_next
real array ray_origin_x
real array ray_origin_y
real array ray_direction_x
real array ray_direction_y
boolean array castResult_intersects
real array castResult_distance
integer array this_592
integer array this
real array angularVelocity_radians
real array Segment_p1_x
real array Segment_p1_y
real array Segment_p1_z
real array Segment_p2_x
real array Segment_p2_y
real array Segment_p2_z
real array Segment_pos_x
real array Segment_pos_y
real array Segment_pos_z
real array Segment_width
lightning array Segment_light
real array Segment_angularVelocity_radians
integer array Segment_LinkedListModule_next
integer array this_593
integer array Iterator_current
boolean array Iterator_destroyOnClose
unit array caster
integer array id
integer array id_482
unit array caster_455
integer array shield
lightning array Shield_l1
lightning array Shield_l2
lightning array Shield_l3
lightning array Shield_l4
integer array Shield_LinkedListModule_prev
integer array Shield_LinkedListModule_next
real array alpha
lightning array timed1
lightning array timed2
lightning array timed3
lightning array timed4
unit array UnitIndex__unit
string array W3UDefinition_def_key
integer wurst_stack_depth=0
string array wurst_stack
real real_asAngleDegrees_return_radians=0.
real real_fromDeg_return_radians=0.
real angle_op_mult_return_radians=0.
real vec3_toVec2_return_x=0.
real vec3_toVec2_return_y=0.
real unit_getPos_return_x=0.
real unit_getPos_return_y=0.
real rect_getCenter_return_x=0.
real rect_getCenter_return_y=0.
real destructable_getPos_return_x=0.
real destructable_getPos_return_y=0.
real EventData_getAbilityTargetPos_return_x=0.
real EventData_getAbilityTargetPos_return_y=0.
real EventData_getSpellTargetPos_return_x=0.
real EventData_getSpellTargetPos_return_y=0.
real vec2_toVec3_return_x=0.
real vec2_toVec3_return_y=0.
real vec2_toVec3_return_z=0.
real vec2_op_plus_return_x=0.
real vec2_op_plus_return_y=0.
real vec2_op_mult_return_x=0.
real vec2_op_mult_return_y=0.
string createObjectDefinition_return_key=null
real vec2_op_minus_return_x=0.
real vec2_op_minus_return_y=0.
boolean ray2d_castToSegment_return_intersects=false
real ray2d_castToSegment_return_point_x=0.
real ray2d_castToSegment_return_point_y=0.
real ray2d_castToSegment_return_distance=0.
boolean ray2d_castToCircle_return_first_intersects=false
real ray2d_castToCircle_return_first_point_x=0.
real ray2d_castToCircle_return_first_point_y=0.
real ray2d_castToCircle_return_first_distance=0.
boolean ray2d_castToCircle_return_second_intersects=false
real ray2d_castToCircle_return_second_point_x=0.
real ray2d_castToCircle_return_second_point_y=0.
real ray2d_castToCircle_return_second_distance=0.
real vec3_op_plus_return_x=0.
real vec3_op_plus_return_y=0.
real vec3_op_plus_return_z=0.
real unit_getFacingAngle_return_radians=0.
real vec2_withRealZ_return_x=0.
real vec2_withRealZ_return_y=0.
real vec2_withRealZ_return_z=0.
real unit_getPos3Real_return_x=0.
real unit_getPos3Real_return_y=0.
real unit_getPos3Real_return_z=0.
real vec2_norm_return_x=0.
real vec2_norm_return_y=0.
real vec2_rotate_return_x=0.
real vec2_rotate_return_y=0.
real vec2_withTerrainZ_return_x=0.
real vec2_withTerrainZ_return_y=0.
real vec2_withTerrainZ_return_z=0.
real vec2_normalizedPointerTo_return_x=0.
real vec2_normalizedPointerTo_return_y=0.
real vec3_rotate_return_x=0.
real vec3_rotate_return_y=0.
real vec3_rotate_return_z=0.
real dispatch_Segment_Segment_Segment_getA_return_x=0.
real dispatch_Segment_Segment_Segment_getA_return_y=0.
real dispatch_Segment_Segment_Segment_getA_return_z=0.
real dispatch_Segment_Segment_Segment_getB_return_x=0.
real dispatch_Segment_Segment_Segment_getB_return_y=0.
real dispatch_Segment_Segment_Segment_getB_return_z=0.
real Segment_getA_return_x=0.
real Segment_getA_return_y=0.
real Segment_getA_return_z=0.
real Segment_getB_return_x=0.
real Segment_getB_return_y=0.
real Segment_getB_return_z=0.
code ref_function_init_Abilities=null
code ref_function_init_AbilityIds=null
code ref_function_init_Real=null
code ref_function_init_Integer=null
code ref_function_init_BitSet=null
code ref_function_init_String=null
code ref_function_init_TargetsAllowed=null
code ref_function_init_Angle=null
code ref_function_init_Vectors=null
code ref_function_init_Destructable=null
code ref_function_init_Player=null
code ref_function_init_Maths=null
code ref_function_init_Printing=null
code ref_function_init_MagicFunctions=null
code ref_function_init_Basics=null
code ref_function_init_GameTimer=null
code ref_function_init_ErrorHandling=null
code ref_function_init_Matrices=null
code ref_function_init_Quaternion=null
code ref_function_init_Table=null
code ref_function_init_Playercolor=null
code ref_function_bridge_init_Colors=null
code ref_function_bridge_init_Framehandle=null
code ref_function_init_Group=null
code ref_function_init_Lightning=null
code ref_function_init_WeatherEffects=null
code ref_function_bridge_init_TypeCasting=null
code ref_function_init_HashList=null
code ref_function_bridge_init_EventHelper=null
code ref_function_init_AbilityObjEditing=null
code ref_function_init_AttachmentPoints=null
code ref_function_init_BuffIds=null
code ref_function_init_Buildings=null
code ref_function_init_ClosureForGroups=null
code ref_function_bridge_init_LinkedList=null
code ref_function_init_ObjectIds=null
code ref_function_bridge_init_TimerUtils=null
code ref_function_init_ClosureTimers=null
code ref_function_init_UnitIds=null
code ref_function_init_MapBounds=null
code ref_function_bridge_init_Preloader=null
code ref_function_bridge_init_ObjectIdGenerator=null
code ref_function_bridge_init_ChannelAbilityPreset=null
code ref_function_bridge_init_RegisterEvents=null
code ref_function_init_Orders=null
code ref_function_bridge_init_OnUnitEnterLeave=null
code ref_function_init_UnitIndexer=null
code ref_function_bridge_init_ClosureEvents=null
code ref_function_bridge_init_Character=null
code ref_function_init_Doodads=null
code ref_function_init_Icons=null
code ref_function_init_ItemIds=null
code ref_function_bridge_init_Missile=null
code ref_function_init_Objects=null
code ref_function_init_Raycast=null
code ref_function_init_Sounds=null
code ref_function_init_Soundsets=null
code ref_function_init_Textures=null
code ref_function_init_UI=null
code ref_function_init_Units=null
code ref_function_bridge_init_Segment=null
code ref_function_bridge_init_Razor=null
code ref_function_bridge_init_ShieldGenerator=null
code ref_function_code__addAction_Character=null
code ref_function_code__addAction_Character_538=null
code ref_function_code__onUnitIndex_ClosureEvents=null
code ref_function_bridge_code__onUnitDeindex_ClosureEvents=null
code ref_function_bridge_EventListener_generalEventCallback=null
code ref_function_bridge_code__Filter_ClosureForGroups=null
code ref_function_bridge_code__EnumDestructablesInRect_ClosureForGroups=null
code ref_function_code__startPeriodic_GameTimer=null
code ref_function_bridge_code__registerPlayerUnitEvent_RegisterEvents=null
code ref_function_bridge_Segment_updateAll=null
code ref_function_bridge_code__onEnter_UnitIndexer=null
code ref_function_bridge_code__onLeave_UnitIndexer=null
code ref_function_bridge_code__addAction_nullTimer_ClosureEvents=null
code ref_function_bridge_code__addAction_nullTimer_ClosureEvents_510=null
code ref_function_bridge_code__addAction_nullTimer_ClosureEvents_511=null
code ref_function_bridge_code__registerPlayerUnitEvent_nullTimer_ClosureEvents=null
code ref_function_bridge_CallbackCounted_staticCallback=null
code ref_function_bridge_CallbackPeriodic_staticCallback=null
code ref_function_bridge_code__start_CallbackSingle_ClosureTimers=null
code ref_function_code__Filter_registerEnterRegion_nullTimer_OnUnitEnterLeave=null
code ref_function_code__registerPlayerUnitEvent_nullTimer_OnUnitEnterLeave=null
code ref_function_code__ForGroup_nullTimer_OnUnitEnterLeave=null
unit group_nexttempReturn=null
timer getTimertempReturn=null
trigger dispatch_Table_Table_Table_loadTriggertempReturn=null
framehandle createFrametempReturn=null
trigger triggerFromIndextempReturn=null
endglobals
native UnitAlive takes unit id_1 returns boolean
function CreateNeutralPassiveBuildings takes nothing returns nothing
	local player p = Player(PLAYER_NEUTRAL_PASSIVE)
	call BlzCreateUnitWithSkin(p, 1852010546, 2272.0,  - 6752.0, 270.000, 1852010546)
	call BlzCreateUnitWithSkin(p, 1852010546,  - 2336.0,  - 2144.0, 270.000, 1852010546)
	call BlzCreateUnitWithSkin(p, 1852010546,  - 6752.0, 2272.0, 270.000, 1852010546)
	set p = null
endfunction

function CreatePlayerBuildings takes nothing returns nothing
endfunction

function CreatePlayerUnits takes nothing returns nothing
endfunction

function CreateAllUnits takes nothing returns nothing
	call CreateNeutralPassiveBuildings()
	call CreatePlayerBuildings()
	call CreatePlayerUnits()
endfunction

function CreateRegions takes nothing returns nothing
	set gg_rct_Finish = Rect( - 6816.0, 2208.0,  - 6688.0, 2336.0)
	set gg_rct_Checkpoint = Rect( - 2432.0,  - 2240.0,  - 2240.0,  - 2048.0)
	set gg_rct_Start = Rect(2176.0,  - 6848.0, 2368.0,  - 6656.0)
	call Rect( - 7040.0, 256.0,  - 6912.0, 384.0)
	call Rect( - 4096.0,  - 2688.0,  - 3968.0,  - 2560.0)
	call Rect( - 4864.0, 2432.0,  - 4736.0, 2560.0)
	call Rect( - 1920.0,  - 512.0,  - 1792.0,  - 384.0)
	call Rect( - 6144.0, 1536.0,  - 6016.0, 1664.0)
	call Rect( - 2944.0,  - 1664.0,  - 2816.0,  - 1536.0)
	set gg_rct_RazorStart = Rect( - 2048.0,  - 2560.0,  - 1920.0,  - 2432.0)
	set gg_rct_RazorFinish = Rect(1792.0,  - 6400.0, 1920.0,  - 6272.0)
	set gg_rct_ShieldGeneratorSpawn = Rect( - 3392.0,  - 1376.0,  - 3264.0,  - 1248.0)
endfunction

function InitGlobals takes nothing returns nothing
endfunction

function Loglevel_getTag takes integer this_1 returns string
	local integer temp = this_1
	if temp == 0 then
		return "|cffADADADtrace|r"
	elseif temp == 1 then
		return "|cff2685DCdebug|r"
	elseif temp == 2 then
		return "|cffFFCC00info|r"
	elseif temp == 3 then
		return "|cffF47E3Ewarning|r"
	else
		return "|cffFB2700error|r"
	endif
endfunction

function printLog takes player showTo, integer loglvl, string msg returns nothing
	local string compositeMsg
	if Printing_DEBUG_LEVEL <= loglvl then
		set compositeMsg = Loglevel_getTag(loglvl) + " - " + msg
		call DisplayTimedTextToPlayer(showTo, 0., 0., Printing_DEBUG_MSG_DURATION, compositeMsg)
	endif
endfunction

function Log_error takes string msg returns nothing
	call printLog(Player_localPlayer, 4, msg)
endfunction

function compileError takes string msg returns nothing
endfunction

function hashtable_hasBoolean takes hashtable this_1, integer parentKey, integer childKey returns boolean
	return HaveSavedBoolean(this_1, parentKey, childKey)
endfunction

function hashtable_hasInt takes hashtable this_1, integer parentKey, integer childKey returns boolean
	return HaveSavedInteger(this_1, parentKey, childKey)
endfunction

function hashtable_loadBoolean takes hashtable this_1, integer parentKey, integer childKey returns boolean
	return LoadBoolean(this_1, parentKey, childKey)
endfunction

function hashtable_loadInt takes hashtable this_1, integer parentKey, integer childKey returns integer
	return LoadInteger(this_1, parentKey, childKey)
endfunction

function hashtable_saveBoolean takes hashtable this_1, integer parentKey, integer childKey, boolean value returns nothing
	call SaveBoolean(this_1, parentKey, childKey, value)
endfunction

function hashtable_saveInt takes hashtable this_1, integer parentKey, integer childKey, integer value returns nothing
	call SaveInteger(this_1, parentKey, childKey, value)
endfunction

function real_toInt takes real this_1 returns integer
	return R2I(this_1)
endfunction

function string_getHash takes string this_1 returns integer
	return StringHash(this_1)
endfunction

function error takes string msg, string w__wurst_stackPos returns nothing
	local integer hash
	local string stacktraceStr
	local integer stacktraceIndex
	local integer stacktraceLimit
	local string stacktraceStr_1
	local integer stacktraceIndex_1
	local integer stacktraceLimit_1
	local string temp
	local string temp_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if MagicFunctions_compiletime then
		call compileError("ERROR: " + msg)
	else
		if  not ErrorHandling_suppressErrorMessages then
			set hash = string_getHash(msg)
			if hashtable_hasInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) then
				if hashtable_loadInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) + ErrorHandling_MUTE_ERROR_DURATION < GameTimer_currentTime then
					set temp = msg
					set stacktraceStr = ""
					set stacktraceIndex = wurst_stack_depth
					set stacktraceLimit = 0
					loop
						set stacktraceIndex = stacktraceIndex - 1
						set stacktraceLimit = stacktraceLimit + 1
						exitwhen stacktraceLimit > 20
						exitwhen stacktraceIndex < 0
						set stacktraceStr = stacktraceStr + "\n   " + wurst_stack[stacktraceIndex]
					endloop
					call Log_error(temp + stacktraceStr)
					call hashtable_saveInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, real_toInt(GameTimer_currentTime))
					call hashtable_saveBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, false)
				elseif hashtable_hasBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) then
					if  not hashtable_loadBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) then
						call Log_error("|cffFF3A29Excessive repeating errors are being omitted")
						call hashtable_saveBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, true)
					endif
				else
					call Log_error("|cffFF3A29Excessive repeating errors are being omitted")
					call hashtable_saveBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, true)
				endif
			else
				call hashtable_saveInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, real_toInt(GameTimer_currentTime))
				set temp_1 = "Message: " + msg
				set stacktraceStr_1 = ""
				set stacktraceIndex_1 = wurst_stack_depth
				set stacktraceLimit_1 = 0
				loop
					set stacktraceIndex_1 = stacktraceIndex_1 - 1
					set stacktraceLimit_1 = stacktraceLimit_1 + 1
					exitwhen stacktraceLimit_1 > 20
					exitwhen stacktraceIndex_1 < 0
					set stacktraceStr_1 = stacktraceStr_1 + "\n   " + wurst_stack[stacktraceIndex_1]
				endloop
				call Log_error(temp_1 + stacktraceStr_1)
			endif
		endif
		call I2S(1 / 0)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function initCompiletimeState_0 takes nothing returns nothing
	set hashtable_compiletime_480 = InitHashtable()
	set hashtable_compiletime_479 = InitHashtable()
	set hashtable_compiletime_478 = InitHashtable()
	set hashtable_compiletime = InitHashtable()
	call SaveInteger(hashtable_compiletime_480, 1, -1663695754, 13)
	call SaveInteger(hashtable_compiletime_480, 1, -854572045, 3)
	call SaveInteger(hashtable_compiletime_480, 1, 349230650, 7)
	call SaveInteger(hashtable_compiletime_480, 1, -1474492777, 9)
	call SaveInteger(hashtable_compiletime_480, 1, 789744696, 15)
	call SaveInteger(hashtable_compiletime_480, 1, -1559655710, 12)
	call SaveInteger(hashtable_compiletime_480, 1, -943650483, 5)
	call SaveInteger(hashtable_compiletime_480, 1, -1587459251, 10)
	call SaveInteger(hashtable_compiletime_480, 1, -1894922563, 8)
	call SaveInteger(hashtable_compiletime_480, 1, -1676716706, 11)
	call SaveInteger(hashtable_compiletime_480, 1, 597637742, 14)
	call SaveInteger(hashtable_compiletime_480, 1, -680649701, 4)
	call SaveInteger(hashtable_compiletime_480, 1, -671760605, 6)
	call SaveInteger(hashtable_compiletime_480, 1, -242600650, 0)
	call SaveInteger(hashtable_compiletime_480, 1, -647782241, 2)
	call SaveInteger(hashtable_compiletime_480, 1, 1132341824, 1)
	call SaveStr(hashtable_compiletime_480, 2, 0, "")
endfunction

function initCompiletimeState takes nothing returns nothing
	call ExecuteFunc("initCompiletimeState_0")
endfunction

function CallbackCounted_getCount takes integer this_1 returns integer
	local integer cond_result
	if CallbackCounted_count[this_1] < CallbackCounted_maxCount[this_1] then
		set cond_result = CallbackCounted_count[this_1] + 1
	else
		set cond_result = CallbackCounted_count[this_1]
	endif
	return cond_result
endfunction

function dispatch_CallbackCounted_ClosureTimers_CallbackCounted_getCount takes integer this_1, string w__wurst_stackPos returns integer
	local integer ClosureTimers_CallbackCounted_getCount_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.getCount", "when calling error in ClosureTimers, line 161")
		else
			call error("Called CallbackCounted.getCount on invalid object.", "when calling error in ClosureTimers, line 161")
		endif
	endif
	set ClosureTimers_CallbackCounted_getCount_result = CallbackCounted_getCount(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return ClosureTimers_CallbackCounted_getCount_result
endfunction

function CallbackCounted_isLast takes integer this_1 returns boolean
	return CallbackCounted_count[this_1] == 0
endfunction

function dispatch_CallbackCounted_ClosureTimers_CallbackCounted_isLast takes integer this_1, string w__wurst_stackPos returns boolean
	local boolean ClosureTimers_CallbackCounted_isLast_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.isLast", "when calling error in ClosureTimers, line 158")
		else
			call error("Called CallbackCounted.isLast on invalid object.", "when calling error in ClosureTimers, line 158")
		endif
	endif
	set ClosureTimers_CallbackCounted_isLast_result = CallbackCounted_isLast(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return ClosureTimers_CallbackCounted_isLast_result
endfunction

function CallbackCounted_progress takes integer this_1 returns real
	return 1. - CallbackCounted_count[this_1] * 1. / CallbackCounted_maxCount[this_1]
endfunction

function dispatch_CallbackCounted_ClosureTimers_CallbackCounted_progress takes integer this_1, string w__wurst_stackPos returns real
	local real ClosureTimers_CallbackCounted_progress_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.progress", "when calling error in ClosureTimers, line 165")
		else
			call error("Called CallbackCounted.progress on invalid object.", "when calling error in ClosureTimers, line 165")
		endif
	endif
	set ClosureTimers_CallbackCounted_progress_result = CallbackCounted_progress(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return ClosureTimers_CallbackCounted_progress_result
endfunction

function int_toString takes integer this_1 returns string
	return I2S(this_1)
endfunction

function testFail takes string msg returns nothing
endfunction

function int_assertEquals takes integer this_1, integer expected returns nothing
	if this_1 != expected then
		call testFail("Expected <" + int_toString(expected) + ">, Actual <" + int_toString(this_1) + ">")
	endif
endfunction

function real_toString takes real this_1 returns string
	return R2S(this_1)
endfunction

function real_assertEquals takes real this_1, real expected, real delta returns nothing
	if this_1 - expected > delta or expected - this_1 > delta then
		call testFail("Expected <" + real_toString(expected) + ">, Actual <" + real_toString(this_1) + " with delta " + real_toString(delta) + ">")
	endif
endfunction

function call_doPeriodicallyCounted_ClosureTimers takes integer this_1, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call int_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_getCount(cb, "when calling getCount in ClosureTimers, line 201"), w_count[this_1])
	if dispatch_CallbackCounted_ClosureTimers_CallbackCounted_isLast(cb, "when calling isLast in ClosureTimers, line 202") then
		call real_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_progress(cb, "when calling progress in ClosureTimers, line 203"), 1., 0.0001)
		call int_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_getCount(cb, "when calling getCount in ClosureTimers, line 204"), 1)
	elseif w_count[this_1] == 3 then
		call real_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_progress(cb, "when calling progress in ClosureTimers, line 206"), 0.33333, 0.00001)
		call int_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_getCount(cb, "when calling getCount in ClosureTimers, line 207"), 3)
	elseif w_count[this_1] == 2 then
		call real_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_progress(cb, "when calling progress in ClosureTimers, line 209"), 0.66666, 0.00001)
		call int_assertEquals(dispatch_CallbackCounted_ClosureTimers_CallbackCounted_getCount(cb, "when calling getCount in ClosureTimers, line 210"), 2)
	endif
	set w_count[this_1] = w_count[this_1] - 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Iterator_onDestroy takes integer this_1 returns nothing
endfunction

function dealloc_Iterator takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_typeId[obj] == 0 then
		call error("Double free: object of type Iterator", "when calling error in LinkedListModule, line 71")
	else
		set Iterator_nextFree_169[Iterator_firstFree_161] = obj
		set Iterator_firstFree_161 = Iterator_firstFree_161 + 1
		set Iterator_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyIterator takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call Iterator_onDestroy(this_1)
	call dealloc_Iterator(this_1, "when calling dealloc_Iterator in LinkedListModule, line 71")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_Iterator_destroyIterator takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Iterator.Iterator", "when calling error in LinkedListModule, line 71")
		else
			call error("Called Iterator.Iterator on invalid object.", "when calling error in LinkedListModule, line 71")
		endif
	endif
	call destroyIterator(this_1, "when calling destroyIterator in LinkedListModule, line 71")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Iterator_close takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_destroyOnClose[this_1] then
		call dispatch_Iterator_destroyIterator(this_1, "when calling dispatch_Iterator_destroyIterator in LinkedListModule, line 91")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Iterator_hasNext takes integer this_1 returns boolean
	return Iterator_current[this_1] != 0
endfunction

function Iterator_next takes integer this_1 returns integer
	local integer res = Iterator_current[this_1]
	set Iterator_current[this_1] = Segment_LinkedListModule_next[Iterator_current[this_1]]
	return res
endfunction

function alloc_Iterator_475 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_firstFree_161 == 0 then
		if Iterator_maxIndex_165 < 32768 then
			set Iterator_maxIndex_165 = Iterator_maxIndex_165 + 1
			set this_1 = Iterator_maxIndex_165
			set Iterator_typeId[this_1] = 728
		else
			call error("Out of memory: Could not create Iterator.", "when calling error in LinkedListModule, line 71")
			set this_1 = 0
		endif
	else
		set Iterator_firstFree_161 = Iterator_firstFree_161 - 1
		set this_1 = Iterator_nextFree_169[Iterator_firstFree_161]
		set Iterator_typeId[this_1] = 728
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function Iterator_init_248 takes integer this_1 returns nothing
	set Iterator_current[this_1] = Segment_LinkedListModule_first
endfunction

function construct_Iterator_579 takes integer this_1, boolean destroyOnClose returns nothing
	call Iterator_init_248(this_1)
	set Iterator_destroyOnClose[this_1] = destroyOnClose
endfunction

function new_Iterator_851 takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Iterator_475("when calling alloc_Iterator in LinkedListModule, line 75")
	call construct_Iterator_579(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function Segment_LinkedListModule_iterator takes string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = new_Iterator_851(true, "when calling new_Iterator in LinkedListModule, line 53")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function alloc_ForGroupCallback_forUnitsInRange_Razor_Razor takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_firstFree == 0 then
		if ForGroupCallback_maxIndex < 32768 then
			set ForGroupCallback_maxIndex = ForGroupCallback_maxIndex + 1
			set this_1 = ForGroupCallback_maxIndex
			set ForGroupCallback_typeId[this_1] = 674
		else
			call error("Out of memory: Could not create ForGroupCallback_forUnitsInRange_Razor_Razor.", "when calling error in Razor, line 59")
			set this_1 = 0
		endif
	else
		set ForGroupCallback_firstFree = ForGroupCallback_firstFree - 1
		set this_1 = ForGroupCallback_nextFree[ForGroupCallback_firstFree]
		set ForGroupCallback_typeId[this_1] = 674
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function vec3_op_plus takes real this_x, real this_y, real this_z, real v_x, real v_y, real v_z returns real
	set vec3_op_plus_return_x = this_x + v_x
	set vec3_op_plus_return_y = this_y + v_y
	set vec3_op_plus_return_z = this_z + v_z
	return vec3_op_plus_return_x
endfunction

function Segment_getA takes integer this_1 returns real
	set Segment_getA_return_x = vec3_op_plus(Segment_pos_x[this_1], Segment_pos_y[this_1], Segment_pos_z[this_1], Segment_p1_x[this_1], Segment_p1_y[this_1], Segment_p1_z[this_1])
	set Segment_getA_return_y = vec3_op_plus_return_y
	set Segment_getA_return_z = vec3_op_plus_return_z
	return Segment_getA_return_x
endfunction

function dispatch_Segment_Segment_Segment_getA takes integer this_1, string w__wurst_stackPos returns real
	local real Segment_Segment_getA_result_x
	local real Segment_Segment_getA_result_y
	local real Segment_Segment_getA_result_z
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Segment_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Segment.getA", "when calling error in Segment, line 49")
		else
			call error("Called Segment.getA on invalid object.", "when calling error in Segment, line 49")
		endif
	endif
	set tuple_temp = Segment_getA(this_1)
	set tuple_temp_1 = Segment_getA_return_y
	set tuple_temp_2 = Segment_getA_return_z
	set Segment_Segment_getA_result_x = tuple_temp
	set Segment_Segment_getA_result_y = tuple_temp_1
	set Segment_Segment_getA_result_z = tuple_temp_2
	set wurst_stack_depth = wurst_stack_depth - 1
	set dispatch_Segment_Segment_Segment_getA_return_x = Segment_Segment_getA_result_x
	set dispatch_Segment_Segment_Segment_getA_return_y = Segment_Segment_getA_result_y
	set dispatch_Segment_Segment_Segment_getA_return_z = Segment_Segment_getA_result_z
	return dispatch_Segment_Segment_Segment_getA_return_x
endfunction

function Segment_getB takes integer this_1 returns real
	set Segment_getB_return_x = vec3_op_plus(Segment_pos_x[this_1], Segment_pos_y[this_1], Segment_pos_z[this_1], Segment_p2_x[this_1], Segment_p2_y[this_1], Segment_p2_z[this_1])
	set Segment_getB_return_y = vec3_op_plus_return_y
	set Segment_getB_return_z = vec3_op_plus_return_z
	return Segment_getB_return_x
endfunction

function dispatch_Segment_Segment_Segment_getB takes integer this_1, string w__wurst_stackPos returns real
	local real Segment_Segment_getB_result_x
	local real Segment_Segment_getB_result_y
	local real Segment_Segment_getB_result_z
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Segment_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Segment.getB", "when calling error in Segment, line 52")
		else
			call error("Called Segment.getB on invalid object.", "when calling error in Segment, line 52")
		endif
	endif
	set tuple_temp = Segment_getB(this_1)
	set tuple_temp_1 = Segment_getB_return_y
	set tuple_temp_2 = Segment_getB_return_z
	set Segment_Segment_getB_result_x = tuple_temp
	set Segment_Segment_getB_result_y = tuple_temp_1
	set Segment_Segment_getB_result_z = tuple_temp_2
	set wurst_stack_depth = wurst_stack_depth - 1
	set dispatch_Segment_Segment_Segment_getB_return_x = Segment_Segment_getB_result_x
	set dispatch_Segment_Segment_Segment_getB_return_y = Segment_Segment_getB_result_y
	set dispatch_Segment_Segment_Segment_getB_return_z = Segment_Segment_getB_result_z
	return dispatch_Segment_Segment_Segment_getB_return_x
endfunction

function addEffect takes string path, real pos_x, real pos_y returns effect
	return AddSpecialEffect(path, pos_x, pos_y)
endfunction

function effect_destr takes effect this_1 returns nothing
	call DestroyEffect(this_1)
endfunction

function effect_setScale takes effect this_1, real scale returns nothing
	call BlzSetSpecialEffectScale(this_1, scale)
endfunction

function angle_radians takes real this_radians returns real
	return this_radians
endfunction

function effect_setYaw takes effect this_1, real yaw_radians returns nothing
	call BlzSetSpecialEffectYaw(this_1, angle_radians(yaw_radians))
endfunction

function flashEffect_734 takes string path, real pos_x, real pos_y, real scale, real yaw_radians returns nothing
	local effect receiver = addEffect(path, pos_x, pos_y)
	local effect receiver_1
	local effect receiver_2
	call effect_setScale(receiver, scale)
	set receiver_1 = receiver
	call effect_setYaw(receiver_1, yaw_radians)
	set receiver_2 = receiver_1
	call effect_destr(receiver_2)
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
endfunction

function real_fromDeg takes real this_1 returns real
	set real_fromDeg_return_radians = this_1 * Angle_DEGTORAD
	return real_fromDeg_return_radians
endfunction

function flashEffect takes string path, real pos_x, real pos_y returns nothing
	call flashEffect_734(path, pos_x, pos_y, 1.0, real_fromDeg(GetRandomReal(0., 359.)))
endfunction

function alloc_LLEntry takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLEntry_firstFree == 0 then
		if LLEntry_maxIndex < 32768 then
			set LLEntry_maxIndex = LLEntry_maxIndex + 1
			set this_1 = LLEntry_maxIndex
		else
			call error("Out of memory: Could not create LLEntry.", "when calling error in LinkedList, line 421")
			set this_1 = 0
		endif
	else
		set LLEntry_firstFree = LLEntry_firstFree - 1
		set this_1 = LLEntry_nextFree[LLEntry_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function LLEntry_init takes integer this_1 returns nothing
endfunction

function construct_LLEntry takes integer this_1, integer elem, integer prev, integer next returns nothing
	call LLEntry_init(this_1)
	set LLEntry_elem[this_1] = elem
	set LLEntry_prev[this_1] = prev
	set LLEntry_next[this_1] = next
endfunction

function new_LLEntry takes integer elem, integer prev, integer next, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_LLEntry("when calling alloc_LLEntry in LinkedList, line 426")
	call construct_LLEntry(this_1, elem, prev, next)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function LinkedList_add_1 takes integer this_1, integer elems_0, string w__wurst_stackPos returns nothing
	local integer entry
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set entry = new_LLEntry(elems_0, LLEntry_prev[LinkedList_dummy[this_1]], LinkedList_dummy[this_1], "when calling new_LLEntry in LinkedList, line 40")
	set LLEntry_next[LLEntry_prev[LinkedList_dummy[this_1]]] = entry
	set LLEntry_prev[LinkedList_dummy[this_1]] = entry
	set LinkedList_size[this_1] = LinkedList_size[this_1] + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_LinkedList_LinkedList_LinkedList_add_1 takes integer this_1, integer elems_0, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LinkedList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling LinkedList.add", "when calling error in LinkedList, line 38")
		else
			call error("Called LinkedList.add on invalid object.", "when calling error in LinkedList, line 38")
		endif
	endif
	call LinkedList_add_1(this_1, elems_0, "when calling add in LinkedList, line 38")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function handle_getHandleId takes handle this_1 returns integer
	return GetHandleId(this_1)
endfunction

function unitToIndex takes unit object returns integer
	return handle_getHandleId(object)
endfunction

function callback_forEachFrom_LinkedList takes integer this_1, unit u, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_LinkedList_LinkedList_LinkedList_add_1(result[this_1], unitToIndex(u), "when calling add in LinkedList, line 550")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function unit_remove takes unit this_1 returns nothing
	call RemoveUnit(this_1)
endfunction

function callback_forEachFrom_Preloader takes integer this_1, unit u returns nothing
	call unit_remove(u)
endfunction

function addEffect_443 takes string path, widget target, string attachPointName returns effect
	return AddSpecialEffectTarget(path, target, attachPointName)
endfunction

function flashEffect_735 takes string path, widget target, string attachPointName returns nothing
	call effect_destr(addEffect_443(path, target, attachPointName))
endfunction

function real_isBetween takes real this_1, real low, real high returns boolean
	return this_1 >= low and this_1 <= high
endfunction

function real_squared takes real this_1 returns real
	return this_1 * this_1
endfunction

function vec2_distanceToSq takes real this_x, real this_y, real v_x, real v_y returns real
	return real_squared(v_x - this_x) + real_squared(v_y - this_y)
endfunction

function vec2_dot takes real this_x, real this_y, real v_x, real v_y returns real
	return this_x * v_x + this_y * v_y
endfunction

function vec2_lengthSq takes real this_x, real this_y returns real
	return this_x * this_x + this_y * this_y
endfunction

function vec2_op_minus takes real this_x, real this_y, real v_x, real v_y returns real
	set vec2_op_minus_return_x = this_x - v_x
	set vec2_op_minus_return_y = this_y - v_y
	return vec2_op_minus_return_x
endfunction

function vec2_op_mult takes real this_x, real this_y, real factor returns real
	set vec2_op_mult_return_x = this_x * factor
	set vec2_op_mult_return_y = this_y * factor
	return vec2_op_mult_return_x
endfunction

function vec2_op_plus takes real this_x, real this_y, real v_x, real v_y returns real
	set vec2_op_plus_return_x = this_x + v_x
	set vec2_op_plus_return_y = this_y + v_y
	return vec2_op_plus_return_x
endfunction

function ray2d_castToCircle takes real this_origin_x, real this_origin_y, real this_direction_x, real this_direction_y, real center_x, real center_y, real radius returns boolean
	local boolean tuple_temp = Raycast_FAIL_2D_intersects
	local real tuple_temp_1 = Raycast_FAIL_2D_point_x
	local real tuple_temp_2 = Raycast_FAIL_2D_point_y
	local real tuple_temp_3 = Raycast_FAIL_2D_distance
	local boolean tuple_temp_4 = Raycast_FAIL_2D_intersects
	local real tuple_temp_5 = Raycast_FAIL_2D_point_x
	local real tuple_temp_6 = Raycast_FAIL_2D_point_y
	local real tuple_temp_7 = Raycast_FAIL_2D_distance
	local boolean result_first_intersects = tuple_temp
	local real result_first_point_x = tuple_temp_1
	local real result_first_point_y = tuple_temp_2
	local real result_first_distance = tuple_temp_3
	local boolean result_second_intersects = tuple_temp_4
	local real result_second_point_x = tuple_temp_5
	local real result_second_point_y = tuple_temp_6
	local real result_second_distance = tuple_temp_7
	local real lengthSq = vec2_lengthSq(this_direction_x, this_direction_y)
	local real length
	local real dir_x
	local real dir_y
	local real v_x
	local real v_y
	local real dot
	local real tangent_x
	local real tangent_y
	local real dd
	local real rr
	local real t
	local real first
	local real second
	local real tuple_temp_8
	local real tuple_temp_9
	local real tuple_temp_10
	local real tuple_temp_11
	local real tuple_temp_12
	local real tuple_temp_13
	local real tuple_temp_14
	local real tuple_temp_15
	local real tuple_temp_16
	local real tuple_temp_17
	local real tuple_temp_18
	local real tuple_temp_19
	local real tuple_temp_20
	local real tuple_temp_21
	if lengthSq > Raycast_EPSILON and radius > Raycast_EPSILON then
		set length = SquareRoot(lengthSq)
		set tuple_temp_8 = this_direction_x / length
		set tuple_temp_9 = this_direction_y / length
		set dir_x = tuple_temp_8
		set dir_y = tuple_temp_9
		set tuple_temp_10 = vec2_op_minus(center_x, center_y, this_origin_x, this_origin_y)
		set tuple_temp_11 = vec2_op_minus_return_y
		set v_x = tuple_temp_10
		set v_y = tuple_temp_11
		set dot = vec2_dot(v_x, v_y, dir_x, dir_y)
		set tuple_temp_12 = vec2_op_plus(this_origin_x, this_origin_y, vec2_op_mult(dir_x, dir_y, dot), vec2_op_mult_return_y)
		set tuple_temp_13 = vec2_op_plus_return_y
		set tangent_x = tuple_temp_12
		set tangent_y = tuple_temp_13
		set dd = vec2_distanceToSq(center_x, center_y, tangent_x, tangent_y)
		set rr = real_squared(radius)
		if real_isBetween(dd, rr - Raycast_EPSILON, rr + Raycast_EPSILON) then
			set result_first_intersects = true
			set tuple_temp_14 = tangent_x
			set tuple_temp_15 = tangent_y
			set result_first_point_x = tuple_temp_14
			set result_first_point_y = tuple_temp_15
			set result_first_distance = dot
		elseif dd < rr then
			set t = SquareRoot(rr - dd)
			set first = dot - t
			set second = dot + t
			if first >= 0. then
				set result_first_intersects = true
				set tuple_temp_16 = vec2_op_plus(this_origin_x, this_origin_y, vec2_op_mult(dir_x, dir_y, first), vec2_op_mult_return_y)
				set tuple_temp_17 = vec2_op_plus_return_y
				set result_first_point_x = tuple_temp_16
				set result_first_point_y = tuple_temp_17
				set result_first_distance = first
				set result_second_intersects = true
				set tuple_temp_18 = vec2_op_plus(this_origin_x, this_origin_y, vec2_op_mult(dir_x, dir_y, second), vec2_op_mult_return_y)
				set tuple_temp_19 = vec2_op_plus_return_y
				set result_second_point_x = tuple_temp_18
				set result_second_point_y = tuple_temp_19
				set result_second_distance = second
			elseif second >= 0. then
				set result_first_intersects = true
				set tuple_temp_20 = vec2_op_plus(this_origin_x, this_origin_y, vec2_op_mult(dir_x, dir_y, second), vec2_op_mult_return_y)
				set tuple_temp_21 = vec2_op_plus_return_y
				set result_first_point_x = tuple_temp_20
				set result_first_point_y = tuple_temp_21
				set result_first_distance = second
			endif
		endif
	endif
	set ray2d_castToCircle_return_first_intersects = result_first_intersects
	set ray2d_castToCircle_return_first_point_x = result_first_point_x
	set ray2d_castToCircle_return_first_point_y = result_first_point_y
	set ray2d_castToCircle_return_first_distance = result_first_distance
	set ray2d_castToCircle_return_second_intersects = result_second_intersects
	set ray2d_castToCircle_return_second_point_x = result_second_point_x
	set ray2d_castToCircle_return_second_point_y = result_second_point_y
	set ray2d_castToCircle_return_second_distance = result_second_distance
	return ray2d_castToCircle_return_first_intersects
endfunction

function unit_getCollisionSize takes unit this_1 returns real
	return BlzGetUnitCollisionSize(this_1)
endfunction

function unit_getX takes unit this_1 returns real
	return GetUnitX(this_1)
endfunction

function unit_getY takes unit this_1 returns real
	return GetUnitY(this_1)
endfunction

function unit_getPos takes unit this_1 returns real
	set unit_getPos_return_x = unit_getX(this_1)
	set unit_getPos_return_y = unit_getY(this_1)
	return unit_getPos_return_x
endfunction

function unit_isAlive takes unit this_1 returns boolean
	return UnitAlive(this_1)
endfunction

function unit_kill takes unit this_1 returns nothing
	call KillUnit(this_1)
endfunction

function callback_forUnitsInRange_Razor_Razor takes integer this_1, unit u returns nothing
	local boolean unitResult_intersects
	local real unitResult_distance
	local boolean temp_tuple_first_intersects
	local real temp_tuple_first_point_x
	local real temp_tuple_first_point_y
	local real temp_tuple_first_distance
	local boolean tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local boolean tuple_temp_4
	local real tuple_temp_5
	if unit_isAlive(u) then
		set tuple_temp = ray2d_castToCircle(ray_origin_x[this_1], ray_origin_y[this_1], ray_direction_x[this_1], ray_direction_y[this_1], unit_getPos(u), unit_getPos_return_y, unit_getCollisionSize(u))
		set tuple_temp_1 = ray2d_castToCircle_return_first_point_x
		set tuple_temp_2 = ray2d_castToCircle_return_first_point_y
		set tuple_temp_3 = ray2d_castToCircle_return_first_distance
		set temp_tuple_first_intersects = tuple_temp
		set temp_tuple_first_point_x = tuple_temp_1
		set temp_tuple_first_point_y = tuple_temp_2
		set temp_tuple_first_distance = tuple_temp_3
		set tuple_temp_4 = temp_tuple_first_intersects
		set tuple_temp_5 = temp_tuple_first_distance
		set unitResult_intersects = tuple_temp_4
		set unitResult_distance = tuple_temp_5
		if castResult_intersects[this_1] then
			if unitResult_intersects and unitResult_distance <= castResult_distance[this_1] then
				call unit_kill(u)
				call flashEffect_735(Razor_hitFxPath[this_592[this_1]], u, "chest")
			endif
		elseif unitResult_intersects then
			call unit_kill(u)
			call flashEffect_735(Razor_hitFxPath[this_592[this_1]], u, "chest")
		endif
	endif
endfunction

function vec2_distanceToSegmentSq takes real this_x, real this_y, real v1_x, real v1_y, real v2_x, real v2_y returns real
	local real l2 = vec2_distanceToSq(v1_x, v1_y, v2_x, v2_y)
	local real t
	if l2 == 0. then
		return vec2_distanceToSq(this_x, this_y, v1_x, v1_y)
	endif
	set t = ((this_x - v1_x) * (v2_x - v1_x) + (this_y - v1_y) * (v2_y - v1_y)) / l2
	if t < 0. then
		return vec2_distanceToSq(this_x, this_y, v1_x, v1_y)
	endif
	if t > 1. then
		return vec2_distanceToSq(this_x, this_y, v2_x, v2_y)
	endif
	return vec2_distanceToSq(this_x, this_y, v1_x + t * (v2_x - v1_x), v1_y + t * (v2_y - v1_y))
endfunction

function vec3_toVec2 takes real this_x, real this_y, real this_z returns real
	set vec3_toVec2_return_x = this_x
	set vec3_toVec2_return_y = this_y
	return vec3_toVec2_return_x
endfunction

function callback_forUnitsInRange_Segment_Segment takes integer this_1, unit u returns nothing
	if unit_isAlive(u) and vec2_distanceToSegmentSq(unit_getPos(u), unit_getPos_return_y, vec3_toVec2(vec3_op_plus(Segment_pos_x[this_593[this_1]], Segment_pos_y[this_593[this_1]], Segment_pos_z[this_593[this_1]], Segment_p1_x[this_593[this_1]], Segment_p1_y[this_593[this_1]], Segment_p1_z[this_593[this_1]]), vec3_op_plus_return_y, vec3_op_plus_return_z), vec3_toVec2_return_y, vec3_toVec2(vec3_op_plus(Segment_pos_x[this_593[this_1]], Segment_pos_y[this_593[this_1]], Segment_pos_z[this_593[this_1]], Segment_p2_x[this_593[this_1]], Segment_p2_y[this_593[this_1]], Segment_p2_z[this_593[this_1]]), vec3_op_plus_return_y, vec3_op_plus_return_z), vec3_toVec2_return_y) <= real_squared(unit_getCollisionSize(u)) then
		call flashEffect(Segment_touchEffect, unit_getPos(u), unit_getPos_return_y)
		call unit_kill(u)
	endif
endfunction

function dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback takes integer this_1, unit u, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling ForGroupCallback.callback", "when calling error in ClosureForGroups, line 4")
		else
			call error("Called ForGroupCallback.callback on invalid object.", "when calling error in ClosureForGroups, line 4")
		endif
	endif
	if ForGroupCallback_typeId[this_1] <= 673 then
		if ForGroupCallback_typeId[this_1] <= 672 then
			call callback_forEachFrom_LinkedList(this_1, u, "when calling callback_forEachFrom_LinkedList in ClosureForGroups, line 4")
		else
			call callback_forEachFrom_Preloader(this_1, u)
		endif
	elseif ForGroupCallback_typeId[this_1] <= 674 then
		call callback_forUnitsInRange_Razor_Razor(this_1, u)
	else
		call callback_forUnitsInRange_Segment_Segment(this_1, u)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function group_hasNext takes group this_1 returns boolean
	return FirstOfGroup(this_1) != null
endfunction

function group_next takes group this_1 returns unit
	local unit iterUnit = FirstOfGroup(this_1)
	call GroupRemoveUnit(this_1, iterUnit)
	set group_nexttempReturn = iterUnit
	set iterUnit = null
	return group_nexttempReturn
endfunction

function dealloc_ForGroupCallback takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_typeId[obj] == 0 then
		call error("Double free: object of type ForGroupCallback", "when calling error in ClosureForGroups, line 3")
	else
		set ForGroupCallback_nextFree[ForGroupCallback_firstFree] = obj
		set ForGroupCallback_firstFree = ForGroupCallback_firstFree + 1
		set ForGroupCallback_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyForGroupCallback takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dealloc_ForGroupCallback(this_1, "when calling dealloc_ForGroupCallback in ClosureForGroups, line 3")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_ForGroupCallback_destroyForGroupCallback takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling ForGroupCallback.ForGroupCallback", "when calling error in ClosureForGroups, line 3")
		else
			call error("Called ForGroupCallback.ForGroupCallback on invalid object.", "when calling error in ClosureForGroups, line 3")
		endif
	endif
	call destroyForGroupCallback(this_1, "when calling destroyForGroupCallback in ClosureForGroups, line 3")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function group_clear takes group this_1 returns nothing
	call GroupClear(this_1)
endfunction

function popCallback takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call group_clear(ClosureForGroups_DUMMY_GROUP)
	set ClosureForGroups_tempCallbacksCount = ClosureForGroups_tempCallbacksCount - 1
	call dispatch_ForGroupCallback_destroyForGroupCallback(ClosureForGroups_tempCallbacks[ClosureForGroups_tempCallbacksCount], "when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 30")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function pushCallback takes integer c returns nothing
	set ClosureForGroups_tempCallbacks[ClosureForGroups_tempCallbacksCount] = c
	set ClosureForGroups_tempCallbacksCount = ClosureForGroups_tempCallbacksCount + 1
	set ClosureForGroups_iterCount = 0
	set ClosureForGroups_maxCount = Integer_INT_MAX
endfunction

function forUnitsInRange takes real pos_x, real pos_y, real radius, boolean collisionSizeFiltering, integer c, string w__wurst_stackPos returns nothing
	local unit u
	local group from
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if collisionSizeFiltering then
		call pushCallback(c)
		call GroupEnumUnitsInRange(Group_ENUM_GROUP, pos_x, pos_y, radius + Basics_MAX_COLLISION_SIZE, null)
		set from = Group_ENUM_GROUP
		loop
			exitwhen  not group_hasNext(from)
			set u = group_next(from)
			if IsUnitInRangeXY(u, pos_x, pos_y, radius) then
				call dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback(c, u, "when calling callback in ClosureForGroups, line 110")
			endif
		endloop
		call popCallback("when calling popCallback in ClosureForGroups, line 111")
	else
		call pushCallback(c)
		call GroupEnumUnitsInRange(ClosureForGroups_DUMMY_GROUP, pos_x, pos_y, radius, ClosureForGroups_filter)
		call popCallback("when calling popCallback in ClosureForGroups, line 115")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	set u = null
	set from = null
endfunction

function lightning_move takes lightning this_1, boolean checkVisibility, real start_x, real start_y, real w_end_x, real w_end_y returns boolean
	return MoveLightning(this_1, checkVisibility, start_x, start_y, w_end_x, w_end_y)
endfunction

function real_abs takes real this_1 returns real
	local real cond_result
	if this_1 < 0. then
		set cond_result =  - this_1
	else
		set cond_result = this_1
	endif
	return cond_result
endfunction

function vec2_cross takes real this_x, real this_y, real v_x, real v_y returns real
	return this_x * v_y - this_y * v_x
endfunction

function ray2d_castToSegment takes real this_origin_x, real this_origin_y, real this_direction_x, real this_direction_y, real p1_x, real p1_y, real p2_x, real p2_y returns boolean
	local boolean tuple_temp = Raycast_FAIL_2D_intersects
	local real tuple_temp_1 = Raycast_FAIL_2D_point_x
	local real tuple_temp_2 = Raycast_FAIL_2D_point_y
	local real tuple_temp_3 = Raycast_FAIL_2D_distance
	local boolean result_intersects = tuple_temp
	local real result_point_x = tuple_temp_1
	local real result_point_y = tuple_temp_2
	local real result_distance = tuple_temp_3
	local real lengthSq = vec2_lengthSq(this_direction_x, this_direction_y)
	local real sv_x
	local real sv_y
	local real length
	local real dir_x
	local real dir_y
	local real cross
	local real t1
	local real t2
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	local real tuple_temp_9
	if lengthSq > Raycast_EPSILON then
		set tuple_temp_4 = vec2_op_minus(p2_x, p2_y, p1_x, p1_y)
		set tuple_temp_5 = vec2_op_minus_return_y
		set sv_x = tuple_temp_4
		set sv_y = tuple_temp_5
		if vec2_lengthSq(sv_x, sv_y) > Raycast_EPSILON then
			set length = SquareRoot(lengthSq)
			set tuple_temp_6 = this_direction_x / length
			set tuple_temp_7 = this_direction_y / length
			set dir_x = tuple_temp_6
			set dir_y = tuple_temp_7
			set cross = vec2_cross(dir_x, dir_y, sv_x, sv_y)
			if real_abs(cross) > Raycast_EPSILON then
				set t1 = vec2_cross(vec2_op_minus(p1_x, p1_y, this_origin_x, this_origin_y), vec2_op_minus_return_y, sv_x, sv_y) / cross
				set t2 = vec2_cross(vec2_op_minus(this_origin_x, this_origin_y, p1_x, p1_y), vec2_op_minus_return_y, dir_x, dir_y) / ( - cross)
				if t1 >= 0. and real_isBetween(t2, 0., 1.) then
					set result_intersects = true
					set tuple_temp_8 = vec2_op_plus(this_origin_x, this_origin_y, vec2_op_mult(dir_x, dir_y, t1), vec2_op_mult_return_y)
					set tuple_temp_9 = vec2_op_plus_return_y
					set result_point_x = tuple_temp_8
					set result_point_y = tuple_temp_9
					set result_distance = t1
				endif
			endif
		endif
	endif
	set ray2d_castToSegment_return_intersects = result_intersects
	set ray2d_castToSegment_return_point_x = result_point_x
	set ray2d_castToSegment_return_point_y = result_point_y
	set ray2d_castToSegment_return_distance = result_distance
	return ray2d_castToSegment_return_intersects
endfunction

function vec2_distanceTo takes real this_x, real this_y, real v_x, real v_y returns real
	return SquareRoot(real_squared(v_x - this_x) + real_squared(v_y - this_y))
endfunction

function vec2_length takes real this_x, real this_y returns real
	return SquareRoot(this_x * this_x + this_y * this_y)
endfunction

function vec2_norm takes real this_x, real this_y returns real
	local real len = vec2_length(this_x, this_y)
	local real x = 0.
	local real y = 0.
	if len > 0.0 then
		set x = this_x / len
		set y = this_y / len
	endif
	set vec2_norm_return_x = x
	set vec2_norm_return_y = y
	return vec2_norm_return_x
endfunction

function Razor_update takes integer this_1, real delta, string w__wurst_stackPos returns nothing
	local real offset_x
	local real offset_y
	local real ray_origin_x_1
	local real ray_origin_y_1
	local real ray_direction_x_1
	local real ray_direction_y_1
	local real dist
	local boolean castResult_intersects_1
	local real castResult_point_x
	local real castResult_point_y
	local real castResult_distance_1
	local integer iterator
	local integer seg
	local boolean segResult_intersects
	local real segResult_point_x
	local real segResult_point_y
	local real segResult_distance
	local integer clVar
	local real temp_x
	local real temp_y
	local real temp
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	local real tuple_temp_9
	local boolean tuple_temp_10
	local real tuple_temp_11
	local real tuple_temp_12
	local real tuple_temp_13
	local boolean tuple_temp_14
	local real tuple_temp_15
	local real tuple_temp_16
	local real tuple_temp_17
	local boolean tuple_temp_18
	local real tuple_temp_19
	local real tuple_temp_20
	local real tuple_temp_21
	local boolean tuple_temp_22
	local real tuple_temp_23
	local real tuple_temp_24
	local real tuple_temp_25
	local real tuple_temp_26
	local real tuple_temp_27
	local real tuple_temp_28
	local real tuple_temp_29
	local real tuple_temp_30
	local real tuple_temp_31
	local boolean tuple_temp_32
	local real tuple_temp_33
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set tuple_temp = vec2_op_mult(vec2_op_mult(Razor_dir_x[this_1], Razor_dir_y[this_1], Razor_speed[this_1]), vec2_op_mult_return_y, delta)
	set tuple_temp_1 = vec2_op_mult_return_y
	set offset_x = tuple_temp
	set offset_y = tuple_temp_1
	set tuple_temp_2 = vec2_op_plus(Razor_p1_x[this_1], Razor_p1_y[this_1], offset_x, offset_y)
	set tuple_temp_3 = vec2_op_plus_return_y
	set Razor_p1_x[this_1] = tuple_temp_2
	set Razor_p1_y[this_1] = tuple_temp_3
	set tuple_temp_4 = vec2_op_plus(Razor_p2_x[this_1], Razor_p2_y[this_1], offset_x, offset_y)
	set tuple_temp_5 = vec2_op_plus_return_y
	set Razor_p2_x[this_1] = tuple_temp_4
	set Razor_p2_y[this_1] = tuple_temp_5
	set tuple_temp_6 = Razor_p1_x[this_1]
	set tuple_temp_7 = Razor_p1_y[this_1]
	set tuple_temp_8 = vec2_norm(vec2_op_minus(Razor_p2_x[this_1], Razor_p2_y[this_1], Razor_p1_x[this_1], Razor_p1_y[this_1]), vec2_op_minus_return_y)
	set tuple_temp_9 = vec2_norm_return_y
	set ray_origin_x_1 = tuple_temp_6
	set ray_origin_y_1 = tuple_temp_7
	set ray_direction_x_1 = tuple_temp_8
	set ray_direction_y_1 = tuple_temp_9
	set dist = vec2_distanceTo(Razor_p1_x[this_1], Razor_p1_y[this_1], Razor_p2_x[this_1], Razor_p2_y[this_1])
	set tuple_temp_10 = false
	set tuple_temp_11 = Vectors_ZERO2_x
	set tuple_temp_12 = Vectors_ZERO2_y
	set tuple_temp_13 = 0.
	set castResult_intersects_1 = tuple_temp_10
	set castResult_point_x = tuple_temp_11
	set castResult_point_y = tuple_temp_12
	set castResult_distance_1 = tuple_temp_13
	set iterator = Segment_LinkedListModule_iterator("when calling iterator in Razor, line 46")
	loop
		exitwhen  not Iterator_hasNext(iterator)
		set seg = Iterator_next(iterator)
		set tuple_temp_14 = ray2d_castToSegment(ray_origin_x_1, ray_origin_y_1, ray_direction_x_1, ray_direction_y_1, vec3_toVec2(dispatch_Segment_Segment_Segment_getA(seg, "when calling getA in Razor, line 47"), dispatch_Segment_Segment_Segment_getA_return_y, dispatch_Segment_Segment_Segment_getA_return_z), vec3_toVec2_return_y, vec3_toVec2(dispatch_Segment_Segment_Segment_getB(seg, "when calling getB in Razor, line 47"), dispatch_Segment_Segment_Segment_getB_return_y, dispatch_Segment_Segment_Segment_getB_return_z), vec3_toVec2_return_y)
		set tuple_temp_15 = ray2d_castToSegment_return_point_x
		set tuple_temp_16 = ray2d_castToSegment_return_point_y
		set tuple_temp_17 = ray2d_castToSegment_return_distance
		set segResult_intersects = tuple_temp_14
		set segResult_point_x = tuple_temp_15
		set segResult_point_y = tuple_temp_16
		set segResult_distance = tuple_temp_17
		if segResult_intersects and segResult_distance <= dist then
			if  not castResult_intersects_1 then
				set tuple_temp_18 = segResult_intersects
				set tuple_temp_19 = segResult_point_x
				set tuple_temp_20 = segResult_point_y
				set tuple_temp_21 = segResult_distance
				set castResult_intersects_1 = tuple_temp_18
				set castResult_point_x = tuple_temp_19
				set castResult_point_y = tuple_temp_20
				set castResult_distance_1 = tuple_temp_21
			elseif segResult_distance < castResult_distance_1 then
				set tuple_temp_22 = segResult_intersects
				set tuple_temp_23 = segResult_point_x
				set tuple_temp_24 = segResult_point_y
				set tuple_temp_25 = segResult_distance
				set castResult_intersects_1 = tuple_temp_22
				set castResult_point_x = tuple_temp_23
				set castResult_point_y = tuple_temp_24
				set castResult_distance_1 = tuple_temp_25
			endif
		endif
	endloop
	call Iterator_close(iterator, "when calling close in Razor, line 46")
	if castResult_intersects_1 then
		call lightning_move(Razor_ltn[this_1], false, Razor_p1_x[this_1], Razor_p1_y[this_1], castResult_point_x, castResult_point_y)
		call flashEffect(Razor_hitFxPath[this_1], castResult_point_x, castResult_point_y)
	else
		call lightning_move(Razor_ltn[this_1], false, Razor_p1_x[this_1], Razor_p1_y[this_1], Razor_p2_x[this_1], Razor_p2_y[this_1])
	endif
	set tuple_temp_26 = vec2_op_plus(Razor_p1_x[this_1], Razor_p1_y[this_1], vec2_op_mult(vec2_op_minus(Razor_p2_x[this_1], Razor_p2_y[this_1], Razor_p1_x[this_1], Razor_p1_y[this_1]), vec2_op_minus_return_y, 0.5), vec2_op_mult_return_y)
	set tuple_temp_27 = vec2_op_plus_return_y
	set temp_x = tuple_temp_26
	set temp_y = tuple_temp_27
	set temp = dist
	set clVar = alloc_ForGroupCallback_forUnitsInRange_Razor_Razor("when calling alloc_ForGroupCallback_forUnitsInRange_Razor_Razor in Razor, line 59")
	set tuple_temp_28 = ray_origin_x_1
	set tuple_temp_29 = ray_origin_y_1
	set tuple_temp_30 = ray_direction_x_1
	set tuple_temp_31 = ray_direction_y_1
	set ray_origin_x[clVar] = tuple_temp_28
	set ray_origin_y[clVar] = tuple_temp_29
	set ray_direction_x[clVar] = tuple_temp_30
	set ray_direction_y[clVar] = tuple_temp_31
	set tuple_temp_32 = castResult_intersects_1
	set tuple_temp_33 = castResult_distance_1
	set castResult_intersects[clVar] = tuple_temp_32
	set castResult_distance[clVar] = tuple_temp_33
	set this_592[clVar] = this_1
	call forUnitsInRange(temp_x, temp_y, temp, true, clVar, "when calling forUnitsInRange in Razor, line 59")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_Razor_Razor_Razor_update takes integer this_1, real delta, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Razor_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Razor.update", "when calling error in Razor, line 39")
		else
			call error("Called Razor.update on invalid object.", "when calling error in Razor, line 39")
		endif
	endif
	call Razor_update(this_1, delta, "when calling update in Razor, line 39")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Razor_LinkedListModule_remove takes integer this_1 returns nothing
	set Razor_LinkedListModule_size = Razor_LinkedListModule_size - 1
	if this_1 != Razor_LinkedListModule_first then
		set Razor_LinkedListModule_next[Razor_LinkedListModule_prev[this_1]] = Razor_LinkedListModule_next[this_1]
	else
		set Razor_LinkedListModule_first = Razor_LinkedListModule_next[this_1]
	endif
	if this_1 != Razor_LinkedListModule_last then
		set Razor_LinkedListModule_prev[Razor_LinkedListModule_next[this_1]] = Razor_LinkedListModule_prev[this_1]
	else
		set Razor_LinkedListModule_last = Razor_LinkedListModule_prev[this_1]
	endif
endfunction

function dispatch_Razor_Razor_Razor_LinkedListModule_remove takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Razor_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Razor.remove", "when calling error in LinkedListModule, line 37")
		else
			call error("Called Razor.remove on invalid object.", "when calling error in LinkedListModule, line 37")
		endif
	endif
	call Razor_LinkedListModule_remove(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function lightning_destr takes lightning this_1 returns boolean
	return DestroyLightning(this_1)
endfunction

function Razor_onDestroy takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call lightning_destr(Razor_ltn[this_1])
	call dispatch_Razor_Razor_Razor_LinkedListModule_remove(this_1, "when calling remove in LinkedListModule, line 49")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_Razor takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Razor_typeId[obj] == 0 then
		call error("Double free: object of type Razor", "when calling error in Razor, line 16")
	else
		set Razor_nextFree[Razor_firstFree] = obj
		set Razor_firstFree = Razor_firstFree + 1
		set Razor_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyRazor takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call Razor_onDestroy(this_1, "when calling Razor_onDestroy in Razor, line 36")
	call dealloc_Razor(this_1, "when calling dealloc_Razor in Razor, line 36")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_Razor_destroyRazor takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Razor_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Razor.Razor", "when calling error in Razor, line 16")
		else
			call error("Called Razor.Razor on invalid object.", "when calling error in Razor, line 16")
		endif
	endif
	call destroyRazor(this_1, "when calling destroyRazor in Razor, line 16")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function call_doPeriodicallyTimed_Razor_Razor takes integer this_1, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_Razor_Razor_Razor_update(this[this_1], Basics_ANIMATION_PERIOD, "when calling update in Razor, line 32")
	if dispatch_CallbackCounted_ClosureTimers_CallbackCounted_isLast(cb, "when calling isLast in Razor, line 33") then
		call dispatch_Razor_destroyRazor(this[this_1], "when calling dispatch_Razor_destroyRazor in Razor, line 34")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function panCameraToTimed takes real pos_x, real pos_y, real duration returns nothing
	call PanCameraToTimed(pos_x, pos_y, duration)
endfunction

function call_doPeriodicallyTimed_add_Character takes integer this_1, integer cb returns nothing
	call panCameraToTimed(unit_getPos(Character_character), unit_getPos_return_y, 0.)
endfunction

function dispatch_CallbackCounted_ClosureTimers_CallbackCounted_call takes integer this_1, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.call", "when calling error in ClosureTimers, line 149")
		else
			call error("Called CallbackCounted.call on invalid object.", "when calling error in ClosureTimers, line 149")
		endif
	endif
	if CallbackCounted_typeId[this_1] <= 643 then
		if CallbackCounted_typeId[this_1] <= 642 then
			call call_doPeriodicallyCounted_ClosureTimers(this_1, cb, "when calling call_doPeriodicallyCounted_ClosureTimers in ClosureTimers, line 149")
		else
			call call_doPeriodicallyTimed_Razor_Razor(this_1, cb, "when calling call_doPeriodicallyTimed_Razor_Razor in ClosureTimers, line 149")
		endif
	else
		call call_doPeriodicallyTimed_add_Character(this_1, cb)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Table_loadInt takes integer this_1, integer parentKey returns integer
	return hashtable_loadInt(Table_ht, this_1, parentKey)
endfunction

function dispatch_Table_Table_Table_loadInt takes integer this_1, integer parentKey, string w__wurst_stackPos returns integer
	local integer Table_Table_loadInt_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.loadInt", "when calling error in Table, line 40")
		else
			call error("Called Table.loadInt on invalid object.", "when calling error in Table, line 40")
		endif
	endif
	set Table_Table_loadInt_result = Table_loadInt(this_1, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_loadInt_result
endfunction

function timer_getHandleId takes timer this_1 returns integer
	return GetHandleId(this_1)
endfunction

function timer_getData takes timer this_1, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_Table_Table_Table_loadInt(TimerUtils_timerData, timer_getHandleId(this_1), "when calling loadInt in TimerUtils, line 22")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function timer_pause takes timer this_1 returns nothing
	call PauseTimer(this_1)
endfunction

function Table_saveInt takes integer this_1, integer parentKey, integer value returns nothing
	call hashtable_saveInt(Table_ht, this_1, parentKey, value)
endfunction

function dispatch_Table_Table_Table_saveInt takes integer this_1, integer parentKey, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.saveInt", "when calling error in Table, line 43")
		else
			call error("Called Table.saveInt on invalid object.", "when calling error in Table, line 43")
		endif
	endif
	call Table_saveInt(this_1, parentKey, value)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_setData takes timer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_Table_Table_Table_saveInt(TimerUtils_timerData, timer_getHandleId(this_1), data, "when calling saveInt in TimerUtils, line 18")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_release takes timer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if this_1 == null then
		call error("Trying to release a null timer", "when calling error in TimerUtils, line 38")
		set wurst_stack_depth = wurst_stack_depth - 1
		return
	endif
	if timer_getData(this_1, "when calling getData in TimerUtils, line 40") == TimerUtils_HELD then
		call error("ReleaseTimer: Double free!", "when calling error in TimerUtils, line 41")
		set wurst_stack_depth = wurst_stack_depth - 1
		return
	endif
	call timer_setData(this_1, TimerUtils_HELD, "when calling setData in TimerUtils, line 43")
	call timer_pause(this_1)
	set TimerUtils_freeTimers[TimerUtils_freeTimersCount] = this_1
	set TimerUtils_freeTimersCount = TimerUtils_freeTimersCount + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackCounted_onDestroy takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call timer_release(CallbackCounted_t[this_1], "when calling release in ClosureTimers, line 182")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_CallbackCounted takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[obj] == 0 then
		call error("Double free: object of type CallbackCounted", "when calling error in ClosureTimers, line 144")
	else
		set CallbackCounted_nextFree[CallbackCounted_firstFree] = obj
		set CallbackCounted_firstFree = CallbackCounted_firstFree + 1
		set CallbackCounted_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyCallbackCounted takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call CallbackCounted_onDestroy(this_1, "when calling CallbackCounted_onDestroy in ClosureTimers, line 181")
	call dealloc_CallbackCounted(this_1, "when calling dealloc_CallbackCounted in ClosureTimers, line 181")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackCounted_destroyCallbackCounted takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.CallbackCounted", "when calling error in ClosureTimers, line 144")
		else
			call error("Called CallbackCounted.CallbackCounted on invalid object.", "when calling error in ClosureTimers, line 144")
		endif
	endif
	call destroyCallbackCounted(this_1, "when calling destroyCallbackCounted in ClosureTimers, line 144")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackCounted_callAndCount takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_count[this_1] > 0 then
		set CallbackCounted_count[this_1] = CallbackCounted_count[this_1] - 1
		call dispatch_CallbackCounted_ClosureTimers_CallbackCounted_call(this_1, this_1, "when calling call in ClosureTimers, line 177")
	else
		call dispatch_CallbackCounted_destroyCallbackCounted(this_1, "when calling dispatch_CallbackCounted_destroyCallbackCounted in ClosureTimers, line 179")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackCounted_ClosureTimers_CallbackCounted_callAndCount takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.callAndCount", "when calling error in ClosureTimers, line 174")
		else
			call error("Called CallbackCounted.callAndCount on invalid object.", "when calling error in ClosureTimers, line 174")
		endif
	endif
	call CallbackCounted_callAndCount(this_1, "when calling callAndCount in ClosureTimers, line 174")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackCounted_staticCallback takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_CallbackCounted_ClosureTimers_CallbackCounted_callAndCount(timer_getData(GetExpiredTimer(), "when calling getData in ClosureTimers, line 172"), "when calling callAndCount in ClosureTimers, line 172")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_CallbackCounted_staticCallback takes nothing returns nothing
	set wurst_stack_depth = 0
	call CallbackCounted_staticCallback("via function reference ClosureTimers, line 156")
endfunction

function alloc_Razor takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Razor_firstFree == 0 then
		if Razor_maxIndex < 32768 then
			set Razor_maxIndex = Razor_maxIndex + 1
			set this_1 = Razor_maxIndex
			set Razor_typeId[this_1] = 751
		else
			call error("Out of memory: Could not create Razor.", "when calling error in Razor, line 16")
			set this_1 = 0
		endif
	else
		set Razor_firstFree = Razor_firstFree - 1
		set this_1 = Razor_nextFree[Razor_firstFree]
		set Razor_typeId[this_1] = 751
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function construct_Razor_LinkedListModule takes integer this_1 returns nothing
	set Razor_LinkedListModule_size = Razor_LinkedListModule_size + 1
	if Razor_LinkedListModule_size == 1 then
		set Razor_LinkedListModule_first = this_1
		set Razor_LinkedListModule_prev[this_1] = 0
	else
		set Razor_LinkedListModule_prev[this_1] = Razor_LinkedListModule_last
		set Razor_LinkedListModule_next[Razor_LinkedListModule_last] = this_1
		set Razor_LinkedListModule_prev[Razor_LinkedListModule_first] = this_1
	endif
	set Razor_LinkedListModule_next[this_1] = 0
	set Razor_LinkedListModule_last = this_1
endfunction

function Razor_init takes integer this_1 returns nothing
	set Razor_hitFxPath[this_1] = Abilities_farseerMissile
	call construct_Razor_LinkedListModule(this_1)
endfunction

function addLightning takes string codeName, boolean checkVisibility, real start_x, real start_y, real w_end_x, real w_end_y returns lightning
	return AddLightning(codeName, checkVisibility, start_x, start_y, w_end_x, w_end_y)
endfunction

function alloc_CallbackCounted_doPeriodicallyTimed_Razor_Razor takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_firstFree == 0 then
		if CallbackCounted_maxIndex < 32768 then
			set CallbackCounted_maxIndex = CallbackCounted_maxIndex + 1
			set this_1 = CallbackCounted_maxIndex
			set CallbackCounted_typeId[this_1] = 643
		else
			call error("Out of memory: Could not create CallbackCounted_doPeriodicallyTimed_Razor_Razor.", "when calling error in Razor, line 31")
			set this_1 = 0
		endif
	else
		set CallbackCounted_firstFree = CallbackCounted_firstFree - 1
		set this_1 = CallbackCounted_nextFree[CallbackCounted_firstFree]
		set CallbackCounted_typeId[this_1] = 643
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function CallbackCounted_init takes integer this_1 returns nothing
	set CallbackCounted_count[this_1] = 0
	set CallbackCounted_maxCount[this_1] = 0
endfunction

function construct_CallbackCounted takes integer this_1 returns nothing
	call CallbackCounted_init(this_1)
endfunction

function getTimer takes string w__wurst_stackPos returns timer
	local timer receiver
	local timer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if TimerUtils_freeTimersCount > 0 then
		set TimerUtils_freeTimersCount = TimerUtils_freeTimersCount - 1
		call timer_setData(TimerUtils_freeTimers[TimerUtils_freeTimersCount], 0, "when calling setData in TimerUtils, line 30")
		set wurst_stack_depth = wurst_stack_depth - 1
		set receiver = null
		set stackTrace_tempReturn = null
		return TimerUtils_freeTimers[TimerUtils_freeTimersCount]
	else
		set receiver = CreateTimer()
		call timer_setData(receiver, 0, "when calling setData in TimerUtils, line 33")
		set stackTrace_tempReturn = receiver
		set wurst_stack_depth = wurst_stack_depth - 1
		set getTimertempReturn = stackTrace_tempReturn
		set receiver = null
		set stackTrace_tempReturn = null
		return getTimertempReturn
	endif
endfunction

function timer_startPeriodic takes timer this_1, real time, code timerCallBack returns nothing
	call TimerStart(this_1, time, true, timerCallBack)
endfunction

function CallbackCounted_start takes integer this_1, timer whichTimer, real time, integer callAmount, string w__wurst_stackPos returns nothing
	local timer receiver
	local timer receiver_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set CallbackCounted_count[this_1] = callAmount
	set CallbackCounted_maxCount[this_1] = callAmount
	set receiver = whichTimer
	call timer_setData(receiver, this_1, "when calling setData in ClosureTimers, line 155")
	set receiver_1 = receiver
	call timer_startPeriodic(receiver_1, time, ref_function_bridge_CallbackCounted_staticCallback)
	set CallbackCounted_t[this_1] = receiver_1
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
endfunction

function dispatch_CallbackCounted_ClosureTimers_CallbackCounted_start takes integer this_1, timer whichTimer, real time, integer callAmount, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackCounted.start", "when calling error in ClosureTimers, line 151")
		else
			call error("Called CallbackCounted.start on invalid object.", "when calling error in ClosureTimers, line 151")
		endif
	endif
	call CallbackCounted_start(this_1, whichTimer, time, callAmount, "when calling start in ClosureTimers, line 151")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_doPeriodicallyCounted takes timer this_1, real time, integer callAmount, integer cb, string w__wurst_stackPos returns integer
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_CallbackCounted_ClosureTimers_CallbackCounted_start(cb, this_1, time, callAmount, "when calling start in ClosureTimers, line 69")
	set wurst_stack_depth = wurst_stack_depth - 1
	return cb
endfunction

function timer_doPeriodicallyTimed takes timer this_1, real interval, real timerDuration, integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = timer_doPeriodicallyCounted(this_1, interval, real_toInt(timerDuration / interval + 0.5), cb, "when calling doPeriodicallyCounted in ClosureTimers, line 93")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function doPeriodicallyTimed takes real interval, real timerDuration, integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = timer_doPeriodicallyTimed(getTimer("when calling getTimer in ClosureTimers, line 104"), interval, timerDuration, cb, "when calling doPeriodicallyTimed in ClosureTimers, line 104")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function construct_Razor takes integer this_1, real p1_x, real p1_y, real p2_x, real p2_y, real direction_x, real direction_y, real speed, real lifetime, string w__wurst_stackPos returns nothing
	local integer clVar
	local real temp
	local real temp_1
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call Razor_init(this_1)
	set tuple_temp = vec2_norm(direction_x, direction_y)
	set tuple_temp_1 = vec2_norm_return_y
	set Razor_dir_x[this_1] = tuple_temp
	set Razor_dir_y[this_1] = tuple_temp_1
	set tuple_temp_2 = p1_x
	set tuple_temp_3 = p1_y
	set Razor_p1_x[this_1] = tuple_temp_2
	set Razor_p1_y[this_1] = tuple_temp_3
	set tuple_temp_4 = p2_x
	set tuple_temp_5 = p2_y
	set Razor_p2_x[this_1] = tuple_temp_4
	set Razor_p2_y[this_1] = tuple_temp_5
	set Razor_ltn[this_1] = addLightning(Lightning_LIGHTNING_CHAIN_LIGHTNING_PRIMARY, false, p1_x, p1_y, p2_x, p2_y)
	set Razor_speed[this_1] = speed
	set temp = Basics_ANIMATION_PERIOD
	set temp_1 = lifetime
	set clVar = alloc_CallbackCounted_doPeriodicallyTimed_Razor_Razor("when calling alloc_CallbackCounted_doPeriodicallyTimed_Razor_Razor in Razor, line 31")
	call construct_CallbackCounted(clVar)
	set this[clVar] = this_1
	call doPeriodicallyTimed(temp, temp_1, clVar, "when calling doPeriodicallyTimed in Razor, line 31")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function new_Razor takes real p1_x, real p1_y, real p2_x, real p2_y, real direction_x, real direction_y, real speed, real lifetime, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Razor("when calling alloc_Razor in Razor, line 25")
	call construct_Razor(this_1, p1_x, p1_y, p2_x, p2_y, direction_x, direction_y, speed, lifetime, "when calling construct_Razor in Razor, line 25")
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_RazorRed takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Razor_firstFree == 0 then
		if Razor_maxIndex < 32768 then
			set Razor_maxIndex = Razor_maxIndex + 1
			set this_1 = Razor_maxIndex
			set Razor_typeId[this_1] = 752
		else
			call error("Out of memory: Could not create RazorRed.", "when calling error in Razor, line 72")
			set this_1 = 0
		endif
	else
		set Razor_firstFree = Razor_firstFree - 1
		set this_1 = Razor_nextFree[Razor_firstFree]
		set Razor_typeId[this_1] = 752
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function RazorRed_init takes integer this_1 returns nothing
endfunction

function construct_RazorRed takes integer this_1, real p1_x, real p1_y, real p2_x, real p2_y, real direction_x, real direction_y, real speed, real lifetime, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call construct_Razor(this_1, p1_x, p1_y, p2_x, p2_y, direction_x, direction_y, speed, lifetime, "when calling construct_Razor in Razor, line 73")
	call RazorRed_init(this_1)
	call lightning_destr(Razor_ltn[this_1])
	set Razor_ltn[this_1] = addLightning(Lightning_LIGHTNING_FINGER_OF_DEATH, false, p1_x, p1_y, p2_x, p2_y)
	set Razor_hitFxPath[this_1] = Abilities_vengeanceMissile
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function new_RazorRed takes real p1_x, real p1_y, real p2_x, real p2_y, real direction_x, real direction_y, real speed, real lifetime, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_RazorRed("when calling alloc_RazorRed in Razor, line 73")
	call construct_RazorRed(this_1, p1_x, p1_y, p2_x, p2_y, direction_x, direction_y, speed, lifetime, "when calling construct_RazorRed in Razor, line 73")
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function vec2_normalizedPointerTo takes real this_x, real this_y, real target_x, real target_y returns real
	local real tuple_temp = vec2_op_minus(target_x, target_y, this_x, this_y)
	local real tuple_temp_1 = vec2_op_minus_return_y
	local real diff_x = tuple_temp
	local real diff_y = tuple_temp_1
	local real len = vec2_length(diff_x, diff_y)
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	if len > 0. then
		set tuple_temp_2 = vec2_op_mult(diff_x, diff_y, 1. / len)
		set tuple_temp_3 = vec2_op_mult_return_y
		set diff_x = tuple_temp_2
		set diff_y = tuple_temp_3
	else
		set tuple_temp_4 = 1.
		set tuple_temp_5 = 0.
		set diff_x = tuple_temp_4
		set diff_y = tuple_temp_5
	endif
	set vec2_normalizedPointerTo_return_x = diff_x
	set vec2_normalizedPointerTo_return_y = diff_y
	return vec2_normalizedPointerTo_return_x
endfunction

function angle_cos takes real this_radians returns real
	return Cos(this_radians)
endfunction

function angle_sin takes real this_radians returns real
	return Sin(this_radians)
endfunction

function vec2_rotate takes real this_x, real this_y, real angl_radians returns real
	local real c = angle_cos(angl_radians)
	local real s = angle_sin(angl_radians)
	local real px = this_x * c - this_y * s
	local real py = this_x * s + this_y * c
	set vec2_rotate_return_x = px
	set vec2_rotate_return_y = py
	return vec2_rotate_return_x
endfunction

function call_doPeriodically_Razor takes integer this_1, integer cb, string w__wurst_stackPos returns nothing
	local real dir_x
	local real dir_y
	local integer temp
	local real p1_x
	local real p1_y
	local real p2_x
	local real p2_y
	local real p1_x_1
	local real p1_y_1
	local real p2_x_1
	local real p2_y_1
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	local real tuple_temp_9
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set choice[this_1] = choice[this_1] * -1
	set tuple_temp = vec2_normalizedPointerTo(Razor_START_POS_x, Razor_START_POS_y, Razor_FINISH_POS_x, Razor_FINISH_POS_y)
	set tuple_temp_1 = vec2_normalizedPointerTo_return_y
	set dir_x = tuple_temp
	set dir_y = tuple_temp_1
	set temp = choice[this_1]
	if temp == 1 then
		set tuple_temp_2 = vec2_op_plus(Razor_START_POS_x, Razor_START_POS_y, vec2_op_mult(vec2_op_mult(vec2_rotate(dir_x, dir_y, Maths_PI * 0.5), vec2_rotate_return_y, Razor_WIDTH), vec2_op_mult_return_y, 0.5), vec2_op_mult_return_y)
		set tuple_temp_3 = vec2_op_plus_return_y
		set p1_x = tuple_temp_2
		set p1_y = tuple_temp_3
		set tuple_temp_4 = vec2_op_minus(Razor_START_POS_x, Razor_START_POS_y, vec2_op_mult(vec2_op_mult(vec2_rotate(dir_x, dir_y, Maths_PI * 0.5), vec2_rotate_return_y, Razor_WIDTH), vec2_op_mult_return_y, 0.5), vec2_op_mult_return_y)
		set tuple_temp_5 = vec2_op_minus_return_y
		set p2_x = tuple_temp_4
		set p2_y = tuple_temp_5
		call new_Razor(p1_x, p1_y, p2_x, p2_y, dir_x, dir_y, Razor_SPEED, vec2_distanceTo(Razor_START_POS_x, Razor_START_POS_y, Razor_FINISH_POS_x, Razor_FINISH_POS_y) / Razor_SPEED, "when calling new_Razor in Razor, line 90")
	elseif temp == -1 then
		set tuple_temp_6 = vec2_op_minus(Razor_START_POS_x, Razor_START_POS_y, vec2_op_mult(vec2_op_mult(vec2_rotate(dir_x, dir_y, Maths_PI * 0.5), vec2_rotate_return_y, Razor_WIDTH), vec2_op_mult_return_y, 0.5), vec2_op_mult_return_y)
		set tuple_temp_7 = vec2_op_minus_return_y
		set p1_x_1 = tuple_temp_6
		set p1_y_1 = tuple_temp_7
		set tuple_temp_8 = vec2_op_plus(Razor_START_POS_x, Razor_START_POS_y, vec2_op_mult(vec2_op_mult(vec2_rotate(dir_x, dir_y, Maths_PI * 0.5), vec2_rotate_return_y, Razor_WIDTH), vec2_op_mult_return_y, 0.5), vec2_op_mult_return_y)
		set tuple_temp_9 = vec2_op_plus_return_y
		set p2_x_1 = tuple_temp_8
		set p2_y_1 = tuple_temp_9
		call new_RazorRed(p1_x_1, p1_y_1, p2_x_1, p2_y_1, dir_x, dir_y, Razor_SPEED, vec2_distanceTo(Razor_START_POS_x, Razor_START_POS_y, Razor_FINISH_POS_x, Razor_FINISH_POS_y) / Razor_SPEED, "when calling new_RazorRed in Razor, line 94")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackPeriodic_onDestroy takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call timer_release(CallbackPeriodic_t[this_1], "when calling release in ClosureTimers, line 142")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_CallbackPeriodic takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackPeriodic_typeId[obj] == 0 then
		call error("Double free: object of type CallbackPeriodic", "when calling error in ClosureTimers, line 127")
	else
		set CallbackPeriodic_nextFree[CallbackPeriodic_firstFree] = obj
		set CallbackPeriodic_firstFree = CallbackPeriodic_firstFree + 1
		set CallbackPeriodic_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyCallbackPeriodic takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call CallbackPeriodic_onDestroy(this_1, "when calling CallbackPeriodic_onDestroy in ClosureTimers, line 141")
	call dealloc_CallbackPeriodic(this_1, "when calling dealloc_CallbackPeriodic in ClosureTimers, line 141")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackPeriodic_destroyCallbackPeriodic takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackPeriodic_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackPeriodic.CallbackPeriodic", "when calling error in ClosureTimers, line 127")
		else
			call error("Called CallbackPeriodic.CallbackPeriodic on invalid object.", "when calling error in ClosureTimers, line 127")
		endif
	endif
	call destroyCallbackPeriodic(this_1, "when calling destroyCallbackPeriodic in ClosureTimers, line 127")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function lightning_setColor takes lightning this_1, integer c_red, integer c_green, integer c_blue, integer c_alpha returns boolean
	return SetLightningColor(this_1, c_red * 1. / 255, c_green * 1. / 255, c_blue * 1. / 255, c_alpha * 1. / 255)
endfunction

function call_doPeriodically_Shield_ShieldGenerator takes integer this_1, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set alpha[this_1] = alpha[this_1] - 255. * 0.02
	if alpha[this_1] > 0. then
		call lightning_setColor(timed1[this_1], 255, 255, 255, real_toInt(alpha[this_1]))
		call lightning_setColor(timed2[this_1], 255, 255, 255, real_toInt(alpha[this_1]))
		call lightning_setColor(timed3[this_1], 255, 255, 255, real_toInt(alpha[this_1]))
		call lightning_setColor(timed4[this_1], 255, 255, 255, real_toInt(alpha[this_1]))
	else
		call dispatch_CallbackPeriodic_destroyCallbackPeriodic(cb, "when calling dispatch_CallbackPeriodic_destroyCallbackPeriodic in ShieldGenerator, line 74")
		call lightning_destr(timed1[this_1])
		call lightning_destr(timed2[this_1])
		call lightning_destr(timed3[this_1])
		call lightning_destr(timed4[this_1])
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackPeriodic_ClosureTimers_CallbackPeriodic_call takes integer this_1, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackPeriodic_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackPeriodic.call", "when calling error in ClosureTimers, line 130")
		else
			call error("Called CallbackPeriodic.call on invalid object.", "when calling error in ClosureTimers, line 130")
		endif
	endif
	if CallbackPeriodic_typeId[this_1] <= 646 then
		call call_doPeriodically_Razor(this_1, cb, "when calling call_doPeriodically_Razor in ClosureTimers, line 130")
	else
		call call_doPeriodically_Shield_ShieldGenerator(this_1, cb, "when calling call_doPeriodically_Shield_ShieldGenerator in ClosureTimers, line 130")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackPeriodic_staticCallback takes string w__wurst_stackPos returns nothing
	local integer cb
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set cb = timer_getData(GetExpiredTimer(), "when calling getData in ClosureTimers, line 138")
	call dispatch_CallbackPeriodic_ClosureTimers_CallbackPeriodic_call(cb, cb, "when calling call in ClosureTimers, line 139")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_CallbackPeriodic_staticCallback takes nothing returns nothing
	set wurst_stack_depth = 0
	call CallbackPeriodic_staticCallback("via function reference ClosureTimers, line 135")
endfunction

function EventData_getDyingUnit takes nothing returns unit
	return GetDyingUnit()
endfunction

function alloc_CallbackCounted_doPeriodicallyTimed_add_Character takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackCounted_firstFree == 0 then
		if CallbackCounted_maxIndex < 32768 then
			set CallbackCounted_maxIndex = CallbackCounted_maxIndex + 1
			set this_1 = CallbackCounted_maxIndex
			set CallbackCounted_typeId[this_1] = 644
		else
			call error("Out of memory: Could not create CallbackCounted_doPeriodicallyTimed_add_Character.", "when calling error in Character, line 63")
			set this_1 = 0
		endif
	else
		set CallbackCounted_firstFree = CallbackCounted_firstFree - 1
		set this_1 = CallbackCounted_nextFree[CallbackCounted_firstFree]
		set CallbackCounted_typeId[this_1] = 644
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_CallbackSingle_doAfter_add_Character takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this_1 = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this_1] = 653
		else
			call error("Out of memory: Could not create CallbackSingle_doAfter_add_Character.", "when calling error in Character, line 65")
			set this_1 = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this_1 = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this_1] = 653
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function CallbackSingle_init takes integer this_1 returns nothing
endfunction

function construct_CallbackSingle takes integer this_1 returns nothing
	call CallbackSingle_init(this_1)
endfunction

function timer_createTimerDialog takes timer this_1 returns timerdialog
	return CreateTimerDialog(this_1)
endfunction

function timer_start takes timer this_1, real time, code timerCallBack returns nothing
	call TimerStart(this_1, time, false, timerCallBack)
endfunction

function CallbackSingle_start takes integer this_1, timer whichTimer, real time, string w__wurst_stackPos returns nothing
	local timer receiver
	local timer receiver_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set receiver = whichTimer
	call timer_setData(receiver, this_1, "when calling setData in ClosureTimers, line 113")
	set receiver_1 = receiver
	call timer_start(receiver_1, time, ref_function_bridge_code__start_CallbackSingle_ClosureTimers)
	set CallbackSingle_t[this_1] = receiver_1
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
endfunction

function dispatch_CallbackSingle_ClosureTimers_CallbackSingle_start takes integer this_1, timer whichTimer, real time, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackSingle.start", "when calling error in ClosureTimers, line 111")
		else
			call error("Called CallbackSingle.start on invalid object.", "when calling error in ClosureTimers, line 111")
		endif
	endif
	call CallbackSingle_start(this_1, whichTimer, time, "when calling start in ClosureTimers, line 111")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_doAfter takes timer this_1, real timeToWait, integer cb, string w__wurst_stackPos returns integer
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_CallbackSingle_ClosureTimers_CallbackSingle_start(cb, this_1, timeToWait, "when calling start in ClosureTimers, line 16")
	set wurst_stack_depth = wurst_stack_depth - 1
	return cb
endfunction

function timerdialog_display takes timerdialog this_1, boolean display returns nothing
	call TimerDialogDisplay(this_1, display)
endfunction

function onEvent_add_Character takes integer this_1, string w__wurst_stackPos returns nothing
	local unit dyingUnit_1
	local timer reviveTimer
	local timerdialog reviveTimerDialog_1
	local integer clVar
	local integer clVar_1
	local real temp
	local timer temp_1
	local real temp_2
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set dyingUnit_1 = EventData_getDyingUnit()
	call flashEffect("Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl", unit_getPos(dyingUnit_1), unit_getPos_return_y)
	set reviveTimer = getTimer("when calling getTimer in Character, line 59")
	set reviveTimerDialog_1 = timer_createTimerDialog(reviveTimer)
	call timerdialog_display(reviveTimerDialog_1, true)
	set temp = Character_REVIVE_TIME
	set clVar = alloc_CallbackCounted_doPeriodicallyTimed_add_Character("when calling alloc_CallbackCounted_doPeriodicallyTimed_add_Character in Character, line 63")
	call construct_CallbackCounted(clVar)
	call doPeriodicallyTimed(0.02, temp, clVar, "when calling doPeriodicallyTimed in Character, line 63")
	set temp_1 = reviveTimer
	set temp_2 = Character_REVIVE_TIME
	set clVar_1 = alloc_CallbackSingle_doAfter_add_Character("when calling alloc_CallbackSingle_doAfter_add_Character in Character, line 65")
	call construct_CallbackSingle(clVar_1)
	set dyingUnit[clVar_1] = dyingUnit_1
	set reviveTimerDialog[clVar_1] = reviveTimerDialog_1
	call timer_doAfter(temp_1, temp_2, clVar_1, "when calling doAfter in Character, line 65")
	set wurst_stack_depth = wurst_stack_depth - 1
	set dyingUnit_1 = null
	set reviveTimer = null
	set reviveTimerDialog_1 = null
	set temp_1 = null
endfunction

function EventData_getChatMessage takes nothing returns string
	return GetEventPlayerChatString()
endfunction

function rect_getCenterX takes rect this_1 returns real
	return GetRectCenterX(this_1)
endfunction

function rect_getCenterY takes rect this_1 returns real
	return GetRectCenterY(this_1)
endfunction

function rect_getCenter takes rect this_1 returns real
	set rect_getCenter_return_x = rect_getCenterX(this_1)
	set rect_getCenter_return_y = rect_getCenterY(this_1)
	return rect_getCenter_return_x
endfunction

function unit_setPos takes unit this_1, real pos_x, real pos_y returns nothing
	call SetUnitPosition(this_1, pos_x, pos_y)
endfunction

function onEvent_add_Character_866 takes integer this_1 returns nothing
	if EventData_getChatMessage() == "goToCheckpoint" then
		call unit_setPos(Character_character, rect_getCenter(gg_rct_Checkpoint), rect_getCenter_return_y)
	endif
endfunction

function EventData_getTriggerUnit takes nothing returns unit
	return GetTriggerUnit()
endfunction

function unit_addAbility takes unit this_1, integer abil returns boolean
	return UnitAddAbility(this_1, abil)
endfunction

function onEvent_add_ShieldGenerator takes integer this_1 returns nothing
	call unit_addAbility(EventData_getTriggerUnit(), ShieldGenerator_ABOVE_SHIELD_ID)
	call unit_addAbility(EventData_getTriggerUnit(), ShieldGenerator_FRONT_SHIELD_ID)
endfunction

function unit_removeAbility takes unit this_1, integer abil returns boolean
	return UnitRemoveAbility(this_1, abil)
endfunction

function onEvent_add_ShieldGenerator_868 takes integer this_1 returns nothing
	call unit_removeAbility(EventData_getTriggerUnit(), ShieldGenerator_ABOVE_SHIELD_ID)
	call unit_removeAbility(EventData_getTriggerUnit(), ShieldGenerator_FRONT_SHIELD_ID)
endfunction

function EventData_getSpellAbilityId takes nothing returns integer
	return GetSpellAbilityId()
endfunction

function Shield_LinkedListModule_remove takes integer this_1 returns nothing
	set Shield_LinkedListModule_size = Shield_LinkedListModule_size - 1
	if this_1 != Shield_LinkedListModule_first then
		set Shield_LinkedListModule_next[Shield_LinkedListModule_prev[this_1]] = Shield_LinkedListModule_next[this_1]
	else
		set Shield_LinkedListModule_first = Shield_LinkedListModule_next[this_1]
	endif
	if this_1 != Shield_LinkedListModule_last then
		set Shield_LinkedListModule_prev[Shield_LinkedListModule_next[this_1]] = Shield_LinkedListModule_prev[this_1]
	else
		set Shield_LinkedListModule_last = Shield_LinkedListModule_prev[this_1]
	endif
endfunction

function dispatch_Shield_ShieldGenerator_Shield_LinkedListModule_remove takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Shield_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Shield.remove", "when calling error in LinkedListModule, line 37")
		else
			call error("Called Shield.remove on invalid object.", "when calling error in LinkedListModule, line 37")
		endif
	endif
	call Shield_LinkedListModule_remove(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Shield_onDestroy takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call lightning_destr(Shield_l1[this_1])
	call lightning_destr(Shield_l2[this_1])
	call lightning_destr(Shield_l3[this_1])
	call lightning_destr(Shield_l4[this_1])
	call dispatch_Shield_ShieldGenerator_Shield_LinkedListModule_remove(this_1, "when calling remove in LinkedListModule, line 49")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_Shield takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Shield_typeId[obj] == 0 then
		call error("Double free: object of type Shield", "when calling error in ShieldGenerator, line 30")
	else
		set Shield_nextFree[Shield_firstFree] = obj
		set Shield_firstFree = Shield_firstFree + 1
		set Shield_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyShield takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call Shield_onDestroy(this_1, "when calling Shield_onDestroy in ShieldGenerator, line 82")
	call dealloc_Shield(this_1, "when calling dealloc_Shield in ShieldGenerator, line 82")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_Shield_destroyShield takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Shield_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Shield.Shield", "when calling error in ShieldGenerator, line 30")
		else
			call error("Called Shield.Shield on invalid object.", "when calling error in ShieldGenerator, line 30")
		endif
	endif
	call destroyShield(this_1, "when calling destroyShield in ShieldGenerator, line 30")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function onEvent_add_onCast_ShieldGenerator takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventData_getSpellAbilityId() == id_482[this_1] and EventData_getTriggerUnit() == caster_455[this_1] then
		call dispatch_Shield_destroyShield(shield[this_1], "when calling dispatch_Shield_destroyShield in ShieldGenerator, line 168")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_EventListener_ClosureEvents_EventListener_onEvent takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling EventListener.onEvent", "when calling error in ClosureEvents, line 110")
		else
			call error("Called EventListener.onEvent on invalid object.", "when calling error in ClosureEvents, line 110")
		endif
	endif
	if EventListener_typeId[this_1] <= 666 then
		if EventListener_typeId[this_1] <= 665 then
			if EventListener_typeId[this_1] <= 664 then
				call onEvent_add_Character(this_1, "when calling onEvent_add_Character in ClosureEvents, line 110")
			else
				call onEvent_add_Character_866(this_1)
			endif
		else
			call onEvent_add_ShieldGenerator(this_1)
		endif
	elseif EventListener_typeId[this_1] <= 667 then
		call onEvent_add_ShieldGenerator_868(this_1)
	else
		call onEvent_add_onCast_ShieldGenerator(this_1, "when calling onEvent_add_onCast_ShieldGenerator in ClosureEvents, line 110")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function eventid_isKeyboardEvent takes eventid this_1 returns boolean
	local integer eventId = handle_getHandleId(this_1)
	return (eventId >= 261 and eventId <= 268) or eventId == 17
endfunction

function eventid_isMouseEvent takes eventid this_1 returns boolean
	local integer eventId = handle_getHandleId(this_1)
	return eventId >= 305 and eventId <= 307
endfunction

function eventid_isPlayerunitEvent takes eventid this_1 returns boolean
	local integer eventId = handle_getHandleId(this_1)
	return (eventId >= 18 and eventId <= 51) or (eventId >= 269 and eventId <= 277) or eventId == 315 or eventId == 308
endfunction

function trigger_addAction takes trigger this_1, code actionFunc returns triggeraction
	return TriggerAddAction(this_1, actionFunc)
endfunction

function trigger_addCondition takes trigger this_1, boolexpr condition returns triggercondition
	return TriggerAddCondition(this_1, condition)
endfunction

function trigger_registerPlayerUnitEvent takes trigger this_1, player whichPlayer, playerunitevent whichPlayerUnitEvent, boolexpr filter returns event
	return TriggerRegisterPlayerUnitEvent(this_1, whichPlayer, whichPlayerUnitEvent, filter)
endfunction

function registerPlayerUnitEvent_911 takes playerunitevent p, code filter, code condition, code action returns nothing
	local integer hid = handle_getHandleId(p)
	local integer k
	local filterfunc cond_result
	local trigger temp
	local player temp_1
	local playerunitevent temp_2
	if RegisterEvents_t[hid] == null then
		set RegisterEvents_t[hid] = CreateTrigger()
		set k = bj_MAX_PLAYER_SLOTS - 1
		loop
			exitwhen k < 0
			set temp = RegisterEvents_t[hid]
			set temp_1 = Player_players[k]
			set temp_2 = p
			if filter != null then
				set cond_result = Filter(filter)
			else
				set cond_result = null
			endif
			call trigger_registerPlayerUnitEvent(temp, temp_1, temp_2, cond_result)
			set k = k - 1
		endloop
	endif
	if condition != null then
		call trigger_addCondition(RegisterEvents_t[hid], Filter(condition))
	endif
	if action != null then
		call trigger_addAction(RegisterEvents_t[hid], action)
	endif
	set cond_result = null
	set temp = null
	set temp_1 = null
	set temp_2 = null
endfunction

function registerPlayerUnitEvent takes playerunitevent p, code c returns nothing
	call registerPlayerUnitEvent_911(p, null, c, null)
endfunction

function trigger_registerPlayerEvent takes trigger this_1, player whichPlayer, playerevent whichPlayerEvent returns event
	return TriggerRegisterPlayerEvent(this_1, whichPlayer, whichPlayerEvent)
endfunction

function registerEventId takes eventid evnt, string w__wurst_stackPos returns integer
	local integer eventId
	local integer i
	local integer temp
	local trigger receiver
	local trigger receiver_1
	local trigger receiver_2
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set eventId = handle_getHandleId(evnt)
	set ClosureEvents_eventTypeCounter = ClosureEvents_eventTypeCounter + 1
	set ClosureEvents_eventidToIndex[eventId] = ClosureEvents_eventTypeCounter
	if eventid_isPlayerunitEvent(evnt) then
		call registerPlayerUnitEvent(ConvertPlayerUnitEvent(eventId), ref_function_bridge_EventListener_generalEventCallback)
	elseif evnt != EVENT_UNIT_DAMAGED and evnt != EVENT_PLAYER_LEAVE and evnt != ClosureEvents_EVENT_PLAYER_CHAT_FILTER and ( not eventid_isKeyboardEvent(evnt)) and ( not eventid_isMouseEvent(evnt)) then
		call error("registering handleid: " + int_toString(eventId) + " non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.", "when calling error in ClosureEvents, line 247")
	endif
	if eventid_isMouseEvent(evnt) and ( not EventListener_useMouseEvents) then
		set EventListener_useMouseEvents = true
		set i = 0
		set temp = bj_MAX_PLAYERS - 1
		loop
			exitwhen i > temp
			set receiver = ClosureEvents_keyTrig
			call trigger_registerPlayerEvent(receiver, Player_players[i], EVENT_PLAYER_MOUSE_UP)
			set receiver_1 = receiver
			call trigger_registerPlayerEvent(receiver_1, Player_players[i], EVENT_PLAYER_MOUSE_DOWN)
			set receiver_2 = receiver_1
			call trigger_registerPlayerEvent(receiver_2, Player_players[i], EVENT_PLAYER_MOUSE_MOVE)
			set i = i + 1
		endloop
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
	return ClosureEvents_eventTypeCounter
endfunction

function eventid_toIntId takes eventid this_1, string w__wurst_stackPos returns integer
	local integer id_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set id_1 = ClosureEvents_eventidToIndex[handle_getHandleId(this_1)]
	if id_1 == 0 then
		set id_1 = registerEventId(this_1, "when calling registerEventId in ClosureEvents, line 234")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return id_1
endfunction

function fireEvents takes unit w_u returns boolean
	return true
endfunction

function unit_getUserData takes unit this_1 returns integer
	return GetUnitUserData(this_1)
endfunction

function unit_getIndex takes unit this_1 returns integer
	return unit_getUserData(this_1)
endfunction

function EventListener_generalEventCallback takes string w__wurst_stackPos returns nothing
	local unit trigUnit
	local integer id_1
	local integer listener
	local integer nextListener
	local integer listener_1
	local integer nextListener_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set trigUnit = GetTriggerUnit()
	set id_1 = eventid_toIntId(GetTriggerEventId(), "when calling toIntId in ClosureEvents, line 172")
	if trigUnit != null and fireEvents(trigUnit) and unit_getIndex(trigUnit) > 0 then
		if EventListener_unitListenersFirsts[unit_getIndex(trigUnit)] != 0 then
			set listener = EventListener_unitListenersFirsts[unit_getIndex(trigUnit)]
			loop
				exitwhen  not (listener != 0)
				set nextListener = EventListener_next[listener]
				if EventListener_eventId[listener] == id_1 then
					call dispatch_EventListener_ClosureEvents_EventListener_onEvent(listener, "when calling onEvent in ClosureEvents, line 180")
				endif
				set listener = nextListener
			endloop
		endif
	endif
	if EventListener_generalListenersFirsts[id_1] != 0 then
		set listener_1 = EventListener_generalListenersFirsts[id_1]
		loop
			exitwhen  not (listener_1 != 0)
			set nextListener_1 = EventListener_next[listener_1]
			call dispatch_EventListener_ClosureEvents_EventListener_onEvent(listener_1, "when calling onEvent in ClosureEvents, line 187")
			set listener_1 = nextListener_1
		endloop
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	set trigUnit = null
endfunction

function bridge_EventListener_generalEventCallback takes nothing returns nothing
	set wurst_stack_depth = 0
	call EventListener_generalEventCallback("via function reference ClosureEvents, line 245")
endfunction

function alloc_ForGroupCallback_forUnitsInRange_Segment_Segment takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_firstFree == 0 then
		if ForGroupCallback_maxIndex < 32768 then
			set ForGroupCallback_maxIndex = ForGroupCallback_maxIndex + 1
			set this_1 = ForGroupCallback_maxIndex
			set ForGroupCallback_typeId[this_1] = 675
		else
			call error("Out of memory: Could not create ForGroupCallback_forUnitsInRange_Segment_Segment.", "when calling error in Segment, line 43")
			set this_1 = 0
		endif
	else
		set ForGroupCallback_firstFree = ForGroupCallback_firstFree - 1
		set this_1 = ForGroupCallback_nextFree[ForGroupCallback_firstFree]
		set ForGroupCallback_typeId[this_1] = 675
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function angle_op_mult takes real this_radians, real scalar returns real
	set angle_op_mult_return_radians = this_radians * scalar
	return angle_op_mult_return_radians
endfunction

function lightning_move_839 takes lightning this_1, boolean checkVisibility, real start_x, real start_y, real start_z, real w_end_x, real w_end_y, real w_end_z returns boolean
	return MoveLightningEx(this_1, checkVisibility, start_x, start_y, start_z, w_end_x, w_end_y, w_end_z)
endfunction

function vec2_toVec3 takes real this_x, real this_y returns real
	set vec2_toVec3_return_x = this_x
	set vec2_toVec3_return_y = this_y
	set vec2_toVec3_return_z = 0.
	return vec2_toVec3_return_x
endfunction

function Segment_update takes integer this_1, real delay, string w__wurst_stackPos returns nothing
	local real a_radians
	local integer clVar
	local real temp_x
	local real temp_y
	local real temp
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set tuple_temp = angle_op_mult(Segment_angularVelocity_radians[this_1], delay)
	set a_radians = tuple_temp
	set tuple_temp_1 = vec2_toVec3(vec2_rotate(vec3_toVec2(Segment_p1_x[this_1], Segment_p1_y[this_1], Segment_p1_z[this_1]), vec3_toVec2_return_y, a_radians), vec2_rotate_return_y)
	set tuple_temp_2 = vec2_toVec3_return_y
	set tuple_temp_3 = vec2_toVec3_return_z
	set Segment_p1_x[this_1] = tuple_temp_1
	set Segment_p1_y[this_1] = tuple_temp_2
	set Segment_p1_z[this_1] = tuple_temp_3
	set tuple_temp_4 = vec2_toVec3(vec2_rotate(vec3_toVec2(Segment_p2_x[this_1], Segment_p2_y[this_1], Segment_p2_z[this_1]), vec3_toVec2_return_y, a_radians), vec2_rotate_return_y)
	set tuple_temp_5 = vec2_toVec3_return_y
	set tuple_temp_6 = vec2_toVec3_return_z
	set Segment_p2_x[this_1] = tuple_temp_4
	set Segment_p2_y[this_1] = tuple_temp_5
	set Segment_p2_z[this_1] = tuple_temp_6
	call lightning_move_839(Segment_light[this_1], false, vec3_op_plus(Segment_pos_x[this_1], Segment_pos_y[this_1], Segment_pos_z[this_1], Segment_p1_x[this_1], Segment_p1_y[this_1], Segment_p1_z[this_1]), vec3_op_plus_return_y, vec3_op_plus_return_z, vec3_op_plus(Segment_pos_x[this_1], Segment_pos_y[this_1], Segment_pos_z[this_1], Segment_p2_x[this_1], Segment_p2_y[this_1], Segment_p2_z[this_1]), vec3_op_plus_return_y, vec3_op_plus_return_z)
	set tuple_temp_7 = vec3_toVec2(Segment_pos_x[this_1], Segment_pos_y[this_1], Segment_pos_z[this_1])
	set tuple_temp_8 = vec3_toVec2_return_y
	set temp_x = tuple_temp_7
	set temp_y = tuple_temp_8
	set temp = Segment_width[this_1]
	set clVar = alloc_ForGroupCallback_forUnitsInRange_Segment_Segment("when calling alloc_ForGroupCallback_forUnitsInRange_Segment_Segment in Segment, line 43")
	set this_593[clVar] = this_1
	call forUnitsInRange(temp_x, temp_y, temp, true, clVar, "when calling forUnitsInRange in Segment, line 43")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_Segment_Segment_Segment_update takes integer this_1, real delay, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Segment_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Segment.update", "when calling error in Segment, line 38")
		else
			call error("Called Segment.update on invalid object.", "when calling error in Segment, line 38")
		endif
	endif
	call Segment_update(this_1, delay, "when calling update in Segment, line 38")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_getElapsed takes timer this_1 returns real
	return TimerGetElapsed(this_1)
endfunction

function Segment_updateAll takes string w__wurst_stackPos returns nothing
	local integer iterator
	local integer s
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set iterator = Segment_LinkedListModule_iterator("when calling iterator in Segment, line 35")
	loop
		exitwhen  not Iterator_hasNext(iterator)
		set s = Iterator_next(iterator)
		call dispatch_Segment_Segment_Segment_update(s, timer_getElapsed(Segment_clock), "when calling update in Segment, line 36")
	endloop
	call Iterator_close(iterator, "when calling close in Segment, line 35")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_Segment_updateAll takes nothing returns nothing
	set wurst_stack_depth = 0
	call Segment_updateAll("via function reference Segment, line 24")
endfunction

function currentCallbackD takes nothing returns integer
	return ClosureForGroups_tempCallbacksD[ClosureForGroups_tempCallbacksDCount - 1]
endfunction

function destructable_getX takes destructable this_1 returns real
	return GetDestructableX(this_1)
endfunction

function destructable_getY takes destructable this_1 returns real
	return GetDestructableY(this_1)
endfunction

function destructable_getPos takes destructable this_1 returns real
	set destructable_getPos_return_x = destructable_getX(this_1)
	set destructable_getPos_return_y = destructable_getY(this_1)
	return destructable_getPos_return_x
endfunction

function destructable_getTypeId takes destructable this_1 returns integer
	return GetDestructableTypeId(this_1)
endfunction

function destructable_remove takes destructable this_1 returns nothing
	call RemoveDestructable(this_1)
endfunction

function alloc_Segment takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Segment_firstFree == 0 then
		if Segment_maxIndex < 32768 then
			set Segment_maxIndex = Segment_maxIndex + 1
			set this_1 = Segment_maxIndex
			set Segment_typeId[this_1] = 760
		else
			call error("Out of memory: Could not create Segment.", "when calling error in Segment, line 13")
			set this_1 = 0
		endif
	else
		set Segment_firstFree = Segment_firstFree - 1
		set this_1 = Segment_nextFree[Segment_firstFree]
		set Segment_typeId[this_1] = 760
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function construct_Segment_LinkedListModule takes integer this_1 returns nothing
	set Segment_LinkedListModule_size = Segment_LinkedListModule_size + 1
	if Segment_LinkedListModule_size == 1 then
		set Segment_LinkedListModule_first = this_1
	else
		set Segment_LinkedListModule_next[Segment_LinkedListModule_last] = this_1
	endif
	set Segment_LinkedListModule_next[this_1] = 0
	set Segment_LinkedListModule_last = this_1
endfunction

function Segment_init takes integer this_1 returns nothing
	call construct_Segment_LinkedListModule(this_1)
endfunction

function addLightning_445 takes string codeName, boolean checkVisibility, real start_x, real start_y, real start_z, real w_end_x, real w_end_y, real w_end_z returns lightning
	return AddLightningEx(codeName, checkVisibility, start_x, start_y, start_z, w_end_x, w_end_y, w_end_z)
endfunction

function construct_Segment takes integer this_1, real pos_x, real pos_y, real pos_z, real width, real angularVelocity_radians_1 returns nothing
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	local real tuple_temp_9
	call Segment_init(this_1)
	set tuple_temp = pos_x
	set tuple_temp_1 = pos_y
	set tuple_temp_2 = pos_z
	set Segment_pos_x[this_1] = tuple_temp
	set Segment_pos_y[this_1] = tuple_temp_1
	set Segment_pos_z[this_1] = tuple_temp_2
	set tuple_temp_3 = width / 2.
	set tuple_temp_4 = 0.
	set tuple_temp_5 = 0.
	set Segment_p1_x[this_1] = tuple_temp_3
	set Segment_p1_y[this_1] = tuple_temp_4
	set Segment_p1_z[this_1] = tuple_temp_5
	set tuple_temp_6 =  - (width / 2.)
	set tuple_temp_7 = 0.
	set tuple_temp_8 = 0.
	set Segment_p2_x[this_1] = tuple_temp_6
	set Segment_p2_y[this_1] = tuple_temp_7
	set Segment_p2_z[this_1] = tuple_temp_8
	set Segment_width[this_1] = width
	set Segment_light[this_1] = addLightning_445(Segment_lightType, false, vec3_op_plus(pos_x, pos_y, pos_z, Segment_p1_x[this_1], Segment_p1_y[this_1], Segment_p1_z[this_1]), vec3_op_plus_return_y, vec3_op_plus_return_z, vec3_op_plus(pos_x, pos_y, pos_z, Segment_p2_x[this_1], Segment_p2_y[this_1], Segment_p2_z[this_1]), vec3_op_plus_return_y, vec3_op_plus_return_z)
	set tuple_temp_9 = angularVelocity_radians_1
	set Segment_angularVelocity_radians[this_1] = tuple_temp_9
endfunction

function new_Segment takes real pos_x, real pos_y, real pos_z, real width, real angularVelocity_radians_1, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Segment("when calling alloc_Segment in Segment, line 26")
	call construct_Segment(this_1, pos_x, pos_y, pos_z, width, angularVelocity_radians_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function vec2_getTerrainZ takes real this_x, real this_y returns real
	call MoveLocation(Vectors_tempLoc, this_x, this_y)
	return GetLocationZ(Vectors_tempLoc)
endfunction

function vec2_withTerrainZ takes real this_x, real this_y returns real
	set vec2_withTerrainZ_return_x = this_x
	set vec2_withTerrainZ_return_y = this_y
	set vec2_withTerrainZ_return_z = vec2_getTerrainZ(this_x, this_y)
	return vec2_withTerrainZ_return_x
endfunction

function callback_forDestructablesInRect_Segment takes integer this_1, destructable d, string w__wurst_stackPos returns nothing
	local real tuple_temp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if destructable_getTypeId(d) == 1280598642 then
		set tuple_temp = angle_op_mult(angularVelocity_radians[this_1], -1)
		set angularVelocity_radians[this_1] = tuple_temp
		call new_Segment(vec2_withTerrainZ(destructable_getPos(d), destructable_getPos_return_y), vec2_withTerrainZ_return_y, vec2_withTerrainZ_return_z, 400., angularVelocity_radians[this_1], "when calling new_Segment in Segment, line 61")
		call destructable_remove(d)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_ForGroupCallbackD_ClosureForGroups_ForGroupCallbackD_callback takes integer this_1, destructable d, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallbackD_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling ForGroupCallbackD.callback", "when calling error in ClosureForGroups, line 149")
		else
			call error("Called ForGroupCallbackD.callback on invalid object.", "when calling error in ClosureForGroups, line 149")
		endif
	endif
	call callback_forDestructablesInRect_Segment(this_1, d, "when calling callback_forDestructablesInRect_Segment in ClosureForGroups, line 149")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function filterD takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_ForGroupCallbackD_ClosureForGroups_ForGroupCallbackD_callback(currentCallbackD(), GetEnumDestructable(), "when calling callback in ClosureForGroups, line 152")
	set wurst_stack_depth = wurst_stack_depth - 1
	return false
endfunction

function code__EnumDestructablesInRect_ClosureForGroups takes string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = filterD("when calling filterD in ClosureForGroups, line 190")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function bridge_code__EnumDestructablesInRect_ClosureForGroups takes nothing returns boolean
	set wurst_stack_depth = 0
	return code__EnumDestructablesInRect_ClosureForGroups("via function reference ClosureForGroups, line 190")
endfunction

function currentCallback takes nothing returns integer
	return ClosureForGroups_tempCallbacks[ClosureForGroups_tempCallbacksCount - 1]
endfunction

function filterCallback takes unit filter, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ClosureForGroups_iterCount < ClosureForGroups_maxCount then
		call dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback(currentCallback(), filter, "when calling callback in ClosureForGroups, line 18")
	endif
	set ClosureForGroups_iterCount = ClosureForGroups_iterCount + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function code__Filter_ClosureForGroups takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call filterCallback(GetFilterUnit(), "when calling filterCallback in ClosureForGroups, line 14")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__Filter_ClosureForGroups takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__Filter_ClosureForGroups("via function reference ClosureForGroups, line 14")
endfunction

function code__addAction_nullTimer_ClosureEvents takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call EventListener_generalEventCallback("when calling generalEventCallback in ClosureEvents, line 295")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__addAction_nullTimer_ClosureEvents takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__addAction_nullTimer_ClosureEvents("via function reference ClosureEvents, line 295")
endfunction

function code__addAction_nullTimer_ClosureEvents_552 takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call EventListener_generalEventCallback("when calling generalEventCallback in ClosureEvents, line 296")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__addAction_nullTimer_ClosureEvents_501 takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__addAction_nullTimer_ClosureEvents_552("via function reference ClosureEvents, line 296")
endfunction

function code__addAction_nullTimer_ClosureEvents_553 takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call EventListener_generalEventCallback("when calling generalEventCallback in ClosureEvents, line 297")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__addAction_nullTimer_ClosureEvents_502 takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__addAction_nullTimer_ClosureEvents_553("via function reference ClosureEvents, line 297")
endfunction

function getEnterLeaveUnit takes nothing returns unit
	return OnUnitEnterLeave_tempUnits[OnUnitEnterLeave_tempUnitsCount - 1]
endfunction

function shouldIndex takes unit w_u returns boolean
	return true
endfunction

function alloc_UnitIndex takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if UnitIndex_firstFree == 0 then
		if UnitIndex_maxIndex < 32768 then
			set UnitIndex_maxIndex = UnitIndex_maxIndex + 1
			set this_1 = UnitIndex_maxIndex
			set UnitIndex_typeId[this_1] = 787
		else
			call error("Out of memory: Could not create UnitIndex.", "when calling error in UnitIndexer, line 172")
			set this_1 = 0
		endif
	else
		set UnitIndex_firstFree = UnitIndex_firstFree - 1
		set this_1 = UnitIndex_nextFree[UnitIndex_firstFree]
		set UnitIndex_typeId[this_1] = 787
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function UnitIndex_init takes integer this_1 returns nothing
endfunction

function popUnit_880 takes nothing returns nothing
	set UnitIndexer_tempUnitsCount = UnitIndexer_tempUnitsCount - 1
endfunction

function pushUnit_887 takes unit u returns nothing
	set UnitIndexer_tempUnits[UnitIndexer_tempUnitsCount] = u
	set UnitIndexer_tempUnitsCount = UnitIndexer_tempUnitsCount + 1
endfunction

function trigger_evaluate takes trigger this_1 returns boolean
	return TriggerEvaluate(this_1)
endfunction

function unit_setUserData takes unit this_1, integer data returns nothing
	call SetUnitUserData(this_1, data)
endfunction

function construct_UnitIndex takes integer this_1, unit whichUnit returns nothing
	call UnitIndex_init(this_1)
	set UnitIndex__unit[this_1] = whichUnit
	call unit_setUserData(UnitIndex__unit[this_1], this_1)
	call pushUnit_887(whichUnit)
	call trigger_evaluate(UnitIndexer_onIndexTrigger)
	call popUnit_880()
endfunction

function new_UnitIndex takes unit whichUnit, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_UnitIndex("when calling alloc_UnitIndex in UnitIndexer, line 181")
	call construct_UnitIndex(this_1, whichUnit)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function unit_toUnitIndex takes unit this_1, string w__wurst_stackPos returns integer
	local integer instance
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set instance = unit_getUserData(this_1)
	if instance == 0 then
		set instance = new_UnitIndex(this_1, "when calling new_UnitIndex in UnitIndexer, line 135")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return instance
endfunction

function code__onEnter_UnitIndexer takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if shouldIndex(getEnterLeaveUnit()) then
		call unit_toUnitIndex(getEnterLeaveUnit(), "when calling toUnitIndex in UnitIndexer, line 196")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__onEnter_UnitIndexer takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__onEnter_UnitIndexer("via function reference UnitIndexer, line 196")
endfunction

function UnitIndex_onDestroy takes integer this_1 returns nothing
	call pushUnit_887(UnitIndex__unit[this_1])
	call trigger_evaluate(UnitIndexer_onDeindexTrigger)
	call popUnit_880()
	call unit_setUserData(UnitIndex__unit[this_1], 0)
endfunction

function dealloc_UnitIndex takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if UnitIndex_typeId[obj] == 0 then
		call error("Double free: object of type UnitIndex", "when calling error in UnitIndexer, line 172")
	else
		set UnitIndex_nextFree[UnitIndex_firstFree] = obj
		set UnitIndex_firstFree = UnitIndex_firstFree + 1
		set UnitIndex_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyUnitIndex takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call UnitIndex_onDestroy(this_1)
	call dealloc_UnitIndex(this_1, "when calling dealloc_UnitIndex in UnitIndexer, line 188")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_UnitIndex_destroyUnitIndex takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if UnitIndex_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitIndex.UnitIndex", "when calling error in UnitIndexer, line 172")
		else
			call error("Called UnitIndex.UnitIndex on invalid object.", "when calling error in UnitIndexer, line 172")
		endif
	endif
	call destroyUnitIndex(this_1, "when calling destroyUnitIndex in UnitIndexer, line 172")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function unit_deindex takes unit this_1, string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if unit_getUserData(this_1) == 0 then
		set wurst_stack_depth = wurst_stack_depth - 1
		return false
	else
		call dispatch_UnitIndex_destroyUnitIndex(unit_toUnitIndex(this_1, "when calling toUnitIndex in UnitIndexer, line 169"), "when calling dispatch_UnitIndex_destroyUnitIndex in UnitIndexer, line 169")
		set wurst_stack_depth = wurst_stack_depth - 1
		return true
	endif
endfunction

function code__onLeave_UnitIndexer takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if shouldIndex(getEnterLeaveUnit()) then
		call unit_deindex(getEnterLeaveUnit(), "when calling deindex in UnitIndexer, line 197")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__onLeave_UnitIndexer takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__onLeave_UnitIndexer("via function reference UnitIndexer, line 197")
endfunction

function getIndexingUnit takes nothing returns unit
	return UnitIndexer_tempUnits[UnitIndexer_tempUnitsCount - 1]
endfunction

function HashMap_get takes integer this_1, integer key, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_Table_Table_Table_loadInt(this_1, key, "when calling loadInt in HashMap, line 24")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_HashMap_HashMap_HashMap_get takes integer this_1, integer key, string w__wurst_stackPos returns integer
	local integer HashMap_HashMap_get_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashMap.get", "when calling error in HashMap, line 23")
		else
			call error("Called HashMap.get on invalid object.", "when calling error in HashMap, line 23")
		endif
	endif
	set HashMap_HashMap_get_result = HashMap_get(this_1, key, "when calling get in HashMap, line 23")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashMap_HashMap_get_result
endfunction

function Table_hasInt takes integer this_1, integer parentKey returns boolean
	return hashtable_hasInt(Table_ht, this_1, parentKey)
endfunction

function dispatch_Table_Table_Table_hasInt takes integer this_1, integer parentKey, string w__wurst_stackPos returns boolean
	local boolean Table_Table_hasInt_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.hasInt", "when calling error in Table, line 10")
		else
			call error("Called Table.hasInt on invalid object.", "when calling error in Table, line 10")
		endif
	endif
	set Table_Table_hasInt_result = Table_hasInt(this_1, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_hasInt_result
endfunction

function HashMap_has takes integer this_1, integer key, string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_Table_Table_Table_hasInt(this_1, key, "when calling hasInt in HashMap, line 14")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_HashMap_HashMap_HashMap_has takes integer this_1, integer key, string w__wurst_stackPos returns boolean
	local boolean HashMap_HashMap_has_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashMap.has", "when calling error in HashMap, line 13")
		else
			call error("Called HashMap.has on invalid object.", "when calling error in HashMap, line 13")
		endif
	endif
	set HashMap_HashMap_has_result = HashMap_has(this_1, key, "when calling has in HashMap, line 13")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashMap_HashMap_has_result
endfunction

function Table_removeInt takes integer this_1, integer parentKey returns nothing
	call RemoveSavedInteger(Table_ht, this_1, parentKey)
endfunction

function dispatch_Table_Table_Table_removeInt takes integer this_1, integer parentKey, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.removeInt", "when calling error in Table, line 25")
		else
			call error("Called Table.removeInt on invalid object.", "when calling error in Table, line 25")
		endif
	endif
	call Table_removeInt(this_1, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashMap_remove takes integer this_1, integer key, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if dispatch_HashMap_HashMap_HashMap_has(this_1, key, "when calling has in HashMap, line 28") then
		set HashMap_size[this_1] = HashMap_size[this_1] - 1
	endif
	call dispatch_Table_Table_Table_removeInt(this_1, key, "when calling removeInt in HashMap, line 30")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_count takes integer this_1, integer elem returns integer
	return hashtable_loadInt(HashList_occurences, this_1, elem)
endfunction

function dispatch_HashList_HashList_HashList_count takes integer this_1, integer elem, string w__wurst_stackPos returns integer
	local integer HashList_HashList_count_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.count", "when calling error in HashList, line 28")
		else
			call error("Called HashList.count on invalid object.", "when calling error in HashList, line 28")
		endif
	endif
	set HashList_HashList_count_result = HashList_count(this_1, elem)
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashList_HashList_count_result
endfunction

function HashList_decrOccurences takes integer this_1, integer elem, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call hashtable_saveInt(HashList_occurences, this_1, elem, dispatch_HashList_HashList_HashList_count(this_1, elem, "when calling count in HashList, line 38") - 1)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashList_HashList_HashList_decrOccurences takes integer this_1, integer elem, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.decrOccurences", "when calling error in HashList, line 37")
		else
			call error("Called HashList.decrOccurences on invalid object.", "when calling error in HashList, line 37")
		endif
	endif
	call HashList_decrOccurences(this_1, elem, "when calling decrOccurences in HashList, line 37")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_removeAt takes integer this_1, integer index, string w__wurst_stackPos returns integer
	local integer tmp
	local integer i
	local integer temp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_HashList_HashList_HashList_decrOccurences(this_1, hashtable_loadInt(HashList_ht, this_1, index), "when calling decrOccurences in HashList, line 77")
	set tmp = hashtable_loadInt(HashList_ht, this_1, index)
	set i = index
	set temp = HashList_size[this_1]
	loop
		exitwhen i > temp
		call hashtable_saveInt(HashList_ht, this_1, i, hashtable_loadInt(HashList_ht, this_1, i + 1))
		set i = i + 1
	endloop
	set HashList_size[this_1] = HashList_size[this_1] - 1
	set wurst_stack_depth = wurst_stack_depth - 1
	return tmp
endfunction

function dispatch_HashList_HashList_HashList_removeAt takes integer this_1, integer index, string w__wurst_stackPos returns integer
	local integer HashList_HashList_removeAt_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.removeAt", "when calling error in HashList, line 76")
		else
			call error("Called HashList.removeAt on invalid object.", "when calling error in HashList, line 76")
		endif
	endif
	set HashList_HashList_removeAt_result = HashList_removeAt(this_1, index, "when calling removeAt in HashList, line 76")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashList_HashList_removeAt_result
endfunction

function HashList_remove takes integer this_1, integer t, string w__wurst_stackPos returns boolean
	local boolean result_1
	local integer i
	local integer temp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set result_1 = false
	set i = 0
	set temp = HashList_size[this_1] - 1
	loop
		exitwhen i > temp
		if t == hashtable_loadInt(HashList_ht, this_1, i) then
			set result_1 = true
			call dispatch_HashList_HashList_HashList_removeAt(this_1, i, "when calling removeAt in HashList, line 91")
			exitwhen true
		endif
		set i = i + 1
	endloop
	set wurst_stack_depth = wurst_stack_depth - 1
	return result_1
endfunction

function dispatch_HashList_HashList_HashList_remove takes integer this_1, integer t, string w__wurst_stackPos returns boolean
	local boolean HashList_HashList_remove_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.remove", "when calling error in HashList, line 86")
		else
			call error("Called HashList.remove on invalid object.", "when calling error in HashList, line 86")
		endif
	endif
	set HashList_HashList_remove_result = HashList_remove(this_1, t, "when calling remove in HashList, line 86")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashList_HashList_remove_result
endfunction

function HashList_has takes integer this_1, integer elem, string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_HashList_HashList_HashList_count(this_1, elem, "when calling count in HashList, line 109") > 0
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_HashList_HashList_HashList_has takes integer this_1, integer elem, string w__wurst_stackPos returns boolean
	local boolean HashList_HashList_has_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.has", "when calling error in HashList, line 108")
		else
			call error("Called HashList.has on invalid object.", "when calling error in HashList, line 108")
		endif
	endif
	set HashList_HashList_has_result = HashList_has(this_1, elem, "when calling has in HashList, line 108")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashList_HashList_has_result
endfunction

function IterableMap_hasKey takes integer this_1, integer key, string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_HashList_HashList_HashList_has(IterableMap_keys[this_1], key, "when calling has in HashMap, line 88")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_IterableMap_HashMap_IterableMap_hasKey takes integer this_1, integer key, string w__wurst_stackPos returns boolean
	local boolean HashMap_IterableMap_hasKey_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling IterableMap.hasKey", "when calling error in HashMap, line 87")
		else
			call error("Called IterableMap.hasKey on invalid object.", "when calling error in HashMap, line 87")
		endif
	endif
	set HashMap_IterableMap_hasKey_result = IterableMap_hasKey(this_1, key, "when calling hasKey in HashMap, line 87")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashMap_IterableMap_hasKey_result
endfunction

function IterableMap_remove takes integer this_1, integer key, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call HashMap_remove(this_1, key, "when calling remove in HashMap, line 66")
	if dispatch_IterableMap_HashMap_IterableMap_hasKey(this_1, key, "when calling hasKey in HashMap, line 67") then
		call dispatch_HashList_HashList_HashList_remove(IterableMap_keys[this_1], key, "when calling remove in HashMap, line 68")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashMap_HashMap_HashMap_remove takes integer this_1, integer key, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashMap.remove", "when calling error in HashMap, line 27")
		else
			call error("Called HashMap.remove on invalid object.", "when calling error in HashMap, line 27")
		endif
	endif
	if Table_typeId[this_1] <= 778 then
		call HashMap_remove(this_1, key, "when calling remove in HashMap, line 27")
	else
		call IterableMap_remove(this_1, key, "when calling remove in HashMap, line 27")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashMap_put takes integer this_1, integer key, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if  not dispatch_HashMap_HashMap_HashMap_has(this_1, key, "when calling has in HashMap, line 18") then
		set HashMap_size[this_1] = HashMap_size[this_1] + 1
	endif
	call dispatch_Table_Table_Table_saveInt(this_1, key, value, "when calling saveInt in HashMap, line 20")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_incrOccurences takes integer this_1, integer elem, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call hashtable_saveInt(HashList_occurences, this_1, elem, dispatch_HashList_HashList_HashList_count(this_1, elem, "when calling count in HashList, line 35") + 1)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashList_HashList_HashList_incrOccurences takes integer this_1, integer elem, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.incrOccurences", "when calling error in HashList, line 34")
		else
			call error("Called HashList.incrOccurences on invalid object.", "when calling error in HashList, line 34")
		endif
	endif
	call HashList_incrOccurences(this_1, elem, "when calling incrOccurences in HashList, line 34")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_add_1 takes integer this_1, integer elems_0, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call hashtable_saveInt(HashList_ht, this_1, HashList_size[this_1], elems_0)
	call dispatch_HashList_HashList_HashList_incrOccurences(this_1, elems_0, "when calling incrOccurences in HashList, line 44")
	set HashList_size[this_1] = HashList_size[this_1] + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashList_HashList_HashList_add_1 takes integer this_1, integer elems_0, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashList.add", "when calling error in HashList, line 41")
		else
			call error("Called HashList.add on invalid object.", "when calling error in HashList, line 41")
		endif
	endif
	call HashList_add_1(this_1, elems_0, "when calling add in HashList, line 41")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function IterableMap_put takes integer this_1, integer key, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call HashMap_put(this_1, key, value, "when calling put in HashMap, line 60")
	if  not dispatch_IterableMap_HashMap_IterableMap_hasKey(this_1, key, "when calling hasKey in HashMap, line 61") then
		call dispatch_HashList_HashList_HashList_add_1(IterableMap_keys[this_1], key, "when calling add in HashMap, line 62")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashMap_HashMap_HashMap_put takes integer this_1, integer key, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HashMap.put", "when calling error in HashMap, line 17")
		else
			call error("Called HashMap.put on invalid object.", "when calling error in HashMap, line 17")
		endif
	endif
	if Table_typeId[this_1] <= 778 then
		call HashMap_put(this_1, key, value, "when calling put in HashMap, line 17")
	else
		call IterableMap_put(this_1, key, value, "when calling put in HashMap, line 17")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function OnCastListener_onDestroy takes integer this_1, string w__wurst_stackPos returns nothing
	local integer listener
	local integer listener_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if OnCastListener_eventUnit[this_1] != null then
		set listener = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMapCasters, unitToIndex(OnCastListener_eventUnit[this_1]), "when calling get in ClosureEvents, line 60")
		if listener == this_1 then
			call dispatch_HashMap_HashMap_HashMap_put(EventListener_castMapCasters, unitToIndex(OnCastListener_eventUnit[this_1]), OnCastListener_next[this_1], "when calling put in ClosureEvents, line 62")
		elseif OnCastListener_prev[this_1] != 0 then
			set OnCastListener_next[OnCastListener_prev[this_1]] = OnCastListener_next[this_1]
		endif
	else
		set listener_1 = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMap, OnCastListener_abilId[this_1], "when calling get in ClosureEvents, line 66")
		if listener_1 == this_1 then
			call dispatch_HashMap_HashMap_HashMap_put(EventListener_castMap, OnCastListener_abilId[this_1], OnCastListener_next[this_1], "when calling put in ClosureEvents, line 68")
		elseif OnCastListener_prev[this_1] != 0 then
			set OnCastListener_next[OnCastListener_prev[this_1]] = OnCastListener_next[this_1]
		endif
	endif
	set OnCastListener_prev[OnCastListener_next[this_1]] = OnCastListener_prev[this_1]
	set OnCastListener_next[this_1] = 0
	set OnCastListener_prev[this_1] = 0
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_OnCastListener takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if OnCastListener_typeId[obj] == 0 then
		call error("Double free: object of type OnCastListener", "when calling error in ClosureEvents, line 50")
	else
		set OnCastListener_nextFree[OnCastListener_firstFree] = obj
		set OnCastListener_firstFree = OnCastListener_firstFree + 1
		set OnCastListener_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyOnCastListener takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call OnCastListener_onDestroy(this_1, "when calling OnCastListener_onDestroy in ClosureEvents, line 58")
	call dealloc_OnCastListener(this_1, "when calling dealloc_OnCastListener in ClosureEvents, line 58")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_OnCastListener_destroyOnCastListener takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if OnCastListener_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling OnCastListener.OnCastListener", "when calling error in ClosureEvents, line 50")
		else
			call error("Called OnCastListener.OnCastListener on invalid object.", "when calling error in ClosureEvents, line 50")
		endif
	endif
	call destroyOnCastListener(this_1, "when calling destroyOnCastListener in ClosureEvents, line 50")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Log_trace takes string msg returns nothing
	call printLog(Player_localPlayer, 0, msg)
endfunction

function EventListener_onDestroy takes integer this_1 returns nothing
	local integer listener
	local integer listener_1
	if EventListener_uid[this_1] < 0 then
		set listener = EventListener_generalListenersFirsts[EventListener_eventId[this_1]]
		if listener == this_1 then
			set EventListener_generalListenersFirsts[EventListener_eventId[this_1]] = EventListener_next[this_1]
		elseif EventListener_prev[this_1] != 0 then
			set EventListener_next[EventListener_prev[this_1]] = EventListener_next[this_1]
		endif
	else
		set listener_1 = EventListener_unitListenersFirsts[EventListener_uid[this_1]]
		if listener_1 == this_1 then
			set EventListener_unitListenersFirsts[EventListener_uid[this_1]] = EventListener_next[this_1]
		elseif EventListener_prev[this_1] != 0 then
			set EventListener_next[EventListener_prev[this_1]] = EventListener_next[this_1]
		endif
	endif
	if EventListener_next[this_1] != 0 then
		set EventListener_prev[EventListener_next[this_1]] = EventListener_prev[this_1]
	endif
	set EventListener_next[this_1] = 0
	set EventListener_prev[this_1] = 0
endfunction

function dealloc_EventListener takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_typeId[obj] == 0 then
		call error("Double free: object of type EventListener", "when calling error in ClosureEvents, line 98")
	else
		set EventListener_nextFree[EventListener_firstFree] = obj
		set EventListener_firstFree = EventListener_firstFree + 1
		set EventListener_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyEventListener takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call EventListener_onDestroy(this_1)
	call dealloc_EventListener(this_1, "when calling dealloc_EventListener in ClosureEvents, line 208")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_EventListener_destroyEventListener takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling EventListener.EventListener", "when calling error in ClosureEvents, line 98")
		else
			call error("Called EventListener.EventListener on invalid object.", "when calling error in ClosureEvents, line 98")
		endif
	endif
	call destroyEventListener(this_1, "when calling destroyEventListener in ClosureEvents, line 98")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function unregisterEvents takes integer id_1, string w__wurst_stackPos returns nothing
	local integer listener
	local integer t
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if id_1 > 0 then
		if EventListener_unitListenersFirsts[id_1] != 0 then
			call Log_trace("unregister unit has listeners. startid: " + int_toString(id_1))
			set listener = EventListener_unitListenersFirsts[id_1]
			set EventListener_unitListenersFirsts[id_1] = 0
			loop
				exitwhen  not (listener != 0)
				set t = listener
				set listener = EventListener_next[listener]
				call dispatch_EventListener_destroyEventListener(t, "when calling dispatch_EventListener_destroyEventListener in ClosureEvents, line 286")
			endloop
		endif
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function unregisterEventsForUnit takes unit u, string w__wurst_stackPos returns nothing
	local integer listener
	local integer t
	local integer listener_1
	local integer t_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if fireEvents(u) then
		call unregisterEvents(unit_getIndex(u), "when calling unregisterEvents in ClosureEvents, line 262")
		if dispatch_HashMap_HashMap_HashMap_has(EventListener_castMapCasters, unitToIndex(u), "when calling has in ClosureEvents, line 263") then
			set listener = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMapCasters, unitToIndex(u), "when calling get in ClosureEvents, line 264")
			call dispatch_HashMap_HashMap_HashMap_remove(EventListener_castMapCasters, unitToIndex(u), "when calling remove in ClosureEvents, line 265")
			loop
				exitwhen  not (listener != 0)
				set t = listener
				set listener = OnCastListener_next[listener]
				call dispatch_OnCastListener_destroyOnCastListener(t, "when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 269")
			endloop
		endif
		if dispatch_HashMap_HashMap_HashMap_has(EventListener_castMapCasters, unitToIndex(u), "when calling has in ClosureEvents, line 270") then
			set listener_1 = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMapCasters, unitToIndex(u), "when calling get in ClosureEvents, line 271")
			loop
				exitwhen  not (listener_1 != 0)
				set t_1 = listener_1
				set listener_1 = OnCastListener_next[listener_1]
				call dispatch_OnCastListener_destroyOnCastListener(t_1, "when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 275")
			endloop
		endif
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function code__onUnitDeindex_ClosureEvents takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call unregisterEventsForUnit(getIndexingUnit(), "when calling unregisterEventsForUnit in ClosureEvents, line 292")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__onUnitDeindex_ClosureEvents takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__onUnitDeindex_ClosureEvents("via function reference ClosureEvents, line 292")
endfunction

function hashtable_loadTriggerHandle takes hashtable this_1, integer parentKey, integer childKey returns trigger
	return LoadTriggerHandle(this_1, parentKey, childKey)
endfunction

function Table_loadTrigger takes integer this_1, integer parentKey returns trigger
	return hashtable_loadTriggerHandle(Table_ht, this_1, parentKey)
endfunction

function dispatch_Table_Table_Table_loadTrigger takes integer this_1, integer parentKey, string w__wurst_stackPos returns trigger
	local trigger Table_Table_loadTrigger_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.loadTrigger", "when calling error in Table, line 112")
		else
			call error("Called Table.loadTrigger on invalid object.", "when calling error in Table, line 112")
		endif
	endif
	set Table_Table_loadTrigger_result = Table_loadTrigger(this_1, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	set dispatch_Table_Table_Table_loadTriggertempReturn = Table_Table_loadTrigger_result
	set Table_Table_loadTrigger_result = null
	return dispatch_Table_Table_Table_loadTriggertempReturn
endfunction

function hashtable_saveFogStateHandle takes hashtable this_1, integer parentKey, integer childKey, fogstate value returns nothing
	call SaveFogStateHandle(this_1, parentKey, childKey, value)
endfunction

function Table_saveFogState takes integer this_1, integer parentKey, fogstate value returns nothing
	call hashtable_saveFogStateHandle(Table_ht, this_1, parentKey, value)
endfunction

function dispatch_Table_Table_Table_saveFogState takes integer this_1, integer parentKey, fogstate value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.saveFogState", "when calling error in Table, line 169")
		else
			call error("Called Table.saveFogState on invalid object.", "when calling error in Table, line 169")
		endif
	endif
	call Table_saveFogState(this_1, parentKey, value)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function triggerFromIndex takes integer index, string w__wurst_stackPos returns trigger
	local trigger stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_Table_Table_Table_saveFogState(TypeCasting_typecastdata, 0, ConvertFogState(index), "when calling saveFogState in TypeCasting, line 95")
	set stackTrace_tempReturn = dispatch_Table_Table_Table_loadTrigger(TypeCasting_typecastdata, 0, "when calling loadTrigger in TypeCasting, line 96")
	set wurst_stack_depth = wurst_stack_depth - 1
	set triggerFromIndextempReturn = stackTrace_tempReturn
	set stackTrace_tempReturn = null
	return triggerFromIndextempReturn
endfunction

function code__registerPlayerUnitEvent_RegisterEvents takes string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = trigger_evaluate(triggerFromIndex(dispatch_HashMap_HashMap_HashMap_get(RegisterEvents_onCastMap, GetSpellAbilityId(), "when calling get in RegisterEvents, line 58"), "when calling triggerFromIndex in RegisterEvents, line 58"))
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function bridge_code__registerPlayerUnitEvent_RegisterEvents takes nothing returns boolean
	set wurst_stack_depth = 0
	return code__registerPlayerUnitEvent_RegisterEvents("via function reference RegisterEvents, line 58")
endfunction

function dispatch_OnCast_ClosureEvents_OnCast_fireEx takes integer this_1, integer id_1 returns nothing
endfunction

function OnCast_fire takes integer this_1, unit caster_1 returns nothing
	call dispatch_OnCast_ClosureEvents_OnCast_fireEx(this_1, GetSpellAbilityId())
endfunction

function EventData_getAbilityTargetPos takes nothing returns real
	set EventData_getAbilityTargetPos_return_x = GetSpellTargetX()
	set EventData_getAbilityTargetPos_return_y = GetSpellTargetY()
	return EventData_getAbilityTargetPos_return_x
endfunction

function EventData_getSpellTargetPos takes nothing returns real
	set EventData_getSpellTargetPos_return_x = EventData_getAbilityTargetPos()
	set EventData_getSpellTargetPos_return_y = EventData_getAbilityTargetPos_return_y
	return EventData_getSpellTargetPos_return_x
endfunction

function dispatch_OnPointCast_ClosureEvents_OnPointCast_fireEx takes integer this_1, unit caster_1, real target_x, real target_y returns nothing
endfunction

function OnPointCast_fire takes integer this_1, unit caster_1 returns nothing
	call dispatch_OnPointCast_ClosureEvents_OnPointCast_fireEx(this_1, caster_1, EventData_getSpellTargetPos(), EventData_getSpellTargetPos_return_y)
endfunction

function dispatch_OnUnitCast_ClosureEvents_OnUnitCast_fireEx takes integer this_1, unit caster_1, unit target returns nothing
endfunction

function OnUnitCast_fire takes integer this_1, unit caster_1 returns nothing
	call dispatch_OnUnitCast_ClosureEvents_OnUnitCast_fireEx(this_1, caster_1, GetSpellTargetUnit())
endfunction

function EventListener_add takes eventid eventId, integer listener, string w__wurst_stackPos returns integer
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set EventListener_eventId[listener] = eventid_toIntId(eventId, "when calling toIntId in ClosureEvents, line 113")
	if EventListener_generalListenersFirsts[EventListener_eventId[listener]] != 0 then
		set EventListener_prev[EventListener_generalListenersFirsts[EventListener_eventId[listener]]] = listener
		set EventListener_next[listener] = EventListener_generalListenersFirsts[EventListener_eventId[listener]]
	endif
	set EventListener_generalListenersFirsts[EventListener_eventId[listener]] = listener
	set wurst_stack_depth = wurst_stack_depth - 1
	return listener
endfunction

function alloc_CallbackSingle_doAfter_onCast_ShieldGenerator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this_1 = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this_1] = 654
		else
			call error("Out of memory: Could not create CallbackSingle_doAfter_onCast_ShieldGenerator.", "when calling error in ShieldGenerator, line 152")
			set this_1 = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this_1 = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this_1] = 654
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_EventListener_add_onCast_ShieldGenerator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_firstFree == 0 then
		if EventListener_maxIndex < 32768 then
			set EventListener_maxIndex = EventListener_maxIndex + 1
			set this_1 = EventListener_maxIndex
			set EventListener_typeId[this_1] = 668
		else
			call error("Out of memory: Could not create EventListener_add_onCast_ShieldGenerator.", "when calling error in ShieldGenerator, line 166")
			set this_1 = 0
		endif
	else
		set EventListener_firstFree = EventListener_firstFree - 1
		set this_1 = EventListener_nextFree[EventListener_firstFree]
		set EventListener_typeId[this_1] = 668
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function EventListener_init takes integer this_1 returns nothing
	set EventListener_eventId[this_1] = 0
	set EventListener_uid[this_1] = -1
	set EventListener_next[this_1] = 0
	set EventListener_prev[this_1] = 0
endfunction

function construct_EventListener takes integer this_1 returns nothing
	call EventListener_init(this_1)
endfunction

function doAfter takes real timeToWait, integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = timer_doAfter(getTimer("when calling getTimer in ClosureTimers, line 27"), timeToWait, cb, "when calling doAfter in ClosureTimers, line 27")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function alloc_Shield takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Shield_firstFree == 0 then
		if Shield_maxIndex < 32768 then
			set Shield_maxIndex = Shield_maxIndex + 1
			set this_1 = Shield_maxIndex
			set Shield_typeId[this_1] = 761
		else
			call error("Out of memory: Could not create Shield.", "when calling error in ShieldGenerator, line 30")
			set this_1 = 0
		endif
	else
		set Shield_firstFree = Shield_firstFree - 1
		set this_1 = Shield_nextFree[Shield_firstFree]
		set Shield_typeId[this_1] = 761
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function construct_Shield_LinkedListModule takes integer this_1 returns nothing
	set Shield_LinkedListModule_size = Shield_LinkedListModule_size + 1
	if Shield_LinkedListModule_size == 1 then
		set Shield_LinkedListModule_first = this_1
		set Shield_LinkedListModule_prev[this_1] = 0
	else
		set Shield_LinkedListModule_prev[this_1] = Shield_LinkedListModule_last
		set Shield_LinkedListModule_next[Shield_LinkedListModule_last] = this_1
		set Shield_LinkedListModule_prev[Shield_LinkedListModule_first] = this_1
	endif
	set Shield_LinkedListModule_next[this_1] = 0
	set Shield_LinkedListModule_last = this_1
endfunction

function Shield_init takes integer this_1 returns nothing
	call construct_Shield_LinkedListModule(this_1)
endfunction

function construct_Shield takes integer this_1, unit caster_1, real p1_x, real p1_y, real p1_z, real p2_x, real p2_y, real p2_z, real p3_x, real p3_y, real p3_z, real p4_x, real p4_y, real p4_z returns nothing
	call Shield_init(this_1)
	set Shield_l1[this_1] = addLightning_445(Lightning_LIGHTNING_DRAIN, false, p1_x, p1_y, p1_z, p2_x, p2_y, p2_z)
	set Shield_l2[this_1] = addLightning_445(Lightning_LIGHTNING_DRAIN, false, p2_x, p2_y, p2_z, p3_x, p3_y, p3_z)
	set Shield_l3[this_1] = addLightning_445(Lightning_LIGHTNING_DRAIN, false, p3_x, p3_y, p3_z, p4_x, p4_y, p4_z)
	set Shield_l4[this_1] = addLightning_445(Lightning_LIGHTNING_DRAIN, false, p4_x, p4_y, p4_z, p1_x, p1_y, p1_z)
endfunction

function new_Shield takes unit caster_1, real p1_x, real p1_y, real p1_z, real p2_x, real p2_y, real p2_z, real p3_x, real p3_y, real p3_z, real p4_x, real p4_y, real p4_z, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Shield("when calling alloc_Shield in ShieldGenerator, line 42")
	call construct_Shield(this_1, caster_1, p1_x, p1_y, p1_z, p2_x, p2_y, p2_z, p3_x, p3_y, p3_z, p4_x, p4_y, p4_z)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function unit_disableAbility takes unit this_1, integer abilId, boolean flag, boolean hideUI returns nothing
	call BlzUnitDisableAbility(this_1, abilId, flag, hideUI)
endfunction

function unit_getAbilityCooldown takes unit this_1, integer abilId, integer level returns real
	return BlzGetUnitAbilityCooldown(this_1, abilId, level)
endfunction

function real_asAngleDegrees takes real this_1 returns real
	set real_asAngleDegrees_return_radians = this_1 * Angle_DEGTORAD
	return real_asAngleDegrees_return_radians
endfunction

function unit_getFacingAngle takes unit this_1 returns real
	set unit_getFacingAngle_return_radians = real_asAngleDegrees(GetUnitFacing(this_1))
	return unit_getFacingAngle_return_radians
endfunction

function unit_getFlyHeight takes unit this_1 returns real
	return GetUnitFlyHeight(this_1)
endfunction

function vec2_withRealZ takes real this_x, real this_y, unit u returns real
	set vec2_withRealZ_return_x = this_x
	set vec2_withRealZ_return_y = this_y
	set vec2_withRealZ_return_z = vec2_getTerrainZ(this_x, this_y) + unit_getFlyHeight(u)
	return vec2_withRealZ_return_x
endfunction

function unit_getPos3Real takes unit this_1 returns real
	set unit_getPos3Real_return_x = vec2_withRealZ(unit_getPos(this_1), unit_getPos_return_y, this_1)
	set unit_getPos3Real_return_y = vec2_withRealZ_return_y
	set unit_getPos3Real_return_z = vec2_withRealZ_return_z
	return unit_getPos3Real_return_x
endfunction

function angle_degrees takes real this_radians returns real
	return this_radians * Angle_RADTODEG
endfunction

function unit_setFacing takes unit this_1, real a_radians returns nothing
	call SetUnitFacing(this_1, angle_degrees(a_radians))
endfunction

function Log_warn takes string msg returns nothing
	call printLog(Player_localPlayer, 3, msg)
endfunction

function vec3_rotate takes real this_x, real this_y, real this_z, real axis_x, real axis_y, real axis_z, real radians returns real
	local real al = axis_x * axis_x + axis_y * axis_y + axis_z * axis_z
	local real c = Cos(radians)
	local real s = Sin(radians)
	local real f
	local real zx
	local real zy
	local real zz
	local real xx
	local real xy
	local real xz
	local real yx
	local real yy
	local real yz
	if al == 0.0 then
		call Log_warn("vector.rotate error: The length of the axis vector is 0.0!")
		set vec3_rotate_return_x = 0.
		set vec3_rotate_return_y = 0.
		set vec3_rotate_return_z = 0.
		return vec3_rotate_return_x
	endif
	set f = (this_x * axis_x + this_y * axis_y + this_z * axis_z) / al
	set zx = axis_x * f
	set zy = axis_y * f
	set zz = axis_z * f
	set xx = this_x - zx
	set xy = this_y - zy
	set xz = this_z - zz
	set al = SquareRoot(al)
	set yx = (axis_y * xz - axis_z * xy) / al
	set yy = (axis_z * xx - axis_x * xz) / al
	set yz = (axis_x * xy - axis_y * xx) / al
	set vec3_rotate_return_x = xx * c + yx * s + zx
	set vec3_rotate_return_y = xy * c + yy * s + zy
	set vec3_rotate_return_z = xz * c + yz * s + zz
	return vec3_rotate_return_x
endfunction

function fire_onCast_ShieldGenerator takes integer this_1, unit caster_1, string w__wurst_stackPos returns nothing
	local integer id_1
	local integer cond_result
	local integer clVar
	local real axis_x
	local real axis_y
	local real axis_z
	local real angl_radians
	local real pos_x
	local real pos_y
	local real pos_z
	local real array points_x
	local real array points_y
	local real array points_z
	local real cond_result_x
	local real cond_result_y
	local real cond_result_z
	local real cond_result_x_1
	local real cond_result_y_1
	local real cond_result_z_1
	local real p1_x
	local real p1_y
	local real p1_z
	local real p2_x
	local real p2_y
	local real p2_z
	local real p3_x
	local real p3_y
	local real p3_z
	local real p4_x
	local real p4_y
	local real p4_z
	local integer shield_1
	local integer clVar_1
	local unit temp
	local real temp_1
	local playerunitevent temp_2
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	local real tuple_temp_9
	local real tuple_temp_10
	local real tuple_temp_11
	local real tuple_temp_12
	local real tuple_temp_13
	local real tuple_temp_14
	local real tuple_temp_15
	local real tuple_temp_16
	local real tuple_temp_17
	local real tuple_temp_18
	local real tuple_temp_19
	local real tuple_temp_20
	local real tuple_temp_21
	local real tuple_temp_22
	local real tuple_temp_23
	local real tuple_temp_24
	local real tuple_temp_25
	local real tuple_temp_26
	local real tuple_temp_27
	local real tuple_temp_28
	local real tuple_temp_29
	local real tuple_temp_30
	local real tuple_temp_31
	local real tuple_temp_32
	local real tuple_temp_33
	local real tuple_temp_34
	local real tuple_temp_35
	local real tuple_temp_36
	local real tuple_temp_37
	local real tuple_temp_38
	local real tuple_temp_39
	local real tuple_temp_40
	local real tuple_temp_41
	local real tuple_temp_42
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set id_1 = EventData_getSpellAbilityId()
	set temp = caster_1
	if id_1 == ShieldGenerator_FRONT_SHIELD_ID then
		set cond_result = ShieldGenerator_ABOVE_SHIELD_ID
	else
		set cond_result = id_1
	endif
	call unit_disableAbility(temp, cond_result, true, false)
	set temp_1 = unit_getAbilityCooldown(caster_1, id_1, 1)
	set clVar = alloc_CallbackSingle_doAfter_onCast_ShieldGenerator("when calling alloc_CallbackSingle_doAfter_onCast_ShieldGenerator in ShieldGenerator, line 152")
	call construct_CallbackSingle(clVar)
	set caster[clVar] = caster_1
	set id[clVar] = id_1
	call doAfter(temp_1, clVar, "when calling doAfter in ShieldGenerator, line 152")
	set tuple_temp = 0.
	set tuple_temp_1 = 0.
	set tuple_temp_2 = 1.
	set axis_x = tuple_temp
	set axis_y = tuple_temp_1
	set axis_z = tuple_temp_2
	set tuple_temp_3 = unit_getFacingAngle(caster_1)
	set angl_radians = tuple_temp_3
	set tuple_temp_4 = unit_getPos3Real(caster_1)
	set tuple_temp_5 = unit_getPos3Real_return_y
	set tuple_temp_6 = unit_getPos3Real_return_z
	set pos_x = tuple_temp_4
	set pos_y = tuple_temp_5
	set pos_z = tuple_temp_6
	set tuple_temp_7 = Vectors_ZERO3_x
	set tuple_temp_8 = Vectors_ZERO3_y
	set tuple_temp_9 = Vectors_ZERO3_z
	set points_x[0] = tuple_temp_7
	set points_y[0] = tuple_temp_8
	set points_z[0] = tuple_temp_9
	set tuple_temp_10 = Vectors_ZERO3_x
	set tuple_temp_11 = Vectors_ZERO3_y
	set tuple_temp_12 = Vectors_ZERO3_z
	set points_x[1] = tuple_temp_10
	set points_y[1] = tuple_temp_11
	set points_z[1] = tuple_temp_12
	if id_1 == ShieldGenerator_FRONT_SHIELD_ID then
		set tuple_temp_13 = ShieldGenerator_FRONT_SHIELD_POINTS_x[0]
		set tuple_temp_14 = ShieldGenerator_FRONT_SHIELD_POINTS_y[0]
		set tuple_temp_15 = ShieldGenerator_FRONT_SHIELD_POINTS_z[0]
		set cond_result_x = tuple_temp_13
		set cond_result_y = tuple_temp_14
		set cond_result_z = tuple_temp_15
	else
		set tuple_temp_16 = ShieldGenerator_ABOVE_SHIELD_POINTS_x[0]
		set tuple_temp_17 = ShieldGenerator_ABOVE_SHIELD_POINTS_y[0]
		set tuple_temp_18 = ShieldGenerator_ABOVE_SHIELD_POINTS_z[0]
		set cond_result_x = tuple_temp_16
		set cond_result_y = tuple_temp_17
		set cond_result_z = tuple_temp_18
	endif
	set tuple_temp_19 = cond_result_x
	set tuple_temp_20 = cond_result_y
	set tuple_temp_21 = cond_result_z
	set points_x[0] = tuple_temp_19
	set points_y[0] = tuple_temp_20
	set points_z[0] = tuple_temp_21
	if id_1 == ShieldGenerator_FRONT_SHIELD_ID then
		set tuple_temp_22 = ShieldGenerator_FRONT_SHIELD_POINTS_x[1]
		set tuple_temp_23 = ShieldGenerator_FRONT_SHIELD_POINTS_y[1]
		set tuple_temp_24 = ShieldGenerator_FRONT_SHIELD_POINTS_z[1]
		set cond_result_x_1 = tuple_temp_22
		set cond_result_y_1 = tuple_temp_23
		set cond_result_z_1 = tuple_temp_24
	else
		set tuple_temp_25 = ShieldGenerator_ABOVE_SHIELD_POINTS_x[1]
		set tuple_temp_26 = ShieldGenerator_ABOVE_SHIELD_POINTS_y[1]
		set tuple_temp_27 = ShieldGenerator_ABOVE_SHIELD_POINTS_z[1]
		set cond_result_x_1 = tuple_temp_25
		set cond_result_y_1 = tuple_temp_26
		set cond_result_z_1 = tuple_temp_27
	endif
	set tuple_temp_28 = cond_result_x_1
	set tuple_temp_29 = cond_result_y_1
	set tuple_temp_30 = cond_result_z_1
	set points_x[1] = tuple_temp_28
	set points_y[1] = tuple_temp_29
	set points_z[1] = tuple_temp_30
	set tuple_temp_31 = vec3_op_plus(vec3_rotate(points_x[0], points_y[0], points_z[0], axis_x, axis_y, axis_z, angle_radians(angl_radians)), vec3_rotate_return_y, vec3_rotate_return_z, pos_x, pos_y, pos_z)
	set tuple_temp_32 = vec3_op_plus_return_y
	set tuple_temp_33 = vec3_op_plus_return_z
	set p1_x = tuple_temp_31
	set p1_y = tuple_temp_32
	set p1_z = tuple_temp_33
	set tuple_temp_34 = vec3_op_plus(vec3_rotate(points_x[0], points_y[1], points_z[0], axis_x, axis_y, axis_z, angle_radians(angl_radians)), vec3_rotate_return_y, vec3_rotate_return_z, pos_x, pos_y, pos_z)
	set tuple_temp_35 = vec3_op_plus_return_y
	set tuple_temp_36 = vec3_op_plus_return_z
	set p2_x = tuple_temp_34
	set p2_y = tuple_temp_35
	set p2_z = tuple_temp_36
	set tuple_temp_37 = vec3_op_plus(vec3_rotate(points_x[1], points_y[1], points_z[1], axis_x, axis_y, axis_z, angle_radians(angl_radians)), vec3_rotate_return_y, vec3_rotate_return_z, pos_x, pos_y, pos_z)
	set tuple_temp_38 = vec3_op_plus_return_y
	set tuple_temp_39 = vec3_op_plus_return_z
	set p3_x = tuple_temp_37
	set p3_y = tuple_temp_38
	set p3_z = tuple_temp_39
	set tuple_temp_40 = vec3_op_plus(vec3_rotate(points_x[1], points_y[0], points_z[1], axis_x, axis_y, axis_z, angle_radians(angl_radians)), vec3_rotate_return_y, vec3_rotate_return_z, pos_x, pos_y, pos_z)
	set tuple_temp_41 = vec3_op_plus_return_y
	set tuple_temp_42 = vec3_op_plus_return_z
	set p4_x = tuple_temp_40
	set p4_y = tuple_temp_41
	set p4_z = tuple_temp_42
	call unit_setFacing(caster_1, angl_radians)
	set shield_1 = new_Shield(caster_1, p1_x, p1_y, p1_z, p2_x, p2_y, p2_z, p3_x, p3_y, p3_z, p4_x, p4_y, p4_z, "when calling new_Shield in ShieldGenerator, line 165")
	set temp_2 = EVENT_PLAYER_UNIT_SPELL_ENDCAST
	set clVar_1 = alloc_EventListener_add_onCast_ShieldGenerator("when calling alloc_EventListener_add_onCast_ShieldGenerator in ShieldGenerator, line 166")
	call construct_EventListener(clVar_1)
	set id_482[clVar_1] = id_1
	set caster_455[clVar_1] = caster_1
	set shield[clVar_1] = shield_1
	call EventListener_add(temp_2, clVar_1, "when calling add in ShieldGenerator, line 166")
	set wurst_stack_depth = wurst_stack_depth - 1
	set temp = null
	set temp_2 = null
endfunction

function dispatch_OnCastListener_ClosureEvents_OnCastListener_fire takes integer this_1, unit caster_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if OnCastListener_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling OnCastListener.fire", "when calling error in ClosureEvents, line 56")
		else
			call error("Called OnCastListener.fire on invalid object.", "when calling error in ClosureEvents, line 56")
		endif
	endif
	if OnCastListener_typeId[this_1] <= 747 then
		if OnCastListener_typeId[this_1] <= 746 then
			call OnCast_fire(this_1, caster_1)
		else
			call fire_onCast_ShieldGenerator(this_1, caster_1, "when calling fire_onCast_ShieldGenerator in ClosureEvents, line 56")
		endif
	elseif OnCastListener_typeId[this_1] <= 748 then
		call OnPointCast_fire(this_1, caster_1)
	else
		call OnUnitCast_fire(this_1, caster_1)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function EventListener_onSpellEffect takes string w__wurst_stackPos returns nothing
	local unit trigUnit
	local integer abilId
	local integer listener
	local integer nextListener
	local integer listener_1
	local integer nextListener_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set trigUnit = GetTriggerUnit()
	set abilId = GetSpellAbilityId()
	if dispatch_HashMap_HashMap_HashMap_has(EventListener_castMapCasters, unitToIndex(trigUnit), "when calling has in ClosureEvents, line 193") then
		set listener = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMapCasters, unitToIndex(trigUnit), "when calling get in ClosureEvents, line 194")
		loop
			exitwhen  not (listener != 0)
			set nextListener = OnCastListener_next[listener]
			if OnCastListener_abilId[listener] == -1 or OnCastListener_abilId[listener] == abilId then
				call dispatch_OnCastListener_ClosureEvents_OnCastListener_fire(listener, GetSpellAbilityUnit(), "when calling fire in ClosureEvents, line 198")
			endif
			set listener = nextListener
		endloop
	endif
	if dispatch_HashMap_HashMap_HashMap_has(EventListener_castMap, abilId, "when calling has in ClosureEvents, line 200") then
		set listener_1 = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMap, abilId, "when calling get in ClosureEvents, line 201")
		loop
			exitwhen  not (listener_1 != 0)
			set nextListener_1 = OnCastListener_next[listener_1]
			if OnCastListener_eventUnit[listener_1] == null or OnCastListener_eventUnit[listener_1] == trigUnit then
				call dispatch_OnCastListener_ClosureEvents_OnCastListener_fire(listener_1, GetSpellAbilityUnit(), "when calling fire in ClosureEvents, line 205")
			endif
			set listener_1 = nextListener_1
		endloop
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	set trigUnit = null
endfunction

function code__registerPlayerUnitEvent_nullTimer_ClosureEvents takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call EventListener_onSpellEffect("when calling onSpellEffect in ClosureEvents, line 312")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__registerPlayerUnitEvent_nullTimer_ClosureEvents takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__registerPlayerUnitEvent_nullTimer_ClosureEvents("via function reference ClosureEvents, line 312")
endfunction

function printTimed takes string msg, real duration returns nothing
	call DisplayTimedTextToPlayer(Player_localPlayer, 0., 0., duration, msg)
endfunction

function call_doAfter_Character takes integer this_1 returns nothing
	call printTimed("|cFFFFCC00Reach the end of the road.|r", 10.)
endfunction

function call_doAfter_ClosureTimers takes integer this_1 returns nothing
	set ClosureTimers_x = ClosureTimers_x + 50
endfunction

function call_doAfter_ClosureTimers_528 takes integer this_1 returns nothing
	set ClosureTimers_x = ClosureTimers_x * 2
endfunction

function call_doAfter_ClosureTimers_529 takes integer this_1 returns nothing
	set ClosureTimers_x = ClosureTimers_x / 2
	call int_assertEquals(ClosureTimers_x, 250)
endfunction

function player_select takes player this_1, unit u returns nothing
	if Player_localPlayer == this_1 then
		call SelectUnit(u, true)
	endif
endfunction

function player_setCameraTargetControllerNoZ takes player this_1, unit whichUnit, real offset_x, real offset_y, boolean inheritOrientation returns nothing
	call SetCameraTargetControllerNoZForPlayer(this_1, whichUnit, offset_x, offset_y, inheritOrientation)
endfunction

function timerdialog_destr takes timerdialog this_1 returns nothing
	call DestroyTimerDialog(this_1)
endfunction

function unit_getOwner takes unit this_1 returns player
	return GetOwningPlayer(this_1)
endfunction

function unit_revive takes unit this_1, real pos_x, real pos_y, boolean doEyecandy returns nothing
	call ReviveHero(this_1, pos_x, pos_y, doEyecandy)
endfunction

function call_doAfter_add_Character takes integer this_1 returns nothing
	local player receiver
	local player receiver_1
	call unit_revive(dyingUnit[this_1], Character_checkpoint_x, Character_checkpoint_y, true)
	call panCameraToTimed(Character_checkpoint_x, Character_checkpoint_y, 0.)
	call timerdialog_destr(reviveTimerDialog[this_1])
	set receiver = unit_getOwner(dyingUnit[this_1])
	call player_select(receiver, dyingUnit[this_1])
	set receiver_1 = receiver
	call player_setCameraTargetControllerNoZ(receiver_1, dyingUnit[this_1], Vectors_ZERO2_x, Vectors_ZERO2_y, false)
	set receiver = null
	set receiver_1 = null
endfunction

function call_doAfter_onCast_ShieldGenerator takes integer this_1 returns nothing
	local unit temp = caster[this_1]
	local integer cond_result
	if id[this_1] == ShieldGenerator_FRONT_SHIELD_ID then
		set cond_result = ShieldGenerator_ABOVE_SHIELD_ID
	else
		set cond_result = id[this_1]
	endif
	call unit_disableAbility(temp, cond_result, false, false)
	set temp = null
endfunction

function trigger_registerPlayerChatEvent takes trigger this_1, player whichPlayer, string chatMessageToDetect, boolean exactMatchOnly returns event
	return TriggerRegisterPlayerChatEvent(this_1, whichPlayer, chatMessageToDetect, exactMatchOnly)
endfunction

function call_nullTimer_ClosureEvents takes integer this_1 returns nothing
	local integer i
	local integer temp
	local trigger receiver
	local trigger receiver_1
	local trigger receiver_2
	local trigger receiver_3
	local trigger receiver_4
	local trigger receiver_5
	local trigger receiver_6
	local trigger receiver_7
	local trigger receiver_8
	local trigger receiver_9
	call trigger_addAction(ClosureEvents_unitTrig, ref_function_bridge_code__addAction_nullTimer_ClosureEvents)
	call trigger_addAction(ClosureEvents_leaveTrig, ref_function_bridge_code__addAction_nullTimer_ClosureEvents_510)
	call trigger_addAction(ClosureEvents_keyTrig, ref_function_bridge_code__addAction_nullTimer_ClosureEvents_511)
	set i = 0
	set temp = bj_MAX_PLAYERS - 1
	loop
		exitwhen i > temp
		call trigger_registerPlayerEvent(ClosureEvents_leaveTrig, Player_players[i], EVENT_PLAYER_LEAVE)
		set receiver = ClosureEvents_keyTrig
		call trigger_registerPlayerEvent(receiver, Player_players[i], EVENT_PLAYER_ARROW_DOWN_DOWN)
		set receiver_1 = receiver
		call trigger_registerPlayerEvent(receiver_1, Player_players[i], EVENT_PLAYER_ARROW_DOWN_UP)
		set receiver_2 = receiver_1
		call trigger_registerPlayerEvent(receiver_2, Player_players[i], EVENT_PLAYER_ARROW_UP_DOWN)
		set receiver_3 = receiver_2
		call trigger_registerPlayerEvent(receiver_3, Player_players[i], EVENT_PLAYER_ARROW_UP_UP)
		set receiver_4 = receiver_3
		call trigger_registerPlayerEvent(receiver_4, Player_players[i], EVENT_PLAYER_ARROW_LEFT_DOWN)
		set receiver_5 = receiver_4
		call trigger_registerPlayerEvent(receiver_5, Player_players[i], EVENT_PLAYER_ARROW_LEFT_UP)
		set receiver_6 = receiver_5
		call trigger_registerPlayerEvent(receiver_6, Player_players[i], EVENT_PLAYER_ARROW_RIGHT_DOWN)
		set receiver_7 = receiver_6
		call trigger_registerPlayerEvent(receiver_7, Player_players[i], EVENT_PLAYER_ARROW_RIGHT_UP)
		set receiver_8 = receiver_7
		call trigger_registerPlayerEvent(receiver_8, Player_players[i], EVENT_PLAYER_END_CINEMATIC)
		set receiver_9 = receiver_8
		call trigger_registerPlayerChatEvent(receiver_9, Player_players[i], "", false)
		set i = i + 1
	endloop
	call registerPlayerUnitEvent_911(EVENT_PLAYER_UNIT_SPELL_EFFECT, null, ref_function_bridge_code__registerPlayerUnitEvent_nullTimer_ClosureEvents, null)
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
	set receiver_3 = null
	set receiver_4 = null
	set receiver_5 = null
	set receiver_6 = null
	set receiver_7 = null
	set receiver_8 = null
	set receiver_9 = null
endfunction

function group_destr takes group this_1 returns nothing
	call DestroyGroup(this_1)
endfunction

function group_enumUnitsInRect_746 takes group this_1, rect rec, boolexpr filter returns nothing
	call GroupEnumUnitsInRect(this_1, rec, filter)
endfunction

function group_enumUnitsInRect takes group this_1, rect rec returns nothing
	call group_enumUnitsInRect_746(this_1, rec, null)
endfunction

function trigger_registerEnterRegion takes trigger this_1, region whichRegion, boolexpr filter returns event
	return TriggerRegisterEnterRegion(this_1, whichRegion, filter)
endfunction

function call_nullTimer_OnUnitEnterLeave takes integer this_1 returns nothing
	local trigger receiver = CreateTrigger()
	local group receiver_1
	local group receiver_2
	call trigger_registerEnterRegion(receiver, MapBounds_boundRegion, Filter(ref_function_code__Filter_registerEnterRegion_nullTimer_OnUnitEnterLeave))
	call registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, ref_function_code__registerPlayerUnitEvent_nullTimer_OnUnitEnterLeave)
	call group_enumUnitsInRect(OnUnitEnterLeave_preplacedUnits, MapBounds_boundRect)
	call ForGroup(OnUnitEnterLeave_preplacedUnits, ref_function_code__ForGroup_nullTimer_OnUnitEnterLeave)
	set receiver_1 = OnUnitEnterLeave_preplacedUnits
	call group_clear(receiver_1)
	set receiver_2 = receiver_1
	call group_destr(receiver_2)
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
endfunction

function alloc_ForGroupCallback_forEachFrom_Preloader takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_firstFree == 0 then
		if ForGroupCallback_maxIndex < 32768 then
			set ForGroupCallback_maxIndex = ForGroupCallback_maxIndex + 1
			set this_1 = ForGroupCallback_maxIndex
			set ForGroupCallback_typeId[this_1] = 673
		else
			call error("Out of memory: Could not create ForGroupCallback_forEachFrom_Preloader.", "when calling error in Preloader, line 48")
			set this_1 = 0
		endif
	else
		set ForGroupCallback_firstFree = ForGroupCallback_firstFree - 1
		set this_1 = ForGroupCallback_nextFree[ForGroupCallback_firstFree]
		set ForGroupCallback_typeId[this_1] = 673
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function group_forEachFrom takes group this_1, integer cb, string w__wurst_stackPos returns nothing
	local unit u
	local group from
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set from = this_1
	loop
		exitwhen  not group_hasNext(from)
		set u = group_next(from)
		call dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback(cb, u, "when calling callback in ClosureForGroups, line 40")
	endloop
	call dispatch_ForGroupCallback_destroyForGroupCallback(cb, "when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 41")
	set wurst_stack_depth = wurst_stack_depth - 1
	set u = null
	set from = null
endfunction

function finishPreload takes string w__wurst_stackPos returns nothing
	local integer clVar
	local group temp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call unit_remove(Preloader_dum)
	set temp = Preloader_dumg
	set clVar = alloc_ForGroupCallback_forEachFrom_Preloader("when calling alloc_ForGroupCallback_forEachFrom_Preloader in Preloader, line 48")
	call group_forEachFrom(temp, clVar, "when calling forEachFrom in Preloader, line 48")
	call group_destr(Preloader_dumg)
	set Preloader_dumg = null
	set wurst_stack_depth = wurst_stack_depth - 1
	set temp = null
endfunction

function call_nullTimer_Preloader takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call finishPreload("when calling finishPreload in Preloader, line 58")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackSingle_ClosureTimers_CallbackSingle_call takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackSingle.call", "when calling error in ClosureTimers, line 109")
		else
			call error("Called CallbackSingle.call on invalid object.", "when calling error in ClosureTimers, line 109")
		endif
	endif
	if CallbackSingle_typeId[this_1] <= 653 then
		if CallbackSingle_typeId[this_1] <= 651 then
			if CallbackSingle_typeId[this_1] <= 650 then
				if CallbackSingle_typeId[this_1] <= 649 then
					call call_doAfter_Character(this_1)
				else
					call call_doAfter_ClosureTimers(this_1)
				endif
			else
				call call_doAfter_ClosureTimers_528(this_1)
			endif
		elseif CallbackSingle_typeId[this_1] <= 652 then
			call call_doAfter_ClosureTimers_529(this_1)
		else
			call call_doAfter_add_Character(this_1)
		endif
	elseif CallbackSingle_typeId[this_1] <= 655 then
		if CallbackSingle_typeId[this_1] <= 654 then
			call call_doAfter_onCast_ShieldGenerator(this_1)
		else
			call call_nullTimer_ClosureEvents(this_1)
		endif
	elseif CallbackSingle_typeId[this_1] <= 656 then
		call call_nullTimer_OnUnitEnterLeave(this_1)
	else
		call call_nullTimer_Preloader(this_1, "when calling call_nullTimer_Preloader in ClosureTimers, line 109")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackSingle_onDestroy takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call timer_release(CallbackSingle_t[this_1], "when calling release in ClosureTimers, line 124")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_CallbackSingle takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[obj] == 0 then
		call error("Double free: object of type CallbackSingle", "when calling error in ClosureTimers, line 107")
	else
		set CallbackSingle_nextFree[CallbackSingle_firstFree] = obj
		set CallbackSingle_firstFree = CallbackSingle_firstFree + 1
		set CallbackSingle_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyCallbackSingle takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call CallbackSingle_onDestroy(this_1, "when calling CallbackSingle_onDestroy in ClosureTimers, line 123")
	call dealloc_CallbackSingle(this_1, "when calling dealloc_CallbackSingle in ClosureTimers, line 123")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackSingle_destroyCallbackSingle takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackSingle.CallbackSingle", "when calling error in ClosureTimers, line 107")
		else
			call error("Called CallbackSingle.CallbackSingle on invalid object.", "when calling error in ClosureTimers, line 107")
		endif
	endif
	call destroyCallbackSingle(this_1, "when calling destroyCallbackSingle in ClosureTimers, line 107")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackSingle_staticCallback takes string w__wurst_stackPos returns nothing
	local timer t
	local integer cb
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set t = GetExpiredTimer()
	set cb = timer_getData(t, "when calling getData in ClosureTimers, line 119")
	call dispatch_CallbackSingle_ClosureTimers_CallbackSingle_call(cb, "when calling call in ClosureTimers, line 120")
	call dispatch_CallbackSingle_destroyCallbackSingle(cb, "when calling dispatch_CallbackSingle_destroyCallbackSingle in ClosureTimers, line 121")
	set wurst_stack_depth = wurst_stack_depth - 1
	set t = null
endfunction

function code__start_CallbackSingle_ClosureTimers takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call CallbackSingle_staticCallback("when calling staticCallback in ClosureTimers, line 114")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__start_CallbackSingle_ClosureTimers takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__start_CallbackSingle_ClosureTimers("via function reference ClosureTimers, line 114")
endfunction

function alloc_OrderStringFactory takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if OrderStringFactory_firstFree == 0 then
		if OrderStringFactory_maxIndex < 32768 then
			set OrderStringFactory_maxIndex = OrderStringFactory_maxIndex + 1
			set this_1 = OrderStringFactory_maxIndex
		else
			call error("Out of memory: Could not create OrderStringFactory.", "when calling error in OrderStringFactory, line 9")
			set this_1 = 0
		endif
	else
		set OrderStringFactory_firstFree = OrderStringFactory_firstFree - 1
		set this_1 = OrderStringFactory_nextFree[OrderStringFactory_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function OrderStringFactory_init takes integer this_1 returns nothing
endfunction

function construct_OrderStringFactory takes integer this_1 returns nothing
	call OrderStringFactory_init(this_1)
endfunction

function new_OrderStringFactory takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_OrderStringFactory("when calling alloc_OrderStringFactory in OrderStringFactory, line 9")
	call construct_OrderStringFactory(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_ChannelAbilityPreset takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call new_OrderStringFactory("when calling new_OrderStringFactory in ChannelAbilityPreset, line 10")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_ChannelAbilityPreset takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_ChannelAbilityPreset("via function reference ChannelAbilityPreset, line 1")
endfunction

function alloc_CallbackSingle_doAfter_Character takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this_1 = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this_1] = 649
		else
			call error("Out of memory: Could not create CallbackSingle_doAfter_Character.", "when calling error in Character, line 48")
			set this_1 = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this_1 = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this_1] = 649
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_EventListener_add_Character takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_firstFree == 0 then
		if EventListener_maxIndex < 32768 then
			set EventListener_maxIndex = EventListener_maxIndex + 1
			set this_1 = EventListener_maxIndex
			set EventListener_typeId[this_1] = 664
		else
			call error("Out of memory: Could not create EventListener_add_Character.", "when calling error in Character, line 56")
			set this_1 = 0
		endif
	else
		set EventListener_firstFree = EventListener_firstFree - 1
		set this_1 = EventListener_nextFree[EventListener_firstFree]
		set EventListener_typeId[this_1] = 664
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_EventListener_add_Character_462 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_firstFree == 0 then
		if EventListener_maxIndex < 32768 then
			set EventListener_maxIndex = EventListener_maxIndex + 1
			set this_1 = EventListener_maxIndex
			set EventListener_typeId[this_1] = 665
		else
			call error("Out of memory: Could not create EventListener_add_Character.", "when calling error in Character, line 85")
			set this_1 = 0
		endif
	else
		set EventListener_firstFree = EventListener_firstFree - 1
		set this_1 = EventListener_nextFree[EventListener_firstFree]
		set EventListener_typeId[this_1] = 665
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function createUnit takes player p, integer unitId, real pos_x, real pos_y, real facing_radians returns unit
	return CreateUnit(p, unitId, pos_x, pos_y, angle_degrees(facing_radians))
endfunction

function ObjectDefinition_setInt takes string this_key, string modification, integer value returns nothing
endfunction

function boolean_toInt takes boolean this_1 returns integer
	local integer cond_result
	if this_1 then
		set cond_result = 1
	else
		set cond_result = 0
	endif
	return cond_result
endfunction

function ObjectDefinition_setBoolean takes string this_key, string modification, boolean value returns nothing
	call ObjectDefinition_setInt(this_key, modification, boolean_toInt(value))
endfunction

function HeroDefinition_hideHeroDeathMsg takes integer this_1, boolean flag returns nothing
	call ObjectDefinition_setBoolean(W3UDefinition_def_key[this_1], "uhhd", flag)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_hideHeroDeathMsg takes integer this_1, boolean flag, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.hideHeroDeathMsg", "when calling error in UnitObjEditing, line 629")
		else
			call error("Called HeroDefinition.hideHeroDeathMsg on invalid object.", "when calling error in UnitObjEditing, line 629")
		endif
	endif
	call HeroDefinition_hideHeroDeathMsg(this_1, flag)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_hideHeroInterfaceIcon takes integer this_1, boolean flag returns nothing
	call ObjectDefinition_setBoolean(W3UDefinition_def_key[this_1], "uhhb", flag)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_hideHeroInterfaceIcon takes integer this_1, boolean flag, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.hideHeroInterfaceIcon", "when calling error in UnitObjEditing, line 632")
		else
			call error("Called HeroDefinition.hideHeroInterfaceIcon on invalid object.", "when calling error in UnitObjEditing, line 632")
		endif
	endif
	call HeroDefinition_hideHeroInterfaceIcon(this_1, flag)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function ObjectDefinition_setString takes string this_key, string modification, string value returns nothing
endfunction

function HeroDefinition_setHeroAbilities takes integer this_1, string data returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "uhab", data)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setHeroAbilities takes integer this_1, string data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.setHeroAbilities", "when calling error in UnitObjEditing, line 671")
		else
			call error("Called HeroDefinition.setHeroAbilities on invalid object.", "when calling error in UnitObjEditing, line 671")
		endif
	endif
	call HeroDefinition_setHeroAbilities(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_setProperNames takes integer this_1, string data returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "upro", data)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setProperNames takes integer this_1, string data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.setProperNames", "when calling error in UnitObjEditing, line 659")
		else
			call error("Called HeroDefinition.setProperNames on invalid object.", "when calling error in UnitObjEditing, line 659")
		endif
	endif
	call HeroDefinition_setProperNames(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_setProperNamesUsed takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "upru", data)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setProperNamesUsed takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.setProperNamesUsed", "when calling error in UnitObjEditing, line 656")
		else
			call error("Called HeroDefinition.setProperNamesUsed on invalid object.", "when calling error in UnitObjEditing, line 656")
		endif
	endif
	call HeroDefinition_setProperNamesUsed(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_setStartingAgility takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "uagi", data)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setStartingAgility takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.setStartingAgility", "when calling error in UnitObjEditing, line 653")
		else
			call error("Called HeroDefinition.setStartingAgility on invalid object.", "when calling error in UnitObjEditing, line 653")
		endif
	endif
	call HeroDefinition_setStartingAgility(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_setStartingIntelligence takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "uint", data)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setStartingIntelligence takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.setStartingIntelligence", "when calling error in UnitObjEditing, line 650")
		else
			call error("Called HeroDefinition.setStartingIntelligence on invalid object.", "when calling error in UnitObjEditing, line 650")
		endif
	endif
	call HeroDefinition_setStartingIntelligence(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_setStartingStrength takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "ustr", data)
endfunction

function dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setStartingStrength takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroDefinition.setStartingStrength", "when calling error in UnitObjEditing, line 647")
		else
			call error("Called HeroDefinition.setStartingStrength on invalid object.", "when calling error in UnitObjEditing, line 647")
		endif
	endif
	call HeroDefinition_setStartingStrength(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function string_length takes string this_1 returns integer
	return StringLength(this_1)
endfunction

function string_substring takes string this_1, integer start, integer stop returns string
	return SubString(this_1, start, stop)
endfunction

function HeroPreset_buildHeroAbilities takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if string_length(HeroPreset_heroAbilityString[this_1]) > 0 then
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setHeroAbilities(this_1, string_substring(HeroPreset_heroAbilityString[this_1], 0, string_length(HeroPreset_heroAbilityString[this_1]) - 1), "when calling setHeroAbilities in HeroPreset, line 40")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HeroPreset_HeroPreset_HeroPreset_buildHeroAbilities takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroPreset.buildHeroAbilities", "when calling error in HeroPreset, line 38")
		else
			call error("Called HeroPreset.buildHeroAbilities on invalid object.", "when calling error in HeroPreset, line 38")
		endif
	endif
	call HeroPreset_buildHeroAbilities(this_1, "when calling buildHeroAbilities in HeroPreset, line 38")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setNormalAbilities takes integer this_1, string data returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "uabi", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setNormalAbilities takes integer this_1, string data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setNormalAbilities", "when calling error in UnitObjEditing, line 243")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setNormalAbilities on invalid object.", "when calling error in UnitObjEditing, line 243")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setNormalAbilities(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroPreset_buildNormalAbilities takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if string_length(HeroPreset_normalAbilityString[this_1]) > 0 then
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setNormalAbilities(this_1, string_substring(HeroPreset_normalAbilityString[this_1], 0, string_length(HeroPreset_normalAbilityString[this_1]) - 1), "when calling setNormalAbilities in HeroPreset, line 47")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HeroPreset_HeroPreset_HeroPreset_buildNormalAbilities takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroPreset.buildNormalAbilities", "when calling error in HeroPreset, line 45")
		else
			call error("Called HeroPreset.buildNormalAbilities on invalid object.", "when calling error in HeroPreset, line 45")
		endif
	endif
	call HeroPreset_buildNormalAbilities(this_1, "when calling buildNormalAbilities in HeroPreset, line 45")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function LLIterator_onDestroy takes integer this_1 returns nothing
endfunction

function dealloc_LLIterator takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLIterator_typeId[obj] == 0 then
		call error("Double free: object of type LLIterator", "when calling error in LinkedList, line 431")
	else
		set LLIterator_nextFree[LLIterator_firstFree] = obj
		set LLIterator_firstFree = LLIterator_firstFree + 1
		set LLIterator_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyLLIterator takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call LLIterator_onDestroy(this_1)
	call dealloc_LLIterator(this_1, "when calling dealloc_LLIterator in LinkedList, line 431")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_LLIterator_destroyLLIterator takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLIterator_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling LLIterator.LLIterator", "when calling error in LinkedList, line 431")
		else
			call error("Called LLIterator.LLIterator on invalid object.", "when calling error in LinkedList, line 431")
		endif
	endif
	call destroyLLIterator(this_1, "when calling destroyLLIterator in LinkedList, line 431")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function LLIterator_close takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLIterator_destroyOnClose[this_1] then
		call dispatch_LLIterator_destroyLLIterator(this_1, "when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 480")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function LLIterator_hasNext takes integer this_1 returns boolean
	return LLEntry_next[LLIterator_current[this_1]] != LLIterator_dummy[this_1]
endfunction

function LLIterator_next takes integer this_1 returns integer
	set LLIterator_current[this_1] = LLEntry_next[LLIterator_current[this_1]]
	return LLEntry_elem[LLIterator_current[this_1]]
endfunction

function alloc_LLIterator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLIterator_firstFree == 0 then
		if LLIterator_maxIndex < 32768 then
			set LLIterator_maxIndex = LLIterator_maxIndex + 1
			set this_1 = LLIterator_maxIndex
			set LLIterator_typeId[this_1] = 732
		else
			call error("Out of memory: Could not create LLIterator.", "when calling error in LinkedList, line 431")
			set this_1 = 0
		endif
	else
		set LLIterator_firstFree = LLIterator_firstFree - 1
		set this_1 = LLIterator_nextFree[LLIterator_firstFree]
		set LLIterator_typeId[this_1] = 732
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function LLIterator_init takes integer this_1 returns nothing
	set LLIterator_destroyOnClose[this_1] = true
endfunction

function LinkedList_getDummy takes integer this_1 returns integer
	return LinkedList_dummy[this_1]
endfunction

function dispatch_LinkedList_LinkedList_LinkedList_getDummy takes integer this_1, string w__wurst_stackPos returns integer
	local integer LinkedList_LinkedList_getDummy_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LinkedList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling LinkedList.getDummy", "when calling error in LinkedList, line 387")
		else
			call error("Called LinkedList.getDummy on invalid object.", "when calling error in LinkedList, line 387")
		endif
	endif
	set LinkedList_LinkedList_getDummy_result = LinkedList_getDummy(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return LinkedList_LinkedList_getDummy_result
endfunction

function LLIterator_reset takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set LLIterator_dummy[this_1] = dispatch_LinkedList_LinkedList_LinkedList_getDummy(LLIterator_parent[this_1], "when calling getDummy in LinkedList, line 447")
	set LLIterator_current[this_1] = LLIterator_dummy[this_1]
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_LLIterator_LinkedList_LLIterator_reset takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLIterator_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling LLIterator.reset", "when calling error in LinkedList, line 446")
		else
			call error("Called LLIterator.reset on invalid object.", "when calling error in LinkedList, line 446")
		endif
	endif
	call LLIterator_reset(this_1, "when calling reset in LinkedList, line 446")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function construct_LLIterator takes integer this_1, integer parent, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call LLIterator_init(this_1)
	set LLIterator_parent[this_1] = parent
	call dispatch_LLIterator_LinkedList_LLIterator_reset(this_1, "when calling reset in LinkedList, line 439")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function new_LLIterator takes integer parent, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_LLIterator("when calling alloc_LLIterator in LinkedList, line 437")
	call construct_LLIterator(this_1, parent, "when calling construct_LLIterator in LinkedList, line 437")
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function LinkedList_iterator takes integer this_1, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = new_LLIterator(this_1, "when calling new_LLIterator in LinkedList, line 184")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function LinkedList_size_1 takes integer this_1 returns integer
	return LinkedList_size[this_1]
endfunction

function dispatch_LinkedList_LinkedList_LinkedList_size takes integer this_1, string w__wurst_stackPos returns integer
	local integer LinkedList_LinkedList_size_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LinkedList_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling LinkedList.size", "when calling error in LinkedList, line 154")
		else
			call error("Called LinkedList.size on invalid object.", "when calling error in LinkedList, line 154")
		endif
	endif
	set LinkedList_LinkedList_size_result = LinkedList_size_1(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return LinkedList_LinkedList_size_result
endfunction

function hashtable_loadString takes hashtable this_1, integer parentKey, integer childKey returns string
	return LoadStr(this_1, parentKey, childKey)
endfunction

function Table_loadString takes integer this_1, integer parentKey returns string
	return hashtable_loadString(Table_ht, this_1, parentKey)
endfunction

function dispatch_Table_Table_Table_loadString takes integer this_1, integer parentKey, string w__wurst_stackPos returns string
	local string Table_Table_loadString_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.loadString", "when calling error in Table, line 58")
		else
			call error("Called Table.loadString on invalid object.", "when calling error in Table, line 58")
		endif
	endif
	set Table_Table_loadString_result = Table_loadString(this_1, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_loadString_result
endfunction

function stringFromIndex takes integer index, string w__wurst_stackPos returns string
	local string str
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set str = dispatch_Table_Table_Table_loadString(TypeCasting_typecastdata, index, "when calling loadString in TypeCasting, line 36")
	set wurst_stack_depth = wurst_stack_depth - 1
	return str
endfunction

function HeroPreset_buildProperNames takes integer this_1, string w__wurst_stackPos returns nothing
	local string s
	local integer iterator
	local string pn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set s = ""
	if dispatch_LinkedList_LinkedList_LinkedList_size(HeroPreset_properNames[this_1], "when calling size in HeroPreset, line 29") > 0 then
		set iterator = LinkedList_iterator(HeroPreset_properNames[this_1], "when calling iterator in HeroPreset, line 30")
		loop
			exitwhen  not LLIterator_hasNext(iterator)
			set pn = stringFromIndex(LLIterator_next(iterator), "when calling stringFromIndex in HeroPreset, line 30")
			set s = s + pn + ","
		endloop
		call LLIterator_close(iterator, "when calling close in HeroPreset, line 30")
		set s = string_substring(s, 0, string_length(s) - 1)
	endif
	call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setProperNames(this_1, s, "when calling setProperNames in HeroPreset, line 33")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HeroPreset_HeroPreset_HeroPreset_buildProperNames takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroPreset.buildProperNames", "when calling error in HeroPreset, line 27")
		else
			call error("Called HeroPreset.buildProperNames on invalid object.", "when calling error in HeroPreset, line 27")
		endif
	endif
	call HeroPreset_buildProperNames(this_1, "when calling buildProperNames in HeroPreset, line 27")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroPreset_buildHero takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_HeroPreset_HeroPreset_HeroPreset_buildProperNames(this_1, "when calling buildProperNames in HeroPreset, line 17")
	call dispatch_HeroPreset_HeroPreset_HeroPreset_buildHeroAbilities(this_1, "when calling buildHeroAbilities in HeroPreset, line 18")
	call dispatch_HeroPreset_HeroPreset_HeroPreset_buildNormalAbilities(this_1, "when calling buildNormalAbilities in HeroPreset, line 19")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HeroPreset_HeroPreset_HeroPreset_buildHero takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling HeroPreset.buildHero", "when calling error in HeroPreset, line 16")
		else
			call error("Called HeroPreset.buildHero on invalid object.", "when calling error in HeroPreset, line 16")
		endif
	endif
	call HeroPreset_buildHero(this_1, "when calling buildHero in HeroPreset, line 16")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setAttacksEnabled takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "uaen", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setAttacksEnabled takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setAttacksEnabled", "when calling error in UnitObjEditing, line 393")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setAttacksEnabled on invalid object.", "when calling error in UnitObjEditing, line 393")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setAttacksEnabled(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function ObjectDefinition_setUnreal takes string this_key, string modification, real value returns nothing
endfunction

function UnitOrBuildingOrHeroDefinition_setCollisionSize takes integer this_1, real data returns nothing
	call ObjectDefinition_setUnreal(W3UDefinition_def_key[this_1], "ucol", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setCollisionSize takes integer this_1, real data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setCollisionSize", "when calling error in UnitObjEditing, line 375")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setCollisionSize on invalid object.", "when calling error in UnitObjEditing, line 375")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setCollisionSize(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setManaMaximum takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "umpm", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setManaMaximum takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setManaMaximum", "when calling error in UnitObjEditing, line 270")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setManaMaximum on invalid object.", "when calling error in UnitObjEditing, line 270")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setManaMaximum(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setModelFile takes integer this_1, string data returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "umdl", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setModelFile takes integer this_1, string data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setModelFile", "when calling error in UnitObjEditing, line 255")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setModelFile on invalid object.", "when calling error in UnitObjEditing, line 255")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setModelFile(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function MovementType_toObjectString takes integer this_1 returns string
	local string result_1 = ""
	local integer temp = this_1
	if temp == 0 then
	elseif temp == 1 then
		set result_1 = "foot"
	elseif temp == 2 then
		set result_1 = "horse"
	elseif temp == 3 then
		set result_1 = "fly"
	elseif temp == 4 then
		set result_1 = "hover"
	elseif temp == 5 then
		set result_1 = "float"
	else
		set result_1 = "amph"
	endif
	return result_1
endfunction

function UnitOrBuildingOrHeroDefinition_setMovementType takes integer this_1, integer mtype returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "umvt", MovementType_toObjectString(mtype))
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setMovementType takes integer this_1, integer mtype, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setMovementType", "when calling error in UnitObjEditing, line 82")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setMovementType on invalid object.", "when calling error in UnitObjEditing, line 82")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setMovementType(this_1, mtype)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function ObjectDefinition_setReal takes string this_key, string modification, real value returns nothing
endfunction

function UnitOrBuildingOrHeroDefinition_setScalingValue takes integer this_1, real data returns nothing
	call ObjectDefinition_setReal(W3UDefinition_def_key[this_1], "usca", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setScalingValue takes integer this_1, real data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setScalingValue", "when calling error in UnitObjEditing, line 174")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setScalingValue on invalid object.", "when calling error in UnitObjEditing, line 174")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setScalingValue(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setSelectionScale takes integer this_1, real data returns nothing
	call ObjectDefinition_setReal(W3UDefinition_def_key[this_1], "ussc", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setSelectionScale takes integer this_1, real data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setSelectionScale", "when calling error in UnitObjEditing, line 165")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setSelectionScale on invalid object.", "when calling error in UnitObjEditing, line 165")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setSelectionScale(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setSpeedBase takes integer this_1, integer data returns nothing
	call ObjectDefinition_setInt(W3UDefinition_def_key[this_1], "umvs", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setSpeedBase takes integer this_1, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setSpeedBase", "when calling error in UnitObjEditing, line 128")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setSpeedBase on invalid object.", "when calling error in UnitObjEditing, line 128")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setSpeedBase(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function UnitOrBuildingOrHeroDefinition_setUnitSoundSet takes integer this_1, string data returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "usnd", data)
endfunction

function dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setUnitSoundSet takes integer this_1, string data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setUnitSoundSet", "when calling error in UnitObjEditing, line 76")
		else
			call error("Called UnitOrBuildingOrHeroDefinition.setUnitSoundSet on invalid object.", "when calling error in UnitObjEditing, line 76")
		endif
	endif
	call UnitOrBuildingOrHeroDefinition_setUnitSoundSet(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function alloc_HeroPreset takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_firstFree == 0 then
		if W3UDefinition_maxIndex < 32768 then
			set W3UDefinition_maxIndex = W3UDefinition_maxIndex + 1
			set this_1 = W3UDefinition_maxIndex
			set W3UDefinition_typeId[this_1] = 797
		else
			call error("Out of memory: Could not create HeroPreset.", "when calling error in HeroPreset, line 7")
			set this_1 = 0
		endif
	else
		set W3UDefinition_firstFree = W3UDefinition_firstFree - 1
		set this_1 = W3UDefinition_nextFree[W3UDefinition_firstFree]
		set W3UDefinition_typeId[this_1] = 797
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function string_charAt takes string this_1, integer index returns string
	return SubString(this_1, index, index + 1)
endfunction

function toRawCode takes integer value returns string
	local string result_1 = ""
	local integer remainingValue = value
	local integer byteno = 0
	local integer charValue
	loop
		exitwhen byteno > 3
		set charValue = ModuloInteger(remainingValue, 256)
		set remainingValue = remainingValue / 256
		set result_1 = string_charAt(ObjectIds_CHARMAP, charValue) + result_1
		set byteno = byteno + 1
	endloop
	return result_1
endfunction

function int_toRawCode takes integer this_1 returns string
	return toRawCode(this_1)
endfunction

function alloc_LinkedList takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LinkedList_firstFree == 0 then
		if LinkedList_maxIndex < 32768 then
			set LinkedList_maxIndex = LinkedList_maxIndex + 1
			set this_1 = LinkedList_maxIndex
			set LinkedList_typeId[this_1] = 735
		else
			call error("Out of memory: Could not create LinkedList.", "when calling error in LinkedList, line 18")
			set this_1 = 0
		endif
	else
		set LinkedList_firstFree = LinkedList_firstFree - 1
		set this_1 = LinkedList_nextFree[LinkedList_firstFree]
		set LinkedList_typeId[this_1] = 735
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function LinkedList_init takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set LinkedList_dummy[this_1] = new_LLEntry(0, 0, 0, "when calling new_LLEntry in LinkedList, line 19")
	set LinkedList_size[this_1] = 0
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function construct_LinkedList2 takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call LinkedList_init(this_1, "when calling LinkedList_init in LinkedList, line 32")
	set LLEntry_next[LinkedList_dummy[this_1]] = LinkedList_dummy[this_1]
	set LLEntry_prev[LinkedList_dummy[this_1]] = LinkedList_dummy[this_1]
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function new_LinkedList takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_LinkedList("when calling alloc_LinkedList in LinkedList, line 32")
	call construct_LinkedList2(this_1, "when calling construct_LinkedList2 in LinkedList, line 32")
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function HeroPreset_init takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set HeroPreset_properNames[this_1] = new_LinkedList("when calling new_LinkedList in HeroPreset, line 8")
	set HeroPreset_heroAbilityString[this_1] = ""
	set HeroPreset_normalAbilityString[this_1] = int_toRawCode(AbilityIds_inventory) + ","
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HeroDefinition_init takes integer this_1 returns nothing
endfunction

function UnitOrHeroDefinition_init takes integer this_1 returns nothing
endfunction

function UnitOrBuildingOrHeroDefinition_init takes integer this_1 returns nothing
endfunction

function W3UDefinition_init takes integer this_1 returns nothing
endfunction

function createObjectDefinition takes string fileType, integer newId, integer deriveFrom returns string
	set createObjectDefinition_return_key = ""
	return createObjectDefinition_return_key
endfunction

function construct_W3UDefinition takes integer this_1, integer newId, integer baseId returns nothing
	local string tuple_temp
	call W3UDefinition_init(this_1)
	set tuple_temp = createObjectDefinition("w3u", newId, baseId)
	set W3UDefinition_def_key[this_1] = tuple_temp
endfunction

function construct_UnitOrBuildingOrHeroDefinition takes integer this_1, integer newUnitId, integer origUnitId returns nothing
	call construct_W3UDefinition(this_1, newUnitId, origUnitId)
	call UnitOrBuildingOrHeroDefinition_init(this_1)
endfunction

function construct_UnitOrHeroDefinition takes integer this_1, integer newId, integer origId returns nothing
	call construct_UnitOrBuildingOrHeroDefinition(this_1, newId, origId)
	call UnitOrHeroDefinition_init(this_1)
endfunction

function construct_HeroDefinition takes integer this_1, integer newId, integer origId returns nothing
	call construct_UnitOrHeroDefinition(this_1, newId, origId)
	call HeroDefinition_init(this_1)
endfunction

function W3UDefinition_setName takes integer this_1, string data returns nothing
	call ObjectDefinition_setString(W3UDefinition_def_key[this_1], "unam", data)
endfunction

function dispatch_W3UDefinition_UnitObjEditing_W3UDefinition_setName takes integer this_1, string data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if W3UDefinition_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling W3UDefinition.setName", "when calling error in UnitObjEditing, line 37")
		else
			call error("Called W3UDefinition.setName on invalid object.", "when calling error in UnitObjEditing, line 37")
		endif
	endif
	call W3UDefinition_setName(this_1, data)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function construct_HeroPreset takes integer this_1, integer newId, integer origId, string name, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call construct_HeroDefinition(this_1, newId, origId)
	call HeroPreset_init(this_1, "when calling HeroPreset_init in HeroPreset, line 12")
	call dispatch_W3UDefinition_UnitObjEditing_W3UDefinition_setName(this_1, name, "when calling setName in HeroPreset, line 14")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function new_HeroPreset takes integer newId, integer origId, string name, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_HeroPreset("when calling alloc_HeroPreset in HeroPreset, line 12")
	call construct_HeroPreset(this_1, newId, origId, name, "when calling construct_HeroPreset in HeroPreset, line 12")
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function createCharacter takes string w__wurst_stackPos returns unit
	local integer originId
	local integer id_1
	local integer receiver
	local integer receiver_1
	local integer receiver_2
	local integer receiver_3
	local integer receiver_4
	local integer receiver_5
	local integer receiver_6
	local integer receiver_7
	local integer receiver_8
	local integer receiver_9
	local integer receiver_10
	local integer receiver_11
	local integer receiver_12
	local integer receiver_13
	local integer receiver_14
	local integer receiver_15
	local integer receiver_16
	local integer receiver_17
	local unit stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set originId = 1332109682
	set id_1 = 1213018161
	if MagicFunctions_compiletime then
		set receiver = new_HeroPreset(id_1, originId, "Mad Poet", "when calling new_HeroPreset in Character, line 13")
		call dispatch_HeroPreset_HeroPreset_HeroPreset_buildHero(receiver, "when calling buildHero in Character, line 14")
		set receiver_1 = receiver
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setProperNames(receiver_1, "Abdul Alhazred", "when calling setProperNames in Character, line 15")
		set receiver_2 = receiver_1
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setProperNamesUsed(receiver_2, 0, "when calling setProperNamesUsed in Character, line 16")
		set receiver_3 = receiver_2
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setUnitSoundSet(receiver_3, "Varimathras", "when calling setUnitSoundSet in Character, line 17")
		set receiver_4 = receiver_3
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setMovementType(receiver_4, 1, "when calling setMovementType in Character, line 18")
		set receiver_5 = receiver_4
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setAttacksEnabled(receiver_5, 0, "when calling setAttacksEnabled in Character, line 19")
		set receiver_6 = receiver_5
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setScalingValue(receiver_6, 1., "when calling setScalingValue in Character, line 20")
		set receiver_7 = receiver_6
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setModelFile(receiver_7, "units\\creeps\\OrcWarlockRed\\OrcWarlockRed.mdl", "when calling setModelFile in Character, line 21")
		set receiver_8 = receiver_7
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_hideHeroDeathMsg(receiver_8, true, "when calling hideHeroDeathMsg in Character, line 22")
		set receiver_9 = receiver_8
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_hideHeroInterfaceIcon(receiver_9, true, "when calling hideHeroInterfaceIcon in Character, line 23")
		set receiver_10 = receiver_9
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setHeroAbilities(receiver_10, "", "when calling setHeroAbilities in Character, line 24")
		set receiver_11 = receiver_10
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setSelectionScale(receiver_11, 1., "when calling setSelectionScale in Character, line 25")
		set receiver_12 = receiver_11
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setSpeedBase(receiver_12, 250, "when calling setSpeedBase in Character, line 26")
		set receiver_13 = receiver_12
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setManaMaximum(receiver_13, 0, "when calling setManaMaximum in Character, line 27")
		set receiver_14 = receiver_13
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setStartingStrength(receiver_14, 0, "when calling setStartingStrength in Character, line 28")
		set receiver_15 = receiver_14
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setStartingAgility(receiver_15, 0, "when calling setStartingAgility in Character, line 29")
		set receiver_16 = receiver_15
		call dispatch_HeroDefinition_UnitObjEditing_HeroDefinition_setStartingIntelligence(receiver_16, 0, "when calling setStartingIntelligence in Character, line 30")
		set receiver_17 = receiver_16
		call dispatch_UnitOrBuildingOrHeroDefinition_UnitObjEditing_UnitOrBuildingOrHeroDefinition_setCollisionSize(receiver_17, 16., "when calling setCollisionSize in Character, line 31")
		set wurst_stack_depth = wurst_stack_depth - 1
		return null
	else
		set stackTrace_tempReturn = createUnit(GetLocalPlayer(), id_1, rect_getCenter(gg_rct_Start), rect_getCenter_return_y, real_asAngleDegrees(135.))
		set wurst_stack_depth = wurst_stack_depth - 1
		return stackTrace_tempReturn
	endif
endfunction

function rectToIndex takes rect object returns integer
	return handle_getHandleId(object)
endfunction

function triggerToIndex takes trigger object returns integer
	return handle_getHandleId(object)
endfunction

function trigger_registerRectEnterEventSource takes trigger this_1, rect r, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call TriggerRegisterEnterRectSimple(this_1, r)
	call dispatch_HashMap_HashMap_HashMap_put(EventHelper_rectMap, triggerToIndex(this_1), rectToIndex(r), "when calling put in EventHelper, line 44")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function init_Character takes string w__wurst_stackPos returns boolean
	local integer clVar
	local player receiver
	local player receiver_1
	local integer clVar_1
	local trigger receiver_2
	local trigger receiver_3
	local trigger receiver_4
	local trigger receiver_5
	local integer clVar_2
	local playerunitevent temp
	local playerevent temp_1
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set Character_REVIVE_TIME = 5.
	set tuple_temp = Vectors_ZERO2_x
	set tuple_temp_1 = Vectors_ZERO2_y
	set Character_checkpoint_x = tuple_temp
	set Character_checkpoint_y = tuple_temp_1
	call FogEnableOff()
	call FogMaskEnableOff()
	set clVar = alloc_CallbackSingle_doAfter_Character("when calling alloc_CallbackSingle_doAfter_Character in Character, line 48")
	call construct_CallbackSingle(clVar)
	call doAfter(0., clVar, "when calling doAfter in Character, line 48")
	set Character_character = createCharacter("when calling createCharacter in Character, line 51")
	set receiver = unit_getOwner(Character_character)
	call player_select(receiver, Character_character)
	set receiver_1 = receiver
	call player_setCameraTargetControllerNoZ(receiver_1, Character_character, Vectors_ZERO2_x, Vectors_ZERO2_y, false)
	set temp = EVENT_PLAYER_UNIT_DEATH
	set clVar_1 = alloc_EventListener_add_Character("when calling alloc_EventListener_add_Character in Character, line 56")
	call construct_EventListener(clVar_1)
	call EventListener_add(temp, clVar_1, "when calling add in Character, line 56")
	set receiver_2 = CreateTrigger()
	call trigger_registerRectEnterEventSource(receiver_2, gg_rct_Finish, "when calling registerRectEnterEventSource in Character, line 72")
	set receiver_3 = receiver_2
	call trigger_addAction(receiver_3, ref_function_code__addAction_Character)
	set tuple_temp_2 = unit_getPos(Character_character)
	set tuple_temp_3 = unit_getPos_return_y
	set Character_checkpoint_x = tuple_temp_2
	set Character_checkpoint_y = tuple_temp_3
	set receiver_4 = CreateTrigger()
	call trigger_registerRectEnterEventSource(receiver_4, gg_rct_Checkpoint, "when calling registerRectEnterEventSource in Character, line 78")
	set receiver_5 = receiver_4
	call trigger_addAction(receiver_5, ref_function_code__addAction_Character_538)
	set temp_1 = ClosureEvents_EVENT_PLAYER_CHAT_FILTER
	set clVar_2 = alloc_EventListener_add_Character_462("when calling alloc_EventListener_add_Character in Character, line 85")
	call construct_EventListener(clVar_2)
	call EventListener_add(temp_1, clVar_2, "when calling add in Character, line 85")
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
	set receiver_3 = null
	set receiver_4 = null
	set receiver_5 = null
	set temp = null
	set temp_1 = null
	return true
endfunction

function bridge_init_Character takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Character("via function reference Character, line 1")
endfunction

function alloc_CallbackSingle_nullTimer_ClosureEvents takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this_1 = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this_1] = 655
		else
			call error("Out of memory: Could not create CallbackSingle_nullTimer_ClosureEvents.", "when calling error in ClosureEvents, line 294")
			set this_1 = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this_1 = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this_1] = 655
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_HashMap takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_firstFree == 0 then
		if Table_maxIndex < 32768 then
			set Table_maxIndex = Table_maxIndex + 1
			set this_1 = Table_maxIndex
			set Table_typeId[this_1] = 778
		else
			call error("Out of memory: Could not create HashMap.", "when calling error in HashMap, line 8")
			set this_1 = 0
		endif
	else
		set Table_firstFree = Table_firstFree - 1
		set this_1 = Table_nextFree[Table_firstFree]
		set Table_typeId[this_1] = 778
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function HashMap_init takes integer this_1 returns nothing
	set HashMap_size[this_1] = 0
endfunction

function Table_init takes integer this_1 returns nothing
endfunction

function construct_Table takes integer this_1 returns nothing
	call Table_init(this_1)
endfunction

function construct_HashMap takes integer this_1 returns nothing
	call construct_Table(this_1)
	call HashMap_init(this_1)
endfunction

function new_HashMap takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_HashMap("when calling alloc_HashMap in HashMap, line 7")
	call construct_HashMap(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function nullTimer takes integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = doAfter(0., cb, "when calling doAfter in ClosureTimers, line 33")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function onUnitDeindex takes code func returns nothing
	call trigger_addCondition(UnitIndexer_onDeindexTrigger, Condition(func))
endfunction

function onUnitIndex takes code func returns nothing
	call trigger_addCondition(UnitIndexer_onIndexTrigger, Condition(func))
endfunction

function init_ClosureEvents takes string w__wurst_stackPos returns boolean
	local integer clVar
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set ClosureEvents_EVENT_PLAYER_CHAT_FILTER = ConvertPlayerEvent(96)
	set EventListener_castMap = new_HashMap("when calling new_HashMap in ClosureEvents, line 99")
	set EventListener_castMapCasters = new_HashMap("when calling new_HashMap in ClosureEvents, line 100")
	set EventListener_useMouseEvents = false
	set ClosureEvents_unitTrig = CreateTrigger()
	set ClosureEvents_leaveTrig = CreateTrigger()
	set ClosureEvents_keyTrig = CreateTrigger()
	set ClosureEvents_eventTypeCounter = 0
	call onUnitIndex(ref_function_code__onUnitIndex_ClosureEvents)
	call onUnitDeindex(ref_function_bridge_code__onUnitDeindex_ClosureEvents)
	set clVar = alloc_CallbackSingle_nullTimer_ClosureEvents("when calling alloc_CallbackSingle_nullTimer_ClosureEvents in ClosureEvents, line 294")
	call construct_CallbackSingle(clVar)
	call nullTimer(clVar, "when calling nullTimer in ClosureEvents, line 294")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_ClosureEvents takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_ClosureEvents("via function reference ClosureEvents, line 1")
endfunction

function initializeTable takes string w__wurst_stackPos returns nothing
	local integer i
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set i = 0
	loop
		exitwhen i > 15
		call dispatch_Table_Table_Table_saveInt(Colors_decs, string_getHash(Colors_hexs[i]), i, "when calling saveInt in Colors, line 295")
		set i = i + 1
	endloop
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function alloc_Table takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_firstFree == 0 then
		if Table_maxIndex < 32768 then
			set Table_maxIndex = Table_maxIndex + 1
			set this_1 = Table_maxIndex
			set Table_typeId[this_1] = 777
		else
			call error("Out of memory: Could not create Table.", "when calling error in Table, line 7")
			set this_1 = 0
		endif
	else
		set Table_firstFree = Table_firstFree - 1
		set this_1 = Table_nextFree[Table_firstFree]
		set Table_typeId[this_1] = 777
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function new_Table takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Table("when calling alloc_Table in Table, line 6")
	call construct_Table(this_1)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_Colors takes string w__wurst_stackPos returns boolean
	local integer tuple_temp
	local integer tuple_temp_1
	local integer tuple_temp_2
	local integer tuple_temp_3
	local integer tuple_temp_4
	local integer tuple_temp_5
	local integer tuple_temp_6
	local integer tuple_temp_7
	local integer tuple_temp_8
	local integer tuple_temp_9
	local integer tuple_temp_10
	local integer tuple_temp_11
	local integer tuple_temp_12
	local integer tuple_temp_13
	local integer tuple_temp_14
	local integer tuple_temp_15
	local integer tuple_temp_16
	local integer tuple_temp_17
	local integer tuple_temp_18
	local integer tuple_temp_19
	local integer tuple_temp_20
	local integer tuple_temp_21
	local integer tuple_temp_22
	local integer tuple_temp_23
	local integer tuple_temp_24
	local integer tuple_temp_25
	local integer tuple_temp_26
	local integer tuple_temp_27
	local integer tuple_temp_28
	local integer tuple_temp_29
	local integer tuple_temp_30
	local integer tuple_temp_31
	local integer tuple_temp_32
	local integer tuple_temp_33
	local integer tuple_temp_34
	local integer tuple_temp_35
	local integer tuple_temp_36
	local integer tuple_temp_37
	local integer tuple_temp_38
	local integer tuple_temp_39
	local integer tuple_temp_40
	local integer tuple_temp_41
	local integer tuple_temp_42
	local integer tuple_temp_43
	local integer tuple_temp_44
	local integer tuple_temp_45
	local integer tuple_temp_46
	local integer tuple_temp_47
	local integer tuple_temp_48
	local integer tuple_temp_49
	local integer tuple_temp_50
	local integer tuple_temp_51
	local integer tuple_temp_52
	local integer tuple_temp_53
	local integer tuple_temp_54
	local integer tuple_temp_55
	local integer tuple_temp_56
	local integer tuple_temp_57
	local integer tuple_temp_58
	local integer tuple_temp_59
	local integer tuple_temp_60
	local integer tuple_temp_61
	local integer tuple_temp_62
	local integer tuple_temp_63
	local integer tuple_temp_64
	local integer tuple_temp_65
	local integer tuple_temp_66
	local integer tuple_temp_67
	local integer tuple_temp_68
	local integer tuple_temp_69
	local integer tuple_temp_70
	local integer tuple_temp_71
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set tuple_temp = 255
	set tuple_temp_1 = 2
	set tuple_temp_2 = 2
	set Colors_PLAYER_COLORS_red[0] = tuple_temp
	set Colors_PLAYER_COLORS_green[0] = tuple_temp_1
	set Colors_PLAYER_COLORS_blue[0] = tuple_temp_2
	set tuple_temp_3 = 0
	set tuple_temp_4 = 65
	set tuple_temp_5 = 255
	set Colors_PLAYER_COLORS_red[1] = tuple_temp_3
	set Colors_PLAYER_COLORS_green[1] = tuple_temp_4
	set Colors_PLAYER_COLORS_blue[1] = tuple_temp_5
	set tuple_temp_6 = 27
	set tuple_temp_7 = 229
	set tuple_temp_8 = 184
	set Colors_PLAYER_COLORS_red[2] = tuple_temp_6
	set Colors_PLAYER_COLORS_green[2] = tuple_temp_7
	set Colors_PLAYER_COLORS_blue[2] = tuple_temp_8
	set tuple_temp_9 = 83
	set tuple_temp_10 = 0
	set tuple_temp_11 = 128
	set Colors_PLAYER_COLORS_red[3] = tuple_temp_9
	set Colors_PLAYER_COLORS_green[3] = tuple_temp_10
	set Colors_PLAYER_COLORS_blue[3] = tuple_temp_11
	set tuple_temp_12 = 255
	set tuple_temp_13 = 252
	set tuple_temp_14 = 0
	set Colors_PLAYER_COLORS_red[4] = tuple_temp_12
	set Colors_PLAYER_COLORS_green[4] = tuple_temp_13
	set Colors_PLAYER_COLORS_blue[4] = tuple_temp_14
	set tuple_temp_15 = 254
	set tuple_temp_16 = 137
	set tuple_temp_17 = 13
	set Colors_PLAYER_COLORS_red[5] = tuple_temp_15
	set Colors_PLAYER_COLORS_green[5] = tuple_temp_16
	set Colors_PLAYER_COLORS_blue[5] = tuple_temp_17
	set tuple_temp_18 = 31
	set tuple_temp_19 = 191
	set tuple_temp_20 = 0
	set Colors_PLAYER_COLORS_red[6] = tuple_temp_18
	set Colors_PLAYER_COLORS_green[6] = tuple_temp_19
	set Colors_PLAYER_COLORS_blue[6] = tuple_temp_20
	set tuple_temp_21 = 228
	set tuple_temp_22 = 90
	set tuple_temp_23 = 175
	set Colors_PLAYER_COLORS_red[7] = tuple_temp_21
	set Colors_PLAYER_COLORS_green[7] = tuple_temp_22
	set Colors_PLAYER_COLORS_blue[7] = tuple_temp_23
	set tuple_temp_24 = 148
	set tuple_temp_25 = 149
	set tuple_temp_26 = 150
	set Colors_PLAYER_COLORS_red[8] = tuple_temp_24
	set Colors_PLAYER_COLORS_green[8] = tuple_temp_25
	set Colors_PLAYER_COLORS_blue[8] = tuple_temp_26
	set tuple_temp_27 = 125
	set tuple_temp_28 = 190
	set tuple_temp_29 = 241
	set Colors_PLAYER_COLORS_red[9] = tuple_temp_27
	set Colors_PLAYER_COLORS_green[9] = tuple_temp_28
	set Colors_PLAYER_COLORS_blue[9] = tuple_temp_29
	set tuple_temp_30 = 15
	set tuple_temp_31 = 97
	set tuple_temp_32 = 69
	set Colors_PLAYER_COLORS_red[10] = tuple_temp_30
	set Colors_PLAYER_COLORS_green[10] = tuple_temp_31
	set Colors_PLAYER_COLORS_blue[10] = tuple_temp_32
	set tuple_temp_33 = 77
	set tuple_temp_34 = 41
	set tuple_temp_35 = 3
	set Colors_PLAYER_COLORS_red[11] = tuple_temp_33
	set Colors_PLAYER_COLORS_green[11] = tuple_temp_34
	set Colors_PLAYER_COLORS_blue[11] = tuple_temp_35
	set tuple_temp_36 = 155
	set tuple_temp_37 = 0
	set tuple_temp_38 = 0
	set Colors_PLAYER_COLORS_red[12] = tuple_temp_36
	set Colors_PLAYER_COLORS_green[12] = tuple_temp_37
	set Colors_PLAYER_COLORS_blue[12] = tuple_temp_38
	set tuple_temp_39 = 0
	set tuple_temp_40 = 0
	set tuple_temp_41 = 195
	set Colors_PLAYER_COLORS_red[13] = tuple_temp_39
	set Colors_PLAYER_COLORS_green[13] = tuple_temp_40
	set Colors_PLAYER_COLORS_blue[13] = tuple_temp_41
	set tuple_temp_42 = 0
	set tuple_temp_43 = 234
	set tuple_temp_44 = 255
	set Colors_PLAYER_COLORS_red[14] = tuple_temp_42
	set Colors_PLAYER_COLORS_green[14] = tuple_temp_43
	set Colors_PLAYER_COLORS_blue[14] = tuple_temp_44
	set tuple_temp_45 = 190
	set tuple_temp_46 = 0
	set tuple_temp_47 = 254
	set Colors_PLAYER_COLORS_red[15] = tuple_temp_45
	set Colors_PLAYER_COLORS_green[15] = tuple_temp_46
	set Colors_PLAYER_COLORS_blue[15] = tuple_temp_47
	set tuple_temp_48 = 235
	set tuple_temp_49 = 205
	set tuple_temp_50 = 135
	set Colors_PLAYER_COLORS_red[16] = tuple_temp_48
	set Colors_PLAYER_COLORS_green[16] = tuple_temp_49
	set Colors_PLAYER_COLORS_blue[16] = tuple_temp_50
	set tuple_temp_51 = 248
	set tuple_temp_52 = 164
	set tuple_temp_53 = 139
	set Colors_PLAYER_COLORS_red[17] = tuple_temp_51
	set Colors_PLAYER_COLORS_green[17] = tuple_temp_52
	set Colors_PLAYER_COLORS_blue[17] = tuple_temp_53
	set tuple_temp_54 = 191
	set tuple_temp_55 = 255
	set tuple_temp_56 = 128
	set Colors_PLAYER_COLORS_red[18] = tuple_temp_54
	set Colors_PLAYER_COLORS_green[18] = tuple_temp_55
	set Colors_PLAYER_COLORS_blue[18] = tuple_temp_56
	set tuple_temp_57 = 220
	set tuple_temp_58 = 185
	set tuple_temp_59 = 235
	set Colors_PLAYER_COLORS_red[19] = tuple_temp_57
	set Colors_PLAYER_COLORS_green[19] = tuple_temp_58
	set Colors_PLAYER_COLORS_blue[19] = tuple_temp_59
	set tuple_temp_60 = 40
	set tuple_temp_61 = 40
	set tuple_temp_62 = 40
	set Colors_PLAYER_COLORS_red[20] = tuple_temp_60
	set Colors_PLAYER_COLORS_green[20] = tuple_temp_61
	set Colors_PLAYER_COLORS_blue[20] = tuple_temp_62
	set tuple_temp_63 = 235
	set tuple_temp_64 = 240
	set tuple_temp_65 = 255
	set Colors_PLAYER_COLORS_red[21] = tuple_temp_63
	set Colors_PLAYER_COLORS_green[21] = tuple_temp_64
	set Colors_PLAYER_COLORS_blue[21] = tuple_temp_65
	set tuple_temp_66 = 0
	set tuple_temp_67 = 120
	set tuple_temp_68 = 30
	set Colors_PLAYER_COLORS_red[22] = tuple_temp_66
	set Colors_PLAYER_COLORS_green[22] = tuple_temp_67
	set Colors_PLAYER_COLORS_blue[22] = tuple_temp_68
	set tuple_temp_69 = 164
	set tuple_temp_70 = 111
	set tuple_temp_71 = 51
	set Colors_PLAYER_COLORS_red[23] = tuple_temp_69
	set Colors_PLAYER_COLORS_green[23] = tuple_temp_70
	set Colors_PLAYER_COLORS_blue[23] = tuple_temp_71
	set Colors_hexs[0] = "0"
	set Colors_hexs[1] = "1"
	set Colors_hexs[2] = "2"
	set Colors_hexs[3] = "3"
	set Colors_hexs[4] = "4"
	set Colors_hexs[5] = "5"
	set Colors_hexs[6] = "6"
	set Colors_hexs[7] = "7"
	set Colors_hexs[8] = "8"
	set Colors_hexs[9] = "9"
	set Colors_hexs[10] = "A"
	set Colors_hexs[11] = "B"
	set Colors_hexs[12] = "C"
	set Colors_hexs[13] = "D"
	set Colors_hexs[14] = "E"
	set Colors_hexs[15] = "F"
	set Colors_decs = new_Table("when calling new_Table in Colors, line 226")
	call initializeTable("when calling initializeTable in Colors, line 298")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_Colors takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Colors("via function reference Colors, line 1")
endfunction

function init_EventHelper takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set EventHelper_rectMap = new_HashMap("when calling new_HashMap in EventHelper, line 7")
	call new_HashMap("when calling new_HashMap in EventHelper, line 8")
	call new_Table("when calling new_Table in EventHelper, line 9")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_EventHelper takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_EventHelper("via function reference EventHelper, line 1")
endfunction

function verifyFrameNameLength takes string name, string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if string_length(name) > Framehandle_BLZ_FRAMENAME_MAXLENGTH then
		call error("Trying to address frame with exceeding maximum frame name length (" + int_toString(Framehandle_BLZ_FRAMENAME_MAXLENGTH) + ") for: " + name, "when calling error in Framehandle, line 78")
		set wurst_stack_depth = wurst_stack_depth - 1
		return false
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function createFrame takes string typeName, string name, framehandle owner, string inherits, integer createContext, string w__wurst_stackPos returns framehandle
	local framehandle stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call verifyFrameNameLength(name, "when calling verifyFrameNameLength in Framehandle, line 144")
	set stackTrace_tempReturn = BlzCreateFrameByType(typeName, name, owner, inherits, createContext)
	set wurst_stack_depth = wurst_stack_depth - 1
	set createFrametempReturn = stackTrace_tempReturn
	set stackTrace_tempReturn = null
	return createFrametempReturn
endfunction

function framehandle_setSize takes framehandle this_1, real width, real height returns nothing
	call BlzFrameSetSize(this_1, width, height)
endfunction

function init_Framehandle takes string w__wurst_stackPos returns boolean
	local framehandle receiver
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set Framehandle_GAME_UI = BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0)
	call BlzGetOriginFrame(ORIGIN_FRAME_WORLD_FRAME, 0)
	set tuple_temp = 0.4
	set tuple_temp_1 = 0.6
	set Framehandle_SCREEN_TOP_x = tuple_temp
	set Framehandle_SCREEN_TOP_y = tuple_temp_1
	set tuple_temp_2 = 0.4
	set tuple_temp_3 = 0.0
	set Framehandle_SCREEN_BOTTOM_x = tuple_temp_2
	set Framehandle_SCREEN_BOTTOM_y = tuple_temp_3
	set Framehandle_BLZ_FRAMENAME_MAXLENGTH = 560
	set receiver = createFrame("FRAME", "SetMousePositionCage", Framehandle_GAME_UI, null, 0, "when calling createFrame in Framehandle, line 483")
	call framehandle_setSize(receiver, 0.0001, 0.0001)
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	return true
endfunction

function bridge_init_Framehandle takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Framehandle("via function reference Framehandle, line 1")
endfunction

function alloc_Comparator_LinkedList takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Comparator_firstFree == 0 then
		if Comparator_maxIndex < 32768 then
			set Comparator_maxIndex = Comparator_maxIndex + 1
			set this_1 = Comparator_maxIndex
		else
			call error("Out of memory: Could not create Comparator_LinkedList.", "when calling error in LinkedList, line 539")
			set this_1 = 0
		endif
	else
		set Comparator_firstFree = Comparator_firstFree - 1
		set this_1 = Comparator_nextFree[Comparator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_Comparator_LinkedList_460 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Comparator_firstFree == 0 then
		if Comparator_maxIndex < 32768 then
			set Comparator_maxIndex = Comparator_maxIndex + 1
			set this_1 = Comparator_maxIndex
		else
			call error("Out of memory: Could not create Comparator_LinkedList.", "when calling error in LinkedList, line 543")
			set this_1 = 0
		endif
	else
		set Comparator_firstFree = Comparator_firstFree - 1
		set this_1 = Comparator_nextFree[Comparator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function realToIndex takes real r returns integer
	return real_toInt(r * TypeCasting_R2I_PRECISION)
endfunction

function init_LinkedList takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call alloc_Comparator_LinkedList("when calling alloc_Comparator_LinkedList in LinkedList, line 539")
	call alloc_Comparator_LinkedList_460("when calling alloc_Comparator_LinkedList in LinkedList, line 543")
	call realToIndex(0.)
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_LinkedList takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_LinkedList("via function reference LinkedList, line 1")
endfunction

function alloc_BackIterator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if BackIterator_firstFree == 0 then
		if BackIterator_maxIndex < 32768 then
			set BackIterator_maxIndex = BackIterator_maxIndex + 1
			set this_1 = BackIterator_maxIndex
		else
			call error("Out of memory: Could not create BackIterator.", "when calling error in LinkedListModule, line 93")
			set this_1 = 0
		endif
	else
		set BackIterator_firstFree = BackIterator_firstFree - 1
		set this_1 = BackIterator_nextFree[BackIterator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function BackIterator_init takes integer this_1 returns nothing
endfunction

function construct_BackIterator takes integer this_1, boolean destroyOnClose returns nothing
	call BackIterator_init(this_1)
endfunction

function new_BackIterator takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_BackIterator("when calling alloc_BackIterator in LinkedListModule, line 97")
	call construct_BackIterator(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_Iterator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_firstFree == 0 then
		if Iterator_maxIndex < 32768 then
			set Iterator_maxIndex = Iterator_maxIndex + 1
			set this_1 = Iterator_maxIndex
		else
			call error("Out of memory: Could not create Iterator.", "when calling error in LinkedListModule, line 71")
			set this_1 = 0
		endif
	else
		set Iterator_firstFree = Iterator_firstFree - 1
		set this_1 = Iterator_nextFree[Iterator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function Iterator_init takes integer this_1 returns nothing
endfunction

function construct_Iterator takes integer this_1, boolean destroyOnClose returns nothing
	call Iterator_init(this_1)
endfunction

function new_Iterator takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Iterator("when calling alloc_Iterator in LinkedListModule, line 75")
	call construct_Iterator(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_Missile takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set Missile_LinkedListModule_first = 0
	call new_Iterator(false, "when calling new_Iterator in LinkedListModule, line 55")
	call new_BackIterator(false, "when calling new_BackIterator in LinkedListModule, line 65")
	call CreateTimer()
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_Missile takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Missile("via function reference Missile, line 1")
endfunction

function alloc_IdGenerator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if IdGenerator_firstFree == 0 then
		if IdGenerator_maxIndex < 32768 then
			set IdGenerator_maxIndex = IdGenerator_maxIndex + 1
			set this_1 = IdGenerator_maxIndex
		else
			call error("Out of memory: Could not create IdGenerator.", "when calling error in ObjectIdGenerator, line 13")
			set this_1 = 0
		endif
	else
		set IdGenerator_firstFree = IdGenerator_firstFree - 1
		set this_1 = IdGenerator_nextFree[IdGenerator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function IdGenerator_init takes integer this_1 returns nothing
endfunction

function construct_IdGenerator takes integer this_1, integer start returns nothing
	call IdGenerator_init(this_1)
endfunction

function new_IdGenerator takes integer start, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_IdGenerator("when calling alloc_IdGenerator in ObjectIdGenerator, line 19")
	call construct_IdGenerator(this_1, start)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_ObjectIdGenerator takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call new_IdGenerator(2016423984, "when calling new_IdGenerator in ObjectIdGenerator, line 6")
	call new_IdGenerator(1213018160, "when calling new_IdGenerator in ObjectIdGenerator, line 7")
	call new_IdGenerator(1095577648, "when calling new_IdGenerator in ObjectIdGenerator, line 8")
	call new_IdGenerator(1112354864, "when calling new_IdGenerator in ObjectIdGenerator, line 9")
	call new_IdGenerator(1229795376, "when calling new_IdGenerator in ObjectIdGenerator, line 10")
	call new_IdGenerator(1380790320, "when calling new_IdGenerator in ObjectIdGenerator, line 11")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_ObjectIdGenerator takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_ObjectIdGenerator("via function reference ObjectIdGenerator, line 1")
endfunction

function alloc_CallbackSingle_nullTimer_OnUnitEnterLeave takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this_1 = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this_1] = 656
		else
			call error("Out of memory: Could not create CallbackSingle_nullTimer_OnUnitEnterLeave.", "when calling error in OnUnitEnterLeave, line 64")
			set this_1 = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this_1 = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this_1] = 656
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function player_setAbilityAvailable takes player this_1, integer abilityId, boolean avail returns nothing
	call SetPlayerAbilityAvailable(this_1, abilityId, avail)
endfunction

function init_OnUnitEnterLeave takes string w__wurst_stackPos returns boolean
	local integer i
	local integer temp
	local integer clVar
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set OnUnitEnterLeave_eventTrigger = CreateTrigger()
	set OnUnitEnterLeave_preplacedUnits = CreateGroup()
	set OnUnitEnterLeave_tempUnitsCount = 0
	set OnUnitEnterLeave_ABILITY_ID = 1095577649
	set i = 0
	set temp = bj_MAX_PLAYER_SLOTS - 1
	loop
		exitwhen i > temp
		call player_setAbilityAvailable(Player_players[i], OnUnitEnterLeave_ABILITY_ID, false)
		set i = i + 1
	endloop
	set clVar = alloc_CallbackSingle_nullTimer_OnUnitEnterLeave("when calling alloc_CallbackSingle_nullTimer_OnUnitEnterLeave in OnUnitEnterLeave, line 64")
	call construct_CallbackSingle(clVar)
	call nullTimer(clVar, "when calling nullTimer in OnUnitEnterLeave, line 64")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_OnUnitEnterLeave takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_OnUnitEnterLeave("via function reference OnUnitEnterLeave, line 1")
endfunction

function alloc_CallbackSingle_nullTimer_Preloader takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this_1 = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this_1] = 657
		else
			call error("Out of memory: Could not create CallbackSingle_nullTimer_Preloader.", "when calling error in Preloader, line 58")
			set this_1 = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this_1 = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this_1] = 657
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function unit_setInvulnerable takes unit this_1, boolean flag returns nothing
	call SetUnitInvulnerable(this_1, flag)
endfunction

function init_Preloader takes string w__wurst_stackPos returns boolean
	local integer clVar
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set Preloader_autoFinish = true
	set Preloader_dumg = CreateGroup()
	set Preloader_dum = createUnit(Basics_DUMMY_PLAYER, UnitIds_shade, MapBounds_playableMin_x, MapBounds_playableMin_y, 0.)
	call unit_setInvulnerable(Preloader_dum, true)
	if Preloader_dum == null then
		call error("DUMMY_UNITID not added correctly to the map.", "when calling error in Preloader, line 56")
	endif
	if Preloader_autoFinish then
		set clVar = alloc_CallbackSingle_nullTimer_Preloader("when calling alloc_CallbackSingle_nullTimer_Preloader in Preloader, line 58")
		call construct_CallbackSingle(clVar)
		call nullTimer(clVar, "when calling nullTimer in Preloader, line 58")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_Preloader takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Preloader("via function reference Preloader, line 1")
endfunction

function alloc_CallbackPeriodic_doPeriodically_Razor takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackPeriodic_firstFree == 0 then
		if CallbackPeriodic_maxIndex < 32768 then
			set CallbackPeriodic_maxIndex = CallbackPeriodic_maxIndex + 1
			set this_1 = CallbackPeriodic_maxIndex
			set CallbackPeriodic_typeId[this_1] = 646
		else
			call error("Out of memory: Could not create CallbackPeriodic_doPeriodically_Razor.", "when calling error in Razor, line 83")
			set this_1 = 0
		endif
	else
		set CallbackPeriodic_firstFree = CallbackPeriodic_firstFree - 1
		set this_1 = CallbackPeriodic_nextFree[CallbackPeriodic_firstFree]
		set CallbackPeriodic_typeId[this_1] = 646
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function CallbackPeriodic_init takes integer this_1 returns nothing
endfunction

function construct_CallbackPeriodic takes integer this_1 returns nothing
	call CallbackPeriodic_init(this_1)
endfunction

function CallbackPeriodic_start takes integer this_1, timer whichTimer, real time, string w__wurst_stackPos returns nothing
	local timer receiver
	local timer receiver_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set receiver = whichTimer
	call timer_setData(receiver, this_1, "when calling setData in ClosureTimers, line 134")
	set receiver_1 = receiver
	call timer_startPeriodic(receiver_1, time, ref_function_bridge_CallbackPeriodic_staticCallback)
	set CallbackPeriodic_t[this_1] = receiver_1
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
endfunction

function dispatch_CallbackPeriodic_ClosureTimers_CallbackPeriodic_start takes integer this_1, timer whichTimer, real time, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackPeriodic_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling CallbackPeriodic.start", "when calling error in ClosureTimers, line 132")
		else
			call error("Called CallbackPeriodic.start on invalid object.", "when calling error in ClosureTimers, line 132")
		endif
	endif
	call CallbackPeriodic_start(this_1, whichTimer, time, "when calling start in ClosureTimers, line 132")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_doPeriodically takes timer this_1, real time, integer cb, string w__wurst_stackPos returns integer
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_CallbackPeriodic_ClosureTimers_CallbackPeriodic_start(cb, this_1, time, "when calling start in ClosureTimers, line 45")
	set wurst_stack_depth = wurst_stack_depth - 1
	return cb
endfunction

function doPeriodically takes real time, integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = timer_doPeriodically(getTimer("when calling getTimer in ClosureTimers, line 57"), time, cb, "when calling doPeriodically in ClosureTimers, line 57")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function alloc_BackIterator_447 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if BackIterator_firstFree_7 == 0 then
		if BackIterator_maxIndex_11 < 32768 then
			set BackIterator_maxIndex_11 = BackIterator_maxIndex_11 + 1
			set this_1 = BackIterator_maxIndex_11
		else
			call error("Out of memory: Could not create BackIterator.", "when calling error in LinkedListModule, line 93")
			set this_1 = 0
		endif
	else
		set BackIterator_firstFree_7 = BackIterator_firstFree_7 - 1
		set this_1 = BackIterator_nextFree_15[BackIterator_firstFree_7]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function BackIterator_init_7 takes integer this_1 returns nothing
endfunction

function construct_BackIterator_566 takes integer this_1, boolean destroyOnClose returns nothing
	call BackIterator_init_7(this_1)
endfunction

function new_BackIterator_843 takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_BackIterator_447("when calling alloc_BackIterator in LinkedListModule, line 97")
	call construct_BackIterator_566(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_Iterator_474 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_firstFree_160 == 0 then
		if Iterator_maxIndex_164 < 32768 then
			set Iterator_maxIndex_164 = Iterator_maxIndex_164 + 1
			set this_1 = Iterator_maxIndex_164
		else
			call error("Out of memory: Could not create Iterator.", "when calling error in LinkedListModule, line 71")
			set this_1 = 0
		endif
	else
		set Iterator_firstFree_160 = Iterator_firstFree_160 - 1
		set this_1 = Iterator_nextFree_168[Iterator_firstFree_160]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function Iterator_init_247 takes integer this_1 returns nothing
endfunction

function construct_Iterator_578 takes integer this_1, boolean destroyOnClose returns nothing
	call Iterator_init_247(this_1)
endfunction

function new_Iterator_850 takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Iterator_474("when calling alloc_Iterator in LinkedListModule, line 75")
	call construct_Iterator_578(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_Razor takes string w__wurst_stackPos returns boolean
	local integer choice_1
	local integer cond_result
	local integer clVar
	local real temp
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set tuple_temp = rect_getCenter(gg_rct_RazorStart)
	set tuple_temp_1 = rect_getCenter_return_y
	set Razor_START_POS_x = tuple_temp
	set Razor_START_POS_y = tuple_temp_1
	set tuple_temp_2 = rect_getCenter(gg_rct_RazorFinish)
	set tuple_temp_3 = rect_getCenter_return_y
	set Razor_FINISH_POS_x = tuple_temp_2
	set Razor_FINISH_POS_y = tuple_temp_3
	set Razor_WIDTH = 1500.
	set Razor_SPEED = 750.
	set Razor_LinkedListModule_first = 0
	set Razor_LinkedListModule_last = 0
	set Razor_LinkedListModule_size = 0
	call new_Iterator_850(false, "when calling new_Iterator in LinkedListModule, line 55")
	call new_BackIterator_843(false, "when calling new_BackIterator in LinkedListModule, line 65")
	if GetRandomInt(0, 1) == 1 then
		set cond_result = 1
	else
		set cond_result = -1
	endif
	set choice_1 = cond_result
	set temp = GetRandomReal(3.5, 4.5)
	set clVar = alloc_CallbackPeriodic_doPeriodically_Razor("when calling alloc_CallbackPeriodic_doPeriodically_Razor in Razor, line 83")
	call construct_CallbackPeriodic(clVar)
	set choice[clVar] = choice_1
	call doPeriodically(temp, clVar, "when calling doPeriodically in Razor, line 83")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_Razor takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Razor("via function reference Razor, line 1")
endfunction

function init_RegisterEvents takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set RegisterEvents_onCastMap = new_HashMap("when calling new_HashMap in RegisterEvents, line 55")
	call registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT, ref_function_bridge_code__registerPlayerUnitEvent_RegisterEvents)
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_RegisterEvents takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_RegisterEvents("via function reference RegisterEvents, line 1")
endfunction

function alloc_ForGroupCallbackD_forDestructablesInRect_Segment takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallbackD_firstFree == 0 then
		if ForGroupCallbackD_maxIndex < 32768 then
			set ForGroupCallbackD_maxIndex = ForGroupCallbackD_maxIndex + 1
			set this_1 = ForGroupCallbackD_maxIndex
			set ForGroupCallbackD_typeId[this_1] = 677
		else
			call error("Out of memory: Could not create ForGroupCallbackD_forDestructablesInRect_Segment.", "when calling error in Segment, line 58")
			set this_1 = 0
		endif
	else
		set ForGroupCallbackD_firstFree = ForGroupCallbackD_firstFree - 1
		set this_1 = ForGroupCallbackD_nextFree[ForGroupCallbackD_firstFree]
		set ForGroupCallbackD_typeId[this_1] = 677
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function dealloc_ForGroupCallbackD takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallbackD_typeId[obj] == 0 then
		call error("Double free: object of type ForGroupCallbackD", "when calling error in ClosureForGroups, line 148")
	else
		set ForGroupCallbackD_nextFree[ForGroupCallbackD_firstFree] = obj
		set ForGroupCallbackD_firstFree = ForGroupCallbackD_firstFree + 1
		set ForGroupCallbackD_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyForGroupCallbackD takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dealloc_ForGroupCallbackD(this_1, "when calling dealloc_ForGroupCallbackD in ClosureForGroups, line 148")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_ForGroupCallbackD_destroyForGroupCallbackD takes integer this_1, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallbackD_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling ForGroupCallbackD.ForGroupCallbackD", "when calling error in ClosureForGroups, line 148")
		else
			call error("Called ForGroupCallbackD.ForGroupCallbackD on invalid object.", "when calling error in ClosureForGroups, line 148")
		endif
	endif
	call destroyForGroupCallbackD(this_1, "when calling destroyForGroupCallbackD in ClosureForGroups, line 148")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function popCallbackD takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set ClosureForGroups_tempCallbacksDCount = ClosureForGroups_tempCallbacksDCount - 1
	call dispatch_ForGroupCallbackD_destroyForGroupCallbackD(ClosureForGroups_tempCallbacksD[ClosureForGroups_tempCallbacksDCount], "when calling dispatch_ForGroupCallbackD_destroyForGroupCallbackD in ClosureForGroups, line 164")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function pushCallbackD takes integer c returns nothing
	set ClosureForGroups_tempCallbacksD[ClosureForGroups_tempCallbacksDCount] = c
	set ClosureForGroups_tempCallbacksDCount = ClosureForGroups_tempCallbacksDCount + 1
endfunction

function forDestructablesInRect_737 takes rect r, boolexpr filter, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call pushCallbackD(cb)
	call EnumDestructablesInRect(r, filter, ref_function_bridge_code__EnumDestructablesInRect_ClosureForGroups)
	call popCallbackD("when calling popCallbackD in ClosureForGroups, line 191")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function forDestructablesInRect takes rect r, integer cb, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call forDestructablesInRect_737(r, null, cb, "when calling forDestructablesInRect in ClosureForGroups, line 185")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function alloc_BackIterator_448 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if BackIterator_firstFree_8 == 0 then
		if BackIterator_maxIndex_12 < 32768 then
			set BackIterator_maxIndex_12 = BackIterator_maxIndex_12 + 1
			set this_1 = BackIterator_maxIndex_12
		else
			call error("Out of memory: Could not create BackIterator.", "when calling error in LinkedListModule, line 93")
			set this_1 = 0
		endif
	else
		set BackIterator_firstFree_8 = BackIterator_firstFree_8 - 1
		set this_1 = BackIterator_nextFree_16[BackIterator_firstFree_8]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function BackIterator_init_8 takes integer this_1 returns nothing
endfunction

function construct_BackIterator_567 takes integer this_1, boolean destroyOnClose returns nothing
	call BackIterator_init_8(this_1)
endfunction

function new_BackIterator_844 takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_BackIterator_448("when calling alloc_BackIterator in LinkedListModule, line 97")
	call construct_BackIterator_567(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_Segment takes string w__wurst_stackPos returns boolean
	local timer receiver
	local real angularVelocity_radians_1
	local integer clVar
	local rect temp
	local real tuple_temp
	local real tuple_temp_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set Segment_LinkedListModule_first = 0
	set Segment_LinkedListModule_last = 0
	set Segment_LinkedListModule_size = 0
	call new_Iterator_851(false, "when calling new_Iterator in LinkedListModule, line 55")
	call new_BackIterator_844(false, "when calling new_BackIterator in LinkedListModule, line 65")
	set Segment_lightType = Lightning_LIGHTNING_DRAIN
	set Segment_touchEffect = "Abilities\\Weapons\\GreenDragonMissile\\GreenDragonMissile.mdl"
	set receiver = CreateTimer()
	call timer_startPeriodic(receiver, 0.02, ref_function_bridge_Segment_updateAll)
	set Segment_clock = receiver
	set tuple_temp = real_asAngleDegrees(45.)
	set angularVelocity_radians_1 = tuple_temp
	set temp = MapBounds_playableMapRect
	set clVar = alloc_ForGroupCallbackD_forDestructablesInRect_Segment("when calling alloc_ForGroupCallbackD_forDestructablesInRect_Segment in Segment, line 58")
	set tuple_temp_1 = angularVelocity_radians_1
	set angularVelocity_radians[clVar] = tuple_temp_1
	call forDestructablesInRect(temp, clVar, "when calling forDestructablesInRect in Segment, line 58")
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set temp = null
	return true
endfunction

function bridge_init_Segment takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Segment("via function reference Segment, line 1")
endfunction

function EventListener_addSpellInternal takes unit u, integer abilId, integer listener, string w__wurst_stackPos returns integer
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set OnCastListener_abilId[listener] = abilId
	if u != null then
		set OnCastListener_eventUnit[listener] = u
		if dispatch_HashMap_HashMap_HashMap_has(EventListener_castMapCasters, unitToIndex(u), "when calling has in ClosureEvents, line 158") then
			set OnCastListener_prev[dispatch_HashMap_HashMap_HashMap_get(EventListener_castMapCasters, unitToIndex(u), "when calling get in ClosureEvents, line 159")] = listener
			set OnCastListener_next[listener] = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMapCasters, unitToIndex(u), "when calling get in ClosureEvents, line 160")
		endif
		call dispatch_HashMap_HashMap_HashMap_put(EventListener_castMapCasters, unitToIndex(u), listener, "when calling put in ClosureEvents, line 161")
	else
		if dispatch_HashMap_HashMap_HashMap_has(EventListener_castMap, abilId, "when calling has in ClosureEvents, line 163") then
			set OnCastListener_prev[dispatch_HashMap_HashMap_HashMap_get(EventListener_castMap, abilId, "when calling get in ClosureEvents, line 164")] = listener
			set OnCastListener_next[listener] = dispatch_HashMap_HashMap_HashMap_get(EventListener_castMap, abilId, "when calling get in ClosureEvents, line 165")
		endif
		call dispatch_HashMap_HashMap_HashMap_put(EventListener_castMap, abilId, listener, "when calling put in ClosureEvents, line 167")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return listener
endfunction

function EventListener_onCast takes integer abilId, integer listener, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = EventListener_addSpellInternal(null, abilId, listener, "when calling addSpellInternal in ClosureEvents, line 143")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function alloc_EventListener_add_ShieldGenerator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_firstFree == 0 then
		if EventListener_maxIndex < 32768 then
			set EventListener_maxIndex = EventListener_maxIndex + 1
			set this_1 = EventListener_maxIndex
			set EventListener_typeId[this_1] = 666
		else
			call error("Out of memory: Could not create EventListener_add_ShieldGenerator.", "when calling error in ShieldGenerator, line 140")
			set this_1 = 0
		endif
	else
		set EventListener_firstFree = EventListener_firstFree - 1
		set this_1 = EventListener_nextFree[EventListener_firstFree]
		set EventListener_typeId[this_1] = 666
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_EventListener_add_ShieldGenerator_464 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if EventListener_firstFree == 0 then
		if EventListener_maxIndex < 32768 then
			set EventListener_maxIndex = EventListener_maxIndex + 1
			set this_1 = EventListener_maxIndex
			set EventListener_typeId[this_1] = 667
		else
			call error("Out of memory: Could not create EventListener_add_ShieldGenerator.", "when calling error in ShieldGenerator, line 144")
			set this_1 = 0
		endif
	else
		set EventListener_firstFree = EventListener_firstFree - 1
		set this_1 = EventListener_nextFree[EventListener_firstFree]
		set EventListener_typeId[this_1] = 667
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_OnCastListener_onCast_ShieldGenerator takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if OnCastListener_firstFree == 0 then
		if OnCastListener_maxIndex < 32768 then
			set OnCastListener_maxIndex = OnCastListener_maxIndex + 1
			set this_1 = OnCastListener_maxIndex
			set OnCastListener_typeId[this_1] = 747
		else
			call error("Out of memory: Could not create OnCastListener_onCast_ShieldGenerator.", "when calling error in ShieldGenerator, line 149")
			set this_1 = 0
		endif
	else
		set OnCastListener_firstFree = OnCastListener_firstFree - 1
		set this_1 = OnCastListener_nextFree[OnCastListener_firstFree]
		set OnCastListener_typeId[this_1] = 747
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function OnCastListener_init takes integer this_1 returns nothing
	set OnCastListener_next[this_1] = 0
	set OnCastListener_prev[this_1] = 0
	set OnCastListener_eventUnit[this_1] = null
endfunction

function construct_OnCastListener takes integer this_1 returns nothing
	call OnCastListener_init(this_1)
endfunction

function createItem_601 takes integer itemId, real pos_x, real pos_y, real pos_z returns item
	return CreateItem(itemId, pos_x, pos_y)
endfunction

function createItem takes integer itemId, real pos_x, real pos_y returns item
	return createItem_601(itemId, vec2_toVec3(pos_x, pos_y), vec2_toVec3_return_y, vec2_toVec3_return_z)
endfunction

function alloc_BackIterator_449 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if BackIterator_firstFree_9 == 0 then
		if BackIterator_maxIndex_13 < 32768 then
			set BackIterator_maxIndex_13 = BackIterator_maxIndex_13 + 1
			set this_1 = BackIterator_maxIndex_13
		else
			call error("Out of memory: Could not create BackIterator.", "when calling error in LinkedListModule, line 93")
			set this_1 = 0
		endif
	else
		set BackIterator_firstFree_9 = BackIterator_firstFree_9 - 1
		set this_1 = BackIterator_nextFree_17[BackIterator_firstFree_9]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function BackIterator_init_9 takes integer this_1 returns nothing
endfunction

function construct_BackIterator_568 takes integer this_1, boolean destroyOnClose returns nothing
	call BackIterator_init_9(this_1)
endfunction

function new_BackIterator_845 takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_BackIterator_449("when calling alloc_BackIterator in LinkedListModule, line 97")
	call construct_BackIterator_568(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function alloc_Iterator_476 takes string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Iterator_firstFree_162 == 0 then
		if Iterator_maxIndex_166 < 32768 then
			set Iterator_maxIndex_166 = Iterator_maxIndex_166 + 1
			set this_1 = Iterator_maxIndex_166
		else
			call error("Out of memory: Could not create Iterator.", "when calling error in LinkedListModule, line 71")
			set this_1 = 0
		endif
	else
		set Iterator_firstFree_162 = Iterator_firstFree_162 - 1
		set this_1 = Iterator_nextFree_170[Iterator_firstFree_162]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function Iterator_init_249 takes integer this_1 returns nothing
endfunction

function construct_Iterator_580 takes integer this_1, boolean destroyOnClose returns nothing
	call Iterator_init_249(this_1)
endfunction

function new_Iterator_852 takes boolean destroyOnClose, string w__wurst_stackPos returns integer
	local integer this_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this_1 = alloc_Iterator_476("when calling alloc_Iterator in LinkedListModule, line 75")
	call construct_Iterator_580(this_1, destroyOnClose)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this_1
endfunction

function init_ShieldGenerator takes string w__wurst_stackPos returns boolean
	local integer clVar
	local integer clVar_1
	local integer eventCb
	local integer clVar_2
	local playerunitevent temp
	local playerunitevent temp_1
	local integer temp_2
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	local real tuple_temp_8
	local real tuple_temp_9
	local real tuple_temp_10
	local real tuple_temp_11
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set ShieldGenerator_ITEM_ID = 1229795377
	set ShieldGenerator_FRONT_SHIELD_ID = 1095577651
	set ShieldGenerator_ABOVE_SHIELD_ID = 1095577652
	set tuple_temp = 150.
	set tuple_temp_1 = 150.
	set tuple_temp_2 = 500.
	set ShieldGenerator_ABOVE_SHIELD_POINTS_x[0] = tuple_temp
	set ShieldGenerator_ABOVE_SHIELD_POINTS_y[0] = tuple_temp_1
	set ShieldGenerator_ABOVE_SHIELD_POINTS_z[0] = tuple_temp_2
	set tuple_temp_3 = -150.
	set tuple_temp_4 = -150.
	set tuple_temp_5 = 500.
	set ShieldGenerator_ABOVE_SHIELD_POINTS_x[1] = tuple_temp_3
	set ShieldGenerator_ABOVE_SHIELD_POINTS_y[1] = tuple_temp_4
	set ShieldGenerator_ABOVE_SHIELD_POINTS_z[1] = tuple_temp_5
	set tuple_temp_6 = 250.
	set tuple_temp_7 = 200.
	set tuple_temp_8 = 0.
	set ShieldGenerator_FRONT_SHIELD_POINTS_x[0] = tuple_temp_6
	set ShieldGenerator_FRONT_SHIELD_POINTS_y[0] = tuple_temp_7
	set ShieldGenerator_FRONT_SHIELD_POINTS_z[0] = tuple_temp_8
	set tuple_temp_9 = 250.
	set tuple_temp_10 = -200.
	set tuple_temp_11 = 250.
	set ShieldGenerator_FRONT_SHIELD_POINTS_x[1] = tuple_temp_9
	set ShieldGenerator_FRONT_SHIELD_POINTS_y[1] = tuple_temp_10
	set ShieldGenerator_FRONT_SHIELD_POINTS_z[1] = tuple_temp_11
	set Shield_LinkedListModule_first = 0
	set Shield_LinkedListModule_last = 0
	set Shield_LinkedListModule_size = 0
	call new_Iterator_852(false, "when calling new_Iterator in LinkedListModule, line 55")
	call new_BackIterator_845(false, "when calling new_BackIterator in LinkedListModule, line 65")
	call createItem(ShieldGenerator_ITEM_ID, rect_getCenter(gg_rct_ShieldGeneratorSpawn), rect_getCenter_return_y)
	set temp = EVENT_PLAYER_UNIT_PICKUP_ITEM
	set clVar = alloc_EventListener_add_ShieldGenerator("when calling alloc_EventListener_add_ShieldGenerator in ShieldGenerator, line 140")
	call construct_EventListener(clVar)
	call EventListener_add(temp, clVar, "when calling add in ShieldGenerator, line 140")
	set temp_1 = EVENT_PLAYER_UNIT_DROP_ITEM
	set clVar_1 = alloc_EventListener_add_ShieldGenerator_464("when calling alloc_EventListener_add_ShieldGenerator in ShieldGenerator, line 144")
	call construct_EventListener(clVar_1)
	call EventListener_add(temp_1, clVar_1, "when calling add in ShieldGenerator, line 144")
	set temp_2 = ShieldGenerator_FRONT_SHIELD_ID
	set clVar_2 = alloc_OnCastListener_onCast_ShieldGenerator("when calling alloc_OnCastListener_onCast_ShieldGenerator in ShieldGenerator, line 149")
	call construct_OnCastListener(clVar_2)
	set eventCb = EventListener_onCast(temp_2, clVar_2, "when calling onCast in ShieldGenerator, line 149")
	call EventListener_onCast(ShieldGenerator_ABOVE_SHIELD_ID, eventCb, "when calling onCast in ShieldGenerator, line 170")
	set wurst_stack_depth = wurst_stack_depth - 1
	set temp = null
	set temp_1 = null
	return true
endfunction

function bridge_init_ShieldGenerator takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_ShieldGenerator("via function reference ShieldGenerator, line 1")
endfunction

function init_TimerUtils takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set TimerUtils_freeTimersCount = 0
	set TimerUtils_timerData = new_Table("when calling new_Table in TimerUtils, line 13")
	set TimerUtils_HELD = 679645218
	call new_HashMap("when calling new_HashMap in TimerUtils, line 59")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_TimerUtils takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_TimerUtils("via function reference TimerUtils, line 1")
endfunction

function hashtable_saveString takes hashtable this_1, integer parentKey, integer childKey, string value returns nothing
	call SaveStr(this_1, parentKey, childKey, value)
endfunction

function Table_saveString takes integer this_1, integer parentKey, string value returns nothing
	call hashtable_saveString(Table_ht, this_1, parentKey, value)
endfunction

function dispatch_Table_Table_Table_saveString takes integer this_1, integer parentKey, string value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this_1] == 0 then
		if this_1 == 0 then
			call error("Nullpointer exception when calling Table.saveString", "when calling error in Table, line 61")
		else
			call error("Called Table.saveString on invalid object.", "when calling error in Table, line 61")
		endif
	endif
	call Table_saveString(this_1, parentKey, value)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function initTypecastData takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_Table_Table_Table_saveString(TypeCasting_typecastdata, 0, "", "when calling saveString in TypeCasting, line 12")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function init_TypeCasting takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set TypeCasting_typecastdata = new_Table("when calling new_Table in TypeCasting, line 7")
	set TypeCasting_R2I_PRECISION = 1000.
	call initTypecastData("when calling initTypecastData in TypeCasting, line 15")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_TypeCasting takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_TypeCasting("via function reference TypeCasting, line 1")
endfunction

function popUnit takes nothing returns nothing
	set OnUnitEnterLeave_tempUnitsCount = OnUnitEnterLeave_tempUnitsCount - 1
endfunction

function pushUnit takes unit u returns nothing
	set OnUnitEnterLeave_tempUnits[OnUnitEnterLeave_tempUnitsCount] = u
	set OnUnitEnterLeave_tempUnitsCount = OnUnitEnterLeave_tempUnitsCount + 1
endfunction

function unit_makeAbilityPermanent takes unit this_1, integer abil, boolean flag returns boolean
	return UnitMakeAbilityPermanent(this_1, flag, abil)
endfunction

function prepareUnit takes unit u returns nothing
	local unit receiver = u
	local unit receiver_1
	call unit_addAbility(receiver, OnUnitEnterLeave_ABILITY_ID)
	set receiver_1 = receiver
	call unit_makeAbilityPermanent(receiver_1, OnUnitEnterLeave_ABILITY_ID, true)
	call pushUnit(u)
	call trigger_evaluate(OnUnitEnterLeave_eventTrigger)
	call popUnit()
	set receiver = null
	set receiver_1 = null
endfunction

function code__Filter_registerEnterRegion_nullTimer_OnUnitEnterLeave takes nothing returns nothing
	call prepareUnit(GetFilterUnit())
endfunction

function code__ForGroup_nullTimer_OnUnitEnterLeave takes nothing returns nothing
	call prepareUnit(GetEnumUnit())
endfunction

function code__addAction_Character takes nothing returns nothing
	call CustomVictoryBJ(GetLocalPlayer(), true, false)
endfunction

function trigger_disable takes trigger this_1 returns nothing
	call DisableTrigger(this_1)
endfunction

function code__addAction_Character_550 takes nothing returns nothing
	local real tuple_temp = rect_getCenter(gg_rct_Checkpoint)
	local real tuple_temp_1 = rect_getCenter_return_y
	set Character_checkpoint_x = tuple_temp
	set Character_checkpoint_y = tuple_temp_1
	call printTimed("|cFFC3DBFFYou've reached the checkpoint!|r", 5.)
	call trigger_disable(GetTriggeringTrigger())
endfunction

function trigger_registerUnitEvent takes trigger this_1, unit whichUnit, unitevent whichEvent returns event
	return TriggerRegisterUnitEvent(this_1, whichUnit, whichEvent)
endfunction

function registerEventsForUnit takes unit u returns nothing
	if fireEvents(u) then
		call trigger_registerUnitEvent(ClosureEvents_unitTrig, u, EVENT_UNIT_DAMAGED)
	endif
endfunction

function code__onUnitIndex_ClosureEvents takes nothing returns nothing
	call registerEventsForUnit(getIndexingUnit())
endfunction

function trigger_execute takes trigger this_1 returns nothing
	call TriggerExecute(this_1)
endfunction

function unit_getAbilityLevel takes unit this_1, integer id_1 returns integer
	return GetUnitAbilityLevel(this_1, id_1)
endfunction

function code__registerPlayerUnitEvent_nullTimer_OnUnitEnterLeave takes nothing returns nothing
	local unit leavingUnit = GetTriggerUnit()
	if unit_getAbilityLevel(leavingUnit, OnUnitEnterLeave_ABILITY_ID) == 0 and GetIssuedOrderId() == OrderIds_undefend then
		call pushUnit(leavingUnit)
		call trigger_execute(OnUnitEnterLeave_eventTrigger)
		call popUnit()
	endif
	set leavingUnit = null
endfunction

function code__startPeriodic_GameTimer takes nothing returns nothing
	set GameTimer_currentTime = GameTimer_currentTime + Basics_ANIMATION_PERIOD
endfunction

function init_Abilities takes nothing returns boolean
	set Abilities_farseerMissile = "Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdx"
	set Abilities_vengeanceMissile = "Abilities\\Weapons\\VengeanceMissile\\VengeanceMissile.mdx"
	return true
endfunction

function init_AbilityIds takes nothing returns boolean
	set AbilityIds_inventory = 1095331446
	return true
endfunction

function init_AbilityObjEditing takes nothing returns boolean
	return true
endfunction

function init_Angle takes nothing returns boolean
	set Angle_DEGTORAD = 0.017453293
	set Angle_RADTODEG = 57.295779513
	return true
endfunction

function init_AttachmentPoints takes nothing returns boolean
	return true
endfunction

function init_Basics takes nothing returns boolean
	set Basics_ANIMATION_PERIOD = 0.030
	set Basics_MAX_COLLISION_SIZE = 197.0
	set Basics_DUMMY_PLAYER = Player_players[PLAYER_NEUTRAL_PASSIVE]
	return true
endfunction

function int_bitOr takes integer this_1, integer other returns integer
	return BlzBitOr(this_1, other)
endfunction

function int_bitXor takes integer this_1, integer other returns integer
	return BlzBitXor(this_1, other)
endfunction

function initPows takes nothing returns nothing
	local integer allPows
	local integer i
	local integer temp
	local integer i_1
	local integer temp_1
	set BitSet_pows[0] = 1
	set allPows = 1
	set i = 1
	set temp = BitSet_BITSET_SIZE - 1
	loop
		exitwhen i > temp
		set BitSet_pows[i] = BitSet_pows[i - 1] * 2
		set allPows = int_bitOr(allPows, BitSet_pows[i])
		set i = i + 1
	endloop
	set i_1 = 0
	set temp_1 = BitSet_BITSET_SIZE - 1
	loop
		exitwhen i_1 > temp_1
		call int_bitXor(allPows, BitSet_pows[i_1])
		set i_1 = i_1 + 1
	endloop
endfunction

function init_BitSet takes nothing returns boolean
	set BitSet_BITSET_SIZE = 32
	call initPows()
	return true
endfunction

function init_BuffIds takes nothing returns boolean
	return true
endfunction

function init_Buildings takes nothing returns boolean
	return true
endfunction

function init_ClosureForGroups takes nothing returns boolean
	local real tuple_temp
	local real tuple_temp_1
	set ClosureForGroups_DUMMY_GROUP = CreateGroup()
	set ClosureForGroups_tempCallbacksCount = 0
	set ClosureForGroups_maxCount = Integer_INT_MAX
	set ClosureForGroups_iterCount = 0
	set ClosureForGroups_filter = Filter(ref_function_bridge_code__Filter_ClosureForGroups)
	set ClosureForGroups_tempCallbacksDCount = 0
	call Rect(0., 0., 0., 0.)
	set tuple_temp = Vectors_ZERO2_x
	set tuple_temp_1 = Vectors_ZERO2_y
	return true
endfunction

function init_ClosureTimers takes nothing returns boolean
	set ClosureTimers_x = 200
	return true
endfunction

function init_Destructable takes nothing returns boolean
	return true
endfunction

function init_Doodads takes nothing returns boolean
	return true
endfunction

function init_ErrorHandling takes nothing returns boolean
	set ErrorHandling_MUTE_ERROR_DURATION = 60
	set ErrorHandling_PRIMARY_ERROR_KEY = -1
	set ErrorHandling_HT = hashtable_compiletime_479
	set ErrorHandling_suppressErrorMessages = false
	return true
endfunction

function init_GameTimer takes nothing returns boolean
	local timer receiver = CreateTimer()
	call timer_start(receiver, 100000., null)
	call timer_startPeriodic(CreateTimer(), Basics_ANIMATION_PERIOD, ref_function_code__startPeriodic_GameTimer)
	set receiver = null
	return true
endfunction

function init_Group takes nothing returns boolean
	set Group_ENUM_GROUP = CreateGroup()
	return true
endfunction

function init_HashList takes nothing returns boolean
	set HashList_ht = hashtable_compiletime
	set HashList_occurences = hashtable_compiletime_478
	return true
endfunction

function init_Icons takes nothing returns boolean
	return true
endfunction

function init_Integer takes nothing returns boolean
	set Integer_INT_MAX = 2147483647
	return true
endfunction

function init_ItemIds takes nothing returns boolean
	return true
endfunction

function init_Lightning takes nothing returns boolean
	set Lightning_LIGHTNING_CHAIN_LIGHTNING_PRIMARY = "CLPB"
	set Lightning_LIGHTNING_DRAIN = "DRAB"
	set Lightning_LIGHTNING_FINGER_OF_DEATH = "AFOD"
	return true
endfunction

function init_MagicFunctions takes nothing returns boolean
	set MagicFunctions_compiletime = false
	return true
endfunction

function rect_getMaxX takes rect this_1 returns real
	return GetRectMaxX(this_1)
endfunction

function rect_getMaxY takes rect this_1 returns real
	return GetRectMaxY(this_1)
endfunction

function rect_getMinX takes rect this_1 returns real
	return GetRectMinX(this_1)
endfunction

function rect_getMinY takes rect this_1 returns real
	return GetRectMinY(this_1)
endfunction

function region_addRect takes region this_1, rect rct returns nothing
	call RegionAddRect(this_1, rct)
endfunction

function initMapBounds takes nothing returns nothing
	local rect cond_result
	local region receiver
	local rect cond_result_1
	local region receiver_1
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	if MagicFunctions_compiletime then
		set cond_result = Rect(-1024., -1024., 1024., 1024.)
	else
		set cond_result = GetPlayableMapRect()
	endif
	set MapBounds_playableMapRect = cond_result
	set receiver = CreateRegion()
	call region_addRect(receiver, MapBounds_playableMapRect)
	if MagicFunctions_compiletime then
		set cond_result_1 = Rect(-1536., -1536., 1536., 1536.)
	else
		set cond_result_1 = GetWorldBounds()
	endif
	set MapBounds_boundRect = cond_result_1
	set receiver_1 = CreateRegion()
	call region_addRect(receiver_1, MapBounds_boundRect)
	set MapBounds_boundRegion = receiver_1
	set tuple_temp = rect_getMinX(MapBounds_playableMapRect)
	set tuple_temp_1 = rect_getMinY(MapBounds_playableMapRect)
	set MapBounds_playableMin_x = tuple_temp
	set MapBounds_playableMin_y = tuple_temp_1
	set tuple_temp_2 = rect_getMaxX(MapBounds_playableMapRect)
	set tuple_temp_3 = rect_getMaxY(MapBounds_playableMapRect)
	set MapBounds_playableMax_x = tuple_temp_2
	set MapBounds_playableMax_y = tuple_temp_3
	set tuple_temp_4 = rect_getMinX(MapBounds_boundRect)
	set tuple_temp_5 = rect_getMinY(MapBounds_boundRect)
	set MapBounds_boundMin_x = tuple_temp_4
	set MapBounds_boundMin_y = tuple_temp_5
	set tuple_temp_6 = rect_getMaxX(MapBounds_boundRect)
	set tuple_temp_7 = rect_getMaxY(MapBounds_boundRect)
	set MapBounds_boundMax_x = tuple_temp_6
	set MapBounds_boundMax_y = tuple_temp_7
	call vec2_op_mult(vec2_op_plus(MapBounds_playableMin_x, MapBounds_playableMin_y, MapBounds_playableMax_x, MapBounds_playableMax_y), vec2_op_plus_return_y, .5)
	call vec2_op_mult(vec2_op_plus(MapBounds_boundMin_x, MapBounds_boundMin_y, MapBounds_boundMax_x, MapBounds_boundMax_y), vec2_op_plus_return_y, .5)
endfunction

function init_MapBounds takes nothing returns boolean
	call initMapBounds()
	return true
endfunction

function init_Maths takes nothing returns boolean
	set Maths_PI = 3.141592654
	return true
endfunction

function init_Matrices takes nothing returns boolean
	local real tuple_temp = 0.
	local real tuple_temp_1 = 0.
	local real tuple_temp_2 = 0.
	local real tuple_temp_3 = 0.
	local real tuple_temp_4 = 0.
	local real tuple_temp_5 = 0.
	local real tuple_temp_6 = 0.
	local real tuple_temp_7 = 0.
	local real tuple_temp_8 = 0.
	local real tuple_temp_9 = 0.
	local real tuple_temp_10 = 0.
	local real tuple_temp_11 = 0.
	local real tuple_temp_12 = 0.
	local real tuple_temp_13 = 0.
	local real tuple_temp_14 = 0.
	local real tuple_temp_15 = 0.
	set Matrices_ZERO44_m00 = tuple_temp
	set Matrices_ZERO44_m01 = tuple_temp_1
	set Matrices_ZERO44_m02 = tuple_temp_2
	set Matrices_ZERO44_m03 = tuple_temp_3
	set Matrices_ZERO44_m10 = tuple_temp_4
	set Matrices_ZERO44_m11 = tuple_temp_5
	set Matrices_ZERO44_m12 = tuple_temp_6
	set Matrices_ZERO44_m13 = tuple_temp_7
	set Matrices_ZERO44_m20 = tuple_temp_8
	set Matrices_ZERO44_m21 = tuple_temp_9
	set Matrices_ZERO44_m22 = tuple_temp_10
	set Matrices_ZERO44_m23 = tuple_temp_11
	set Matrices_ZERO44_m30 = tuple_temp_12
	set Matrices_ZERO44_m31 = tuple_temp_13
	set Matrices_ZERO44_m32 = tuple_temp_14
	set Matrices_ZERO44_m33 = tuple_temp_15
	return true
endfunction

function init_ObjectIds takes nothing returns boolean
	set ObjectIds_CHARMAP = ".................................!.#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
	return true
endfunction

function init_Objects takes nothing returns boolean
	return true
endfunction

function init_Orders takes nothing returns boolean
	set OrderIds_undefend = 852056
	return true
endfunction

function initPlayerArray takes nothing returns nothing
	local integer i = 0
	local integer temp = bj_MAX_PLAYER_SLOTS - 1
	loop
		exitwhen i > temp
		set Player_players[i] = Player(i)
		set i = i + 1
	endloop
endfunction

function init_Player takes nothing returns boolean
	set Player_localPlayer = GetLocalPlayer()
	call initPlayerArray()
	return true
endfunction

function init_Playercolor takes nothing returns boolean
	call ConvertPlayerColor(24)
	call ConvertPlayerColor(25)
	call ConvertPlayerColor(26)
	call ConvertPlayerColor(27)
	return true
endfunction

function init_Printing takes nothing returns boolean
	set Printing_DEBUG_LEVEL = 2
	set Printing_DEBUG_MSG_DURATION = 45.
	return true
endfunction

function init_Quaternion takes nothing returns boolean
	return true
endfunction

function init_Raycast takes nothing returns boolean
	local boolean tuple_temp = false
	local real tuple_temp_1 = Vectors_ZERO2_x
	local real tuple_temp_2 = Vectors_ZERO2_y
	local real tuple_temp_3 = 0.
	set Raycast_FAIL_2D_intersects = tuple_temp
	set Raycast_FAIL_2D_point_x = tuple_temp_1
	set Raycast_FAIL_2D_point_y = tuple_temp_2
	set Raycast_FAIL_2D_distance = tuple_temp_3
	set Raycast_EPSILON = 0.0001
	return true
endfunction

function init_Real takes nothing returns boolean
	set Real_REAL_MAX = 340282366920938000000000000000000000000.
	return true
endfunction

function init_Sounds takes nothing returns boolean
	return true
endfunction

function init_Soundsets takes nothing returns boolean
	return true
endfunction

function init_String takes nothing returns boolean
	set String_charset = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	set String_numberset = "0123456789"
	call string_length(String_numberset)
	call string_length(String_charset)
	return true
endfunction

function init_Table takes nothing returns boolean
	set Table_ht = hashtable_compiletime_480
	return true
endfunction

function init_TargetsAllowed takes nothing returns boolean
	return true
endfunction

function init_Textures takes nothing returns boolean
	return true
endfunction

function init_UI takes nothing returns boolean
	return true
endfunction

function init_UnitIds takes nothing returns boolean
	set UnitIds_shade = 1970497636
	return true
endfunction

function onEnter takes code c returns nothing
	call trigger_addCondition(OnUnitEnterLeave_eventTrigger, Filter(c))
endfunction

function onLeave takes code c returns nothing
	call trigger_addAction(OnUnitEnterLeave_eventTrigger, c)
endfunction

function init_UnitIndexer takes nothing returns boolean
	set UnitIndexer_onIndexTrigger = CreateTrigger()
	set UnitIndexer_onDeindexTrigger = CreateTrigger()
	set UnitIndexer_tempUnitsCount = 0
	call onEnter(ref_function_bridge_code__onEnter_UnitIndexer)
	call onLeave(ref_function_bridge_code__onLeave_UnitIndexer)
	return true
endfunction

function init_Units takes nothing returns boolean
	return true
endfunction

function init_Vectors takes nothing returns boolean
	local real tuple_temp = 0.
	local real tuple_temp_1 = 0.
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	set Vectors_ZERO2_x = tuple_temp
	set Vectors_ZERO2_y = tuple_temp_1
	set tuple_temp_2 = 0.
	set tuple_temp_3 = 0.
	set tuple_temp_4 = 0.
	set Vectors_ZERO3_x = tuple_temp_2
	set Vectors_ZERO3_y = tuple_temp_3
	set Vectors_ZERO3_z = tuple_temp_4
	set Vectors_tempLoc = Location(0., 0.)
	return true
endfunction

function init_WeatherEffects takes nothing returns boolean
	return true
endfunction

function initGlobals takes nothing returns nothing
	set gg_rct_Finish = null
	set gg_rct_Checkpoint = null
	set gg_rct_Start = null
	set gg_rct_RazorStart = null
	set gg_rct_RazorFinish = null
	set gg_rct_ShieldGeneratorSpawn = null
	set CallbackSingle_firstFree = 0
	set CallbackSingle_maxIndex = 0
	set EventListener_firstFree = 0
	set EventListener_maxIndex = 0
	set CallbackCounted_firstFree = 0
	set CallbackCounted_maxIndex = 0
	set OnCastListener_firstFree = 0
	set OnCastListener_maxIndex = 0
	set ForGroupCallback_firstFree = 0
	set ForGroupCallback_maxIndex = 0
	set ForGroupCallbackD_firstFree = 0
	set ForGroupCallbackD_maxIndex = 0
	set CallbackPeriodic_firstFree = 0
	set CallbackPeriodic_maxIndex = 0
	set Table_firstFree = 0
	set Table_maxIndex = 0
	set W3UDefinition_firstFree = 0
	set W3UDefinition_maxIndex = 0
	set Comparator_firstFree = 0
	set Comparator_maxIndex = 0
	set LLEntry_firstFree = 0
	set LLEntry_maxIndex = 0
	set LLIterator_firstFree = 0
	set LLIterator_maxIndex = 0
	set LinkedList_firstFree = 0
	set LinkedList_maxIndex = 0
	set BackIterator_firstFree = 0
	set BackIterator_maxIndex = 0
	set Iterator_firstFree = 0
	set Iterator_maxIndex = 0
	set IdGenerator_firstFree = 0
	set IdGenerator_maxIndex = 0
	set OrderStringFactory_firstFree = 0
	set OrderStringFactory_maxIndex = 0
	set Razor_firstFree = 0
	set Razor_maxIndex = 0
	set BackIterator_firstFree_7 = 0
	set BackIterator_maxIndex_11 = 0
	set Iterator_firstFree_160 = 0
	set Iterator_maxIndex_164 = 0
	set Segment_firstFree = 0
	set Segment_maxIndex = 0
	set BackIterator_firstFree_8 = 0
	set BackIterator_maxIndex_12 = 0
	set Iterator_firstFree_161 = 0
	set Iterator_maxIndex_165 = 0
	set Shield_firstFree = 0
	set Shield_maxIndex = 0
	set BackIterator_firstFree_9 = 0
	set BackIterator_maxIndex_13 = 0
	set Iterator_firstFree_162 = 0
	set Iterator_maxIndex_166 = 0
	set UnitIndex_firstFree = 0
	set UnitIndex_maxIndex = 0
	set ref_function_init_Abilities = function init_Abilities
	set ref_function_init_AbilityIds = function init_AbilityIds
	set ref_function_init_Real = function init_Real
	set ref_function_init_Integer = function init_Integer
	set ref_function_init_BitSet = function init_BitSet
	set ref_function_init_String = function init_String
	set ref_function_init_TargetsAllowed = function init_TargetsAllowed
	set ref_function_init_Angle = function init_Angle
	set ref_function_init_Vectors = function init_Vectors
	set ref_function_init_Destructable = function init_Destructable
	set ref_function_init_Player = function init_Player
	set ref_function_init_Maths = function init_Maths
	set ref_function_init_Printing = function init_Printing
	set ref_function_init_MagicFunctions = function init_MagicFunctions
	set ref_function_init_Basics = function init_Basics
	set ref_function_init_GameTimer = function init_GameTimer
	set ref_function_init_ErrorHandling = function init_ErrorHandling
	set ref_function_init_Matrices = function init_Matrices
	set ref_function_init_Quaternion = function init_Quaternion
	set ref_function_init_Table = function init_Table
	set ref_function_init_Playercolor = function init_Playercolor
	set ref_function_bridge_init_Colors = function bridge_init_Colors
	set ref_function_bridge_init_Framehandle = function bridge_init_Framehandle
	set ref_function_init_Group = function init_Group
	set ref_function_init_Lightning = function init_Lightning
	set ref_function_init_WeatherEffects = function init_WeatherEffects
	set ref_function_bridge_init_TypeCasting = function bridge_init_TypeCasting
	set ref_function_init_HashList = function init_HashList
	set ref_function_bridge_init_EventHelper = function bridge_init_EventHelper
	set ref_function_init_AbilityObjEditing = function init_AbilityObjEditing
	set ref_function_init_AttachmentPoints = function init_AttachmentPoints
	set ref_function_init_BuffIds = function init_BuffIds
	set ref_function_init_Buildings = function init_Buildings
	set ref_function_init_ClosureForGroups = function init_ClosureForGroups
	set ref_function_bridge_init_LinkedList = function bridge_init_LinkedList
	set ref_function_init_ObjectIds = function init_ObjectIds
	set ref_function_bridge_init_TimerUtils = function bridge_init_TimerUtils
	set ref_function_init_ClosureTimers = function init_ClosureTimers
	set ref_function_init_UnitIds = function init_UnitIds
	set ref_function_init_MapBounds = function init_MapBounds
	set ref_function_bridge_init_Preloader = function bridge_init_Preloader
	set ref_function_bridge_init_ObjectIdGenerator = function bridge_init_ObjectIdGenerator
	set ref_function_bridge_init_ChannelAbilityPreset = function bridge_init_ChannelAbilityPreset
	set ref_function_bridge_init_RegisterEvents = function bridge_init_RegisterEvents
	set ref_function_init_Orders = function init_Orders
	set ref_function_bridge_init_OnUnitEnterLeave = function bridge_init_OnUnitEnterLeave
	set ref_function_init_UnitIndexer = function init_UnitIndexer
	set ref_function_bridge_init_ClosureEvents = function bridge_init_ClosureEvents
	set ref_function_bridge_init_Character = function bridge_init_Character
	set ref_function_init_Doodads = function init_Doodads
	set ref_function_init_Icons = function init_Icons
	set ref_function_init_ItemIds = function init_ItemIds
	set ref_function_bridge_init_Missile = function bridge_init_Missile
	set ref_function_init_Objects = function init_Objects
	set ref_function_init_Raycast = function init_Raycast
	set ref_function_init_Sounds = function init_Sounds
	set ref_function_init_Soundsets = function init_Soundsets
	set ref_function_init_Textures = function init_Textures
	set ref_function_init_UI = function init_UI
	set ref_function_init_Units = function init_Units
	set ref_function_bridge_init_Segment = function bridge_init_Segment
	set ref_function_bridge_init_Razor = function bridge_init_Razor
	set ref_function_bridge_init_ShieldGenerator = function bridge_init_ShieldGenerator
	set ref_function_code__addAction_Character = function code__addAction_Character
	set ref_function_code__addAction_Character_538 = function code__addAction_Character_550
	set ref_function_code__onUnitIndex_ClosureEvents = function code__onUnitIndex_ClosureEvents
	set ref_function_bridge_code__onUnitDeindex_ClosureEvents = function bridge_code__onUnitDeindex_ClosureEvents
	set ref_function_bridge_EventListener_generalEventCallback = function bridge_EventListener_generalEventCallback
	set ref_function_bridge_code__Filter_ClosureForGroups = function bridge_code__Filter_ClosureForGroups
	set ref_function_bridge_code__EnumDestructablesInRect_ClosureForGroups = function bridge_code__EnumDestructablesInRect_ClosureForGroups
	set ref_function_code__startPeriodic_GameTimer = function code__startPeriodic_GameTimer
	set ref_function_bridge_code__registerPlayerUnitEvent_RegisterEvents = function bridge_code__registerPlayerUnitEvent_RegisterEvents
	set ref_function_bridge_Segment_updateAll = function bridge_Segment_updateAll
	set ref_function_bridge_code__onEnter_UnitIndexer = function bridge_code__onEnter_UnitIndexer
	set ref_function_bridge_code__onLeave_UnitIndexer = function bridge_code__onLeave_UnitIndexer
	set ref_function_bridge_code__addAction_nullTimer_ClosureEvents = function bridge_code__addAction_nullTimer_ClosureEvents
	set ref_function_bridge_code__addAction_nullTimer_ClosureEvents_510 = function bridge_code__addAction_nullTimer_ClosureEvents_501
	set ref_function_bridge_code__addAction_nullTimer_ClosureEvents_511 = function bridge_code__addAction_nullTimer_ClosureEvents_502
	set ref_function_bridge_code__registerPlayerUnitEvent_nullTimer_ClosureEvents = function bridge_code__registerPlayerUnitEvent_nullTimer_ClosureEvents
	set ref_function_bridge_CallbackCounted_staticCallback = function bridge_CallbackCounted_staticCallback
	set ref_function_bridge_CallbackPeriodic_staticCallback = function bridge_CallbackPeriodic_staticCallback
	set ref_function_bridge_code__start_CallbackSingle_ClosureTimers = function bridge_code__start_CallbackSingle_ClosureTimers
	set ref_function_code__Filter_registerEnterRegion_nullTimer_OnUnitEnterLeave = function code__Filter_registerEnterRegion_nullTimer_OnUnitEnterLeave
	set ref_function_code__registerPlayerUnitEvent_nullTimer_OnUnitEnterLeave = function code__registerPlayerUnitEvent_nullTimer_OnUnitEnterLeave
	set ref_function_code__ForGroup_nullTimer_OnUnitEnterLeave = function code__ForGroup_nullTimer_OnUnitEnterLeave
endfunction

function main takes nothing returns nothing
	local trigger initTrig
	call initGlobals()
	call initCompiletimeState()
	call SetCameraBounds(( - 7424.0) + GetCameraMargin(CAMERA_MARGIN_LEFT), ( - 7680.0) + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), ( - 7424.0) + GetCameraMargin(CAMERA_MARGIN_LEFT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), ( - 7680.0) + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
	call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
	call NewSoundEnvironment("Default")
	call SetAmbientDaySound("LordaeronSummerDay")
	call SetAmbientNightSound("LordaeronSummerNight")
	call SetMapMusic("Music", true, 0)
	call CreateRegions()
	call CreateAllUnits()
	call InitBlizzard()
	call InitGlobals()
	set initTrig = CreateTrigger()
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Abilities))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Abilities.", "when calling error in Abilities, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_AbilityIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package AbilityIds.", "when calling error in AbilityIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Real))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Real.", "when calling error in Real, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Integer))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Integer.", "when calling error in Integer, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_BitSet))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package BitSet.", "when calling error in BitSet, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_String))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package String.", "when calling error in String, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_TargetsAllowed))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package TargetsAllowed.", "when calling error in TargetsAllowed, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Angle))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Angle.", "when calling error in Angle, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Vectors))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Vectors.", "when calling error in Vectors, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Destructable))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Destructable.", "when calling error in Destructable, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Player))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Player.", "when calling error in Player, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Maths))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Maths.", "when calling error in Maths, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Printing))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Printing.", "when calling error in Printing, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_MagicFunctions))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package MagicFunctions.", "when calling error in MagicFunctions, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Basics))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Basics.", "when calling error in Basics, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_GameTimer))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package GameTimer.", "when calling error in GameTimer, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ErrorHandling))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ErrorHandling.", "when calling error in ErrorHandling, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Matrices))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Matrices.", "when calling error in Matrices, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Quaternion))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Quaternion.", "when calling error in Quaternion, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Table))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Table.", "when calling error in Table, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Playercolor))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Playercolor.", "when calling error in Playercolor, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Colors))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Colors.", "when calling error in Colors, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Framehandle))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Framehandle.", "when calling error in Framehandle, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Group))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Group.", "when calling error in Group, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Lightning))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Lightning.", "when calling error in Lightning, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_WeatherEffects))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package WeatherEffects.", "when calling error in WeatherEffects, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_TypeCasting))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package TypeCasting.", "when calling error in TypeCasting, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_HashList))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package HashList.", "when calling error in HashList, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_EventHelper))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package EventHelper.", "when calling error in EventHelper, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_AbilityObjEditing))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package AbilityObjEditing.", "when calling error in AbilityObjEditing, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_AttachmentPoints))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package AttachmentPoints.", "when calling error in AttachmentPoints, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_BuffIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package BuffIds.", "when calling error in BuffIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Buildings))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Buildings.", "when calling error in Buildings, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ClosureForGroups))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ClosureForGroups.", "when calling error in ClosureForGroups, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_LinkedList))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package LinkedList.", "when calling error in LinkedList, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ObjectIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ObjectIds.", "when calling error in ObjectIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_TimerUtils))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package TimerUtils.", "when calling error in TimerUtils, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ClosureTimers))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ClosureTimers.", "when calling error in ClosureTimers, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_UnitIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package UnitIds.", "when calling error in UnitIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_MapBounds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package MapBounds.", "when calling error in MapBounds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Preloader))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Preloader.", "when calling error in Preloader, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_ObjectIdGenerator))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ObjectIdGenerator.", "when calling error in ObjectIdGenerator, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_ChannelAbilityPreset))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ChannelAbilityPreset.", "when calling error in ChannelAbilityPreset, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_RegisterEvents))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package RegisterEvents.", "when calling error in RegisterEvents, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Orders))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Orders.", "when calling error in Orders, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_OnUnitEnterLeave))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package OnUnitEnterLeave.", "when calling error in OnUnitEnterLeave, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_UnitIndexer))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package UnitIndexer.", "when calling error in UnitIndexer, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_ClosureEvents))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ClosureEvents.", "when calling error in ClosureEvents, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Character))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Character.", "when calling error in Character, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Doodads))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Doodads.", "when calling error in Doodads, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Icons))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Icons.", "when calling error in Icons, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ItemIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ItemIds.", "when calling error in ItemIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Missile))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Missile.", "when calling error in Missile, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Objects))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Objects.", "when calling error in Objects, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Raycast))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Raycast.", "when calling error in Raycast, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Sounds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Sounds.", "when calling error in Sounds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Soundsets))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Soundsets.", "when calling error in Soundsets, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Textures))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Textures.", "when calling error in Textures, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_UI))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package UI.", "when calling error in UI, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Units))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Units.", "when calling error in Units, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Segment))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Segment.", "when calling error in Segment, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Razor))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Razor.", "when calling error in Razor, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_ShieldGenerator))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ShieldGenerator.", "when calling error in ShieldGenerator, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call DestroyTrigger(initTrig)
	set initTrig = null
endfunction

function InitCustomPlayerSlots takes nothing returns nothing
	call SetPlayerStartLocation(Player(0), 0)
	call SetPlayerColor(Player(0), ConvertPlayerColor(0))
	call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
	call SetPlayerRaceSelectable(Player(0), true)
	call SetPlayerController(Player(0), MAP_CONTROL_USER)
endfunction

function config takes nothing returns nothing
	call SetMapName("TRIGSTR_008")
	call SetMapDescription("")
	call SetPlayers(1)
	call SetTeams(1)
	call SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
	call DefineStartLocation(0, 2240.0,  - 6784.0)
	call InitCustomPlayerSlots()
	call SetPlayerSlotAvailable(Player(0), MAP_CONTROL_USER)
	call InitGenericPlayerSlots()
endfunction

